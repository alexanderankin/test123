package bzr;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StringList;

import common.threads.WorkRequest;
import common.threads.WorkerThreadPool;

/**
 * Refactored from p4plugin/Perforce.java
 *
 * A simple way to execute commands as child processes,
 * and get the output.
 * create an instance, setWorkDir(), call exec(), waitFor(), and
 * get the output with getOutput().
 *
 * stdout and stderr are merged into one common stream for simplicity.
 *
 * @author ezust
 *
 */
public class Command
{

    private ProcessBuilder pBuilder;
    private Process process;
    private StreamReader stdout;
    private Visitor visitor;
    private WorkRequest stdoutReq;
    /**
     *
     * @param args an array or sequence of String arguments,
     *       the first being the actual command to execute
     */
    public Command(String... args)
    {
        if (args.length < 1)
            throw new IllegalArgumentException("command is null");
        pBuilder = new ProcessBuilder(args);
        // merge stdout and stderr
        pBuilder.redirectErrorStream(true);
    }

    /** Set working directory for execution */
    void setWorkDir(File workDir)
    {
        pBuilder.directory(workDir);
    }

    public String toString() {
        StringList sl = new StringList();
        sl.addAll(pBuilder.command());
        String s = "(workdir=" + pBuilder.directory().toString() + ")";
        sl.add(s);
        return sl.join(" ");
    }
    /**
     * Executes the command specified as the args to the constructor,
     * returning true on success.
     *
     */
    public boolean exec() throws IOException
    {
        if (process != null)
            throw new IllegalStateException("can't reuse Command objects");

        // try to run the command.
        process = pBuilder.start();

        stdout = new StreamReader(process.getInputStream());
        WorkRequest[] reqs = WorkerThreadPool.getSharedInstance().runRequests(
            new Runnable[] { stdout });
        stdoutReq = reqs[0];
        return true;
    }

    /** Wait for the process to finish, and for the process's output to
     * buffer.
     * @throws InterruptedException
     */
    public void waitFor() throws InterruptedException
    {
        process.waitFor();
        stdoutReq.waitFor();
    }

    /**
     *  @return the entire output buffered as a String. */
    public String getOutput()
    {
        if (visitor != null)
            throw new IllegalStateException("no data is buffered if visitor is set");
        if (stdout == null)
            throw new IllegalStateException("command not being executed");
        if (!stdoutReq.isDone())
            throw new IllegalStateException("still reading from process");
        return stdout.getData();
    }

    /**
     * If the visitor is set to something non-null, instead of buffering the
     * output of the process, the CommandOutputReader will call the visitor
     * directly as soon as lines are read from the output of the process.
     * This makes the process more memory efficient when processing really
     * long outputs (like those generated by "p4 files"). Be aware that the
     * visitor's methods will be called from a thread that might not be the
     * AWT thread.
     *
     */
    public void setVisitor(Visitor v)
    {
        this.visitor = v;
    }

    public Process getProcess() {
        return process;
    }

    public boolean isSuccess() {
        return (process.exitValue() == 0);
    }

    public void showError(View v) {
        String msg = "Exit status: " + process.exitValue() ;
        Log.log(Log.ERROR, this, msg);
    }

    public void processOutput(Visitor visitor) {
        // break the list into individual lines.
        try {
            BufferedReader br = new BufferedReader(new StringReader(getOutput()));
            String line;
            while ((line = br.readLine()) != null)
                if (!visitor.process(line))
                    break;
            br.close();
        } catch (IOException ioe) {
            // not gonna happen for StringReader.
        }
    }


    private class StreamReader implements Runnable
    {

        private boolean foundError;
        private InputStream input;
        private StringBuilder data;

        public StreamReader(InputStream in)
        {
            this.input = in;

            this.data = new StringBuilder();
            this.foundError = false;
        }

        public String toString() {
            return Command.this.toString();
        }

        public void run()
        {
            try
            {
                byte[] buf = new byte[128];
                while (true)
                {
                    int read = input.read(buf);
                    if (read == -1)
                        break;

                    for (int i = 0; i < read; i++)
                        data.append((char) buf[i]);

                    if (visitor != null)
                    {
                        int idx;
                        while ((idx = data.indexOf("\n")) >= 0)
                        {
                            if (idx > 0 && data.charAt(idx - 1) == '\r')
                            {
                                // ah, windows.
                                idx--;
                            }
                            String line = data.substring(0, idx);
                            data.delete(0, idx + 1);
                            if (!foundError)
                            {
                                foundError = !visitor.process(line);
                            }
                            if (foundError)
                            {
                                break;
                            }
                        }
                    }
                }
            }
            catch (IOException ioe)
            {
                Log.log(Log.DEBUG, this, ioe);
            }
        }

        public String getData()
        {
            return data.toString();
        }

    }
    /**
     * Interface to implement a "visitor" pattern and make it easier to
     * process the output of the command (less "cookie cutter" code).
     */
    public static interface Visitor
    {
        /**
         * Called once for every line in the output.
         *
         * @return false if there is an error and/or we must stop reading the output.
         */
        public boolean process(String line);

    }
}
