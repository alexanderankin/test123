/*
 * NetRexxScriptPlugin.nrx - NetRexx jEdit Scripting Plugin
 * Copyright (C) 2009 Kermit Kiser
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

 Version 0.2.0 (Sep 23, 2012) 

    * change all classes to package netrexxscript - allows access to public interfaces from NetRexx scripts
    * change NetRexxC.jar to experimental after3.01 version with method resolution fixes - allows direct compile of TeeStream class
    * Add NetRexxScriptErrorList class - allows ErrorList plugin use to be optional
    * add check of new NetRexxA.exiting api (after3.01 version) -  allows us to force a new NetRexxA instance if script executed "Exit" instruction and killed the old one
    * add a copy of the new ant-netrexx.jar version - allows build even if the optional NetRexxC task was not installed with Ant
 
 Version 0.1.3 (Nov 30, 2009) 

    * Fix codepage output problem reported by George Hovey (TeeStream module)
    * Add flush button to console per George request (NetRexxScript module)
    * Change command entry field to HistoryTextField to allow recording and reentering commands (NetRexxScript)
    * fix bug - runbysearch was not correctly searching scriptpath in non preparse mode
    
 Version 0.1.2 (Nov 19, 2009) 

    *  Add check for active macro handler before creating one (fix prob with plugin manager restarts)
 
 Version 0.1.1 (Nov 07, 2009) (prep for second beta version)

    *  Add check for empty files (len<3) - issue error screen and exit
    *  Add outwin.commandstarted call for runmacro entry
 
 Version 0.1.0 (Oct 25, 2009) (first beta version, I hope!)

    *  Mod classloader and runmacro entry to load macro classes without a classpath search
    *  rebuild classloader in flush entry to unload any classes from memory

 Version 0.0.15 (Oct 22, 2009)

    *  Change to allow window to kill scripts started from menu runcurrent option
    *  allow command.nrx syntax on window command line
    *  Add custom classloader to execute java classes
    
 Version 0.0.14 (Oct 18, 2009)

    *  Add dockable window for script console output/input (final major feature!?)
 
 Version 0.0.13 (Oct 14, 2009)

    *  Trap parse error output and scan to flag errors in file buffers (requires ErrorList plugin)
 
 Version 0.0.12 (Oct 12, 2009)

    *  Add options for user specified classpath and scriptpath
 
 Version 0.0.11 (Oct 07, 2009)

    *  Change to use File.separator and File.pathSeparator chars for unix support
 
 Version 0.0.10 (Oct 07, 2009)

    *  Added function to run currently open script buffer
 
 Version 0.0.9 (Oct 05, 2009)

    *  Added code to change classpath system variable to include NetRexx before calling parse
       this seems to fix the problems with the missing netrexx.lang classes under the standard jEdit classpath
 
 Version 0.0.8 (Oct 03, 2009)

    *  Add plugin options panel for trace, verbosity, cache, flush, and preparse options
    *  added trace/notrace and verbosity parse options for user selection
    *  added code and option to prefix scripts with the jedit variables
    
 Version 0.0.7 (Sept. 29, 2009)

    *  Add new options for cache, flush, and preparse
    *  change class to extend EBPlugin and add handleMessage interface for editbus msgs to detect script changes
    *  added code to preserve parse results for cache flag and to locate and parse all files for preparse flag
    *  added code to open log viewer and show an error dialog box for parse errors
    
 Version 0.0.6 (Sept. 26, 2009)

    *  restore code to set scriptPath property as Macros.macro.getPath does not work in jEdit 4.2 and NetRexx scripts cannot call plugin code due to the different class loader structure
    *  add check for NetRexxC.jar in classpath and show error message panel if not found
    
Version 0.0.5 (Sept. 19, 2009)

    * remove pathing from jarfile access to allow placing in base jar directory
    * update startup code to copy all .nrx files in jar (except plugin classes) to macros\NetRexx directory
    * remove code to set scriptPath property and doc Macros.macro.getPath way to set the scriptPath variable
 
Version 0.0.4 (Sept. 18, 2009)

    * created html help file and added to the NetRexxScript.jar file. 

Version 0.0.3 (Sept. 2009)

    * created a macro.handler class and code to register it.
    * deactivated code in setup script that creates beanshell hooks.

Version 0.0.2 (Sept. 2009)

    * added netrexxscript.nrx setup script to scan directories and build beanshell invocation "hook" scripts for all NetRexx scripts.
    * added code to create NetRexx macro subdirectory and copy the setup script from the plugin jar to the subdirectory.  

Version 0.0.1 (Sept. 2009)

    * First version working - required hand coding of beanshell "hook" macros to start the NetRexx scripts with the same name. Solved the missing classpath problem using this one! 
 
 */
  
options strictsignal

--import errorlist
import org.gjt.sp.jedit.
import COM.ibm.netrexx.process.NetRexxA

package netrexxscript

class NetRexxScriptPlugin public extends EBPlugin implements runnable
	
		outwin=NetRexxScript				--	save pointer to dockable window	
		av=View								--	save pointer to jEdit active view	
	
	properties private
		
		interpreter = NetRexxA				--	holds NetRexx interpreter
		myloader=NetRexxScriptClassLoader	--	holds our custom class loader
--		flushinprogress="no"				--	flag to prevent flush loops
		
		cache="empty"						--	cache of parsed scriptnames
		backcache="empty"					--	cache of parsed scriptnames for reverse reference like error reporting
		revcache="empty"					--	cache of prefixed scriptnames (to avoid duplicates)
		
		parseset=String[0]					--	array of script file names to parse
		
		flags=[String 'nocrossref']			--  parse flags per NetRexx user guide as a String array		
		parseflags='nocrossref compact'		--  parse flags per NetRexx user guide as a Rexx item
		
		setdir=String 						--	pass location of settings directory
		ps=File.pathSeparator
		fs=File.separator
		origname=""							--	save original name for runcurrent temp script copy
		
		jcp=String 							--	save original java classpath
		nrcpath=String	""					--	save path to NetRexxC.jar
		errpath=String						--	save path to ErrorList.jar
		lastcpath=String ""					--	save classpath in use by the interpreter
	properties private unused
		lastspath=String ""					--	save scriptpath in use by the plugin
		mypath=String	""					--	save path to NetRexxScript.jar
	properties private
		
		df=boolean 0						--	debug flag defaults to "false"
		
--		errorsource=errorlist.DefaultErrorSource
		errorsource=NetRexxScriptErrorList

		sysin = InputStream
		sysout= PrintStream
		syserr= PrintStream
		tee1  = TeeStream
		tee2  = TeeStream
		tee3  = TeeStream
		out1  = PrintStream
		out2  = PrintStream
		bas1  = ByteArrayOutputStream
		bas2  = ByteArrayOutputStream

--									vars to run the script in it's own thread:
		sthread=Thread
		tparms=Rexx
		tmethod=Method
		
	properties private constant
		
		t=boolean 1		--	"true"
		f=boolean 0		--	"false"
		
	properties public static 
		
		scriptPath=String "bozo"

	properties public constant
		
		NAME = String  "NetRexxScript"
		OPTION_PREFIX = String "options.netrexxscript."
	    
--		Perform plugin initialization			---------------------------------------------------------------------------------------------------------------------

	method start()
		version=jEdit.getProperty("plugin.NetRexxScriptPlugin.version","notfound")
		System.out.println("NetRexxScript plugin version" version "starting")
 		do
		jf=JarFile(getPluginJAR.getFile)
		je=jf.getJarEntry("build.number")
		if je\=null then do
			ir=BufferedReader(InputStreamReader(jf.getInputStream(je)))
			/*l1=*/ ir.readline;l2=ir.readline;l3=ir.readline
--			l1=ir.readline;l2=ir.readline;l3=ir.readline
			System.out.println(l3" "Rexx(l2).substr(2))
			end
		catch ioe=IOException
			System.out.println("build.number" ioe.toString)
		end

		setdir=jEdit.getSettingsDirectory()	--	string with settings directory path (add \macros to get default script paths)		
		
--	init some permanent properties we will need later	
		
    	jEdit.setBooleanProperty(OPTION_PREFIX"debug",jEdit.getBooleanProperty(OPTION_PREFIX"debug",f)) 
    	df=jEdit.getBooleanProperty(OPTION_PREFIX"debug",f) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"clear",jEdit.getBooleanProperty(OPTION_PREFIX"clear",t)) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"trace",jEdit.getBooleanProperty(OPTION_PREFIX"trace",t)) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"cache",jEdit.getBooleanProperty(OPTION_PREFIX"cache",t)) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"preparse",jEdit.getBooleanProperty(OPTION_PREFIX"preparse",t)) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"addjeditvars",jEdit.getBooleanProperty(OPTION_PREFIX"addjeditvars",t))
    	jEdit.setProperty(OPTION_PREFIX"verbosity",jEdit.getProperty(OPTION_PREFIX"verbosity",'verbose3'))
    	jEdit.setProperty(OPTION_PREFIX"classpath",jEdit.getProperty(OPTION_PREFIX"classpath",""))   
    	jEdit.setProperty(OPTION_PREFIX"scriptpath",jEdit.getProperty(OPTION_PREFIX"scriptpath",""))       						
  		
--------------------   locate the NetRexxC.jar file so we can add it to the classpath for the interpreter  ----		
		jcp=System.getProperty(String "java.class.path")
		NRCS=String("NetRexxC.jar")
		
		if jcp.indexOf(NRCS)<0 then do
			ja=jEdit.getPluginJARs
			loop jp=0 to ja.length-1
				if ja[jp].getPath.indexOf(NRCS)>=0 then nrcpath=ja[jp].getPath
				if Rexx(ja[jp].getPath).pos("NetRexxScript.jar")\=0 then mypath=ja[jp].getPath
				if Rexx(ja[jp].getPath).pos("ErrorList.jar")\=0 then errpath=ja[jp].getPath
				end
			end		
			
--	create some external processors and hooks

		sysout=System.out									--	save original IO streams
		syserr=System.err
		sysin=System.in
		System.setIn(NetRexxScriptPlugin.sysin(sysin))		--	set intercept for "ask" instructions			
		bas1 = ByteArrayOutputStream(1000)					--	build some capture streams for output
		out1 = PrintStream(bas1,t)
		bas2 = ByteArrayOutputStream(1000)
		out2 = PrintStream(bas2,t)
		tee1 = TeeStream(System.out, out1)
		tee2 = TeeStream(System.err, out1)
		tee3 = TeeStream(tee1, out2)

		
		setclasspath('init')								-- set custom classpath
		say "load REXXIO class to pickup IO streams" 	 --  see if this sets printstream for "say" instructions		
		newloader											-- build a custom classloader
		newinterpreter										-- make a NetRexx interpreter with current classpath
		setclasspath('off')									 
			
		
		if Macros.getHandler("netrexx")=null then do	--	first start - load a macro handler
			mh=NetRexxScriptMacroHandler()						--	make a macro handler
			Macros.registerHandler(mh)							--	pass to jEdit
			end
		
		if errpath\=null then do
--		if errpath\="" then do
			errorsource=NetRexxScriptErrorList()
--			errorsource=errorlist.DefaultErrorSource("NetRexxScript")
--			ErrorSource.registerErrorSource(errorsource)
			end

	setup														--	perform any new user setup

--	run the provided setup script
			do
			execute(setdir||fs'NetRexx'fs'netrexxscript.nrx scan')		--	check for netrexx scripts and provide hooks
			cache='empty'								-- force cache empty before preparse check adds stuff
			backcache='empty'								-- force cache empty before preparse check adds stuff
			revcache="empty"
			end
		
		loop for 20											--	wait 2 secs for startup script, then kill it
			if sthread=null then leave
			Thread.sleep(100)
			catch oops=Exception
				say oops
			finally
				if sthread\=null then kill
			end		
			
-- if the preparse flag is on, try to parse all scripts we can find
	
		if jEdit.getBooleanProperty(OPTION_PREFIX"preparse") then -
			if \parseall then jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)	--	try to parse all current nrx script files				

		say "NetRexxScript plugin started"

method setup		--	initial setup stuff: creates directories and loads files from our jar
  						
--	create some directorys for NetRexx scripts

		scriptdir=String setdir||fs'macros'fs'NetRexx'
		tempdir=String setdir||fs'NetRexx'
		sdf=File(scriptdir)
		tdf=File(tempdir)
		if \sdf.exists then do
			sdf.mkdir
			if \sdf.exists then do
				say 'unable to create NetRexx script directory:' scriptdir
				return
				end
			end
		if \tdf.exists then do
			tdf.mkdir
			if \tdf.exists then do
				say 'unable to create NetRexx temp script directory:' tempdir
				jEdit.setBooleanProperty(OPTION_PREFIX"addjeditvars",f)
				return
				end
			end

--	install the setup and sample scripts

		do
			jf=JarFile(getPluginJAR.getFile)
			entries = jf.entries()
			loop while entries.hasMoreElements()				
				je=JarEntry entries.nextElement()
				if Rexx(je.getName).translate(fs,'/').pos('NetRexx'fs)>0 then copyjarentry(jf,je,setdir)
--	another Java "gotcha" - jar entries have unix file separators thus requireing the translate above					
				end
			catch err=Exception
				say "NetRexxScript.jar ==>" err
		end
	
-- shutdown the plugin:										-------------------------------------------------------------------------------------------------------
		
	method stop()
		interpreter = null
		System.setIn(sysin)						
		-- clear any error messages before quitting
		if errorsource\= null then do
 			errorsource.quit
/* 			errorsource.clear()
			ErrorSource.unregisterErrorSource(errorsource) */
			end
			
--	unload NetRexxC.jar in case of restarting plugin
	  nrc=jEdit.getPluginJAR(nrcpath)
	  jEdit.removePluginJAR(nrc,0)
			
		say "NetRexxScript plugin stopped"
 
	method commonentry -- make sure run time variables are current
		
		setdir=jEdit.getSettingsDirectory()	--	string with settings directory path	
		
		outwin=null
		av=jEdit.getActiveView
		if av\=null then do
			winout=jEdit.getActiveView.getDockableWindowManager.getDockableWindow(NAME)
			if winout=null then outwin=null
				else outwin=NetRexxScript winout
			end	
		myloader.setDebug(df)
		
-- main method called by macro selection or internally to execute a script:		-----------------------------------------------------------------------------------
		
	method execute(script=String,on=String "") -- analyze script request and execute it
		
		say "NetRexxScript execute" script
		if df then trace all
		origname=on							--	save original script name in case using runcurrent temp copy
	
		if sthread\=null then do
			say "another script is active - cannot execute:"script
			return
			end

--	analyze and verify the script request
		
		rscript=Rexx(script)' '
		if rscript.pos('.nrx ')=0 then do
			Macros.error(jEdit.getActiveView,"The file is not a NetRexx script:\n" rscript)
			if outwin\=null then do;outwin.commandended;end
			return
			end
		parse rscript sname '.nrx ' sparms		-- 	capture any passed parms
		sname=sname'.nrx'						--	reattach file type
		spath=sname.left(sname.lastpos(fs))
		sname=sname.substr(sname.lastpos(fs)+1)
		stype=sname.substr(sname.lastpos('.'))
		sname=sname.left(sname.lastpos('.')-1)
		fname=spath||sname||stype
		
		if jEdit.getBooleanProperty(OPTION_PREFIX"clear",t) then - 
			if outwin\=null then outwin.clearparseout
		
--	 parse the file(s)
		if \cache.exists(fname) then do		--	if the file is not already parsed, do it
			fchk=File(fname)
			if df then say "file len="fchk.length
			if fchk.length<3 then do
				Macros.error(jEdit.getActiveView,"Cannot execute empty file:\n" fname)
				if outwin\=null then outwin.commandended
				return
				end
			addtocache(spath,sname||stype)
			if \parse(fname) then return 	-- parse the file(s), using the flags
			end
				
		if \jEdit.getBooleanProperty(OPTION_PREFIX"cache") then do
			cache='empty'	-- if not using cache, force empty it
			backcache='empty'	-- if not using cache, force empty it
			revcache="empty"	-- if not using cache, force empty it
			end
			
--	save the scriptPath for access by the script			
		scriptPath=String(fname)
		jEdit.setTemporaryProperty("NetRexxScriptPath",scriptPath)		--		save scriptPath for jEdit 4.2 NetRexx script use

		loadandgo(sname,sparms)
		
	method loadandgo(sname=Rexx,sparms=String)		--	load a class and run it's main method
		if df then trace results
-- 	find the script's class
		sscript = String sname
		setclasspath('on')
		scriptClass=interpreter.getClassObject(null, sscript) 	-- find the script's class
		if scriptClass=null then do
			do				 
			scriptClass=myloader.loadClass(sscript)
			catch loaderror=Exception
				say "load error="loaderror
				say "NetRexxScript could not find class for" sname
				setclasspath('off')
			end
				
			if scriptClass=null then do
					if outwin\=null then do;outwin.commandended;end
					av=jEdit.getActiveView;if av=null then return
					Macros.error(av,"The command class could not be located:\n" sname )
					return
					end
			end
		
		justgo(scriptClass,sname,sparms)
			
	method justgo(scriptClass=Class,sname=Rexx,sparms=String)		--	load a class and run it's main method
		if df then trace results

--	find the 'main' method; it takes an array of Strings as its argument
		classes=[interpreter.getClassObject('java.lang', 'String', 1)]
		do
			mainMethod=scriptClass.getMethod('main', classes)
			if mainMethod=null then do
				say "could not find main method in" sname
				setclasspath('off')
				av=jEdit.getActiveView;if av=null then return
				if outwin\=null then do;outwin.commandended;end
				Macros.error(av,"The command method could not be located:\n" sname )
				return
				end
			catch e=Exception
				say e
				if outwin\=null then do;outwin.commandended;end
				setclasspath('off')
				return
			end

--	now invoke it with a separate thread to keep interface alive
		tmethod=mainMethod
		tparms=sparms
		sthread=Thread(this,sname)
		sthread.setDaemon(t)			--	insure thread ends if jEdit closes
		sthread.start

	method run
		
		invokeit(tmethod,tparms)
		
	method invokeit(mainMethod=Method,sparms) --signals IllegalAccessException			--	invoke it with a null instance (it's static)
		values=Object[1]
		sa=String[1];sa[0]=String sparms
		values[0]=sa
		setclasspath('on')				--	setup modified classpath for interpreter

		bas1.reset
		bas2.reset
		if outwin\=null then do
			tee3.setArea(outwin.getscriptout)
			tee2.setArea(outwin.gettraceout)
			tee1.setArea(outwin.gettraceout)
			outwin.commandstarted
			if jEdit.getBooleanProperty(OPTION_PREFIX"clear",t) then do 
				outwin.clearscriptout;outwin.cleartraceout;
				end
			outwin.show("scriptout")
			end

		do
			if df then say "mainMethod="mainMethod
			mainMethod.invoke(null, values)
			catch error=Exception
				say "invokeit error="error
				say "note ***: If NetRexxC is in the Java lib\\ext directory it will cause invocation exceptions."
				say error.getCause
				error.getCause.printStackTrace
			end

		cleancup						--	clean command environment up after done
		sthread=null					--  erase thread pointer
		
		if interpreter.exiting then do					--		reinit interpreter environment if someone used an "Exit" statement  2012-09-21
				newinterpreter
				flush
				end
			
	method cleancup						--	also called by kill thread entry point
		
		if outwin\=null then do
			tee3.setArea(null)
			tee2.setArea(null)
			tee1.setArea(null)
			outwin.show("scriptout")
			outwin.commandended					
			end
		bas1.reset
		bas2.reset
		setclasspath('off')				--	restore the original classpath value in case someone else checks it	
			
--	end of script execution method		--	start of externally called methods	---------------------------------
	
method kill
	if sthread\=null then sthread.stop
	sthread=null
	cleancup
	flush
		
method interrupt
	if sthread\=null then sthread.interrupt

method handleMessage(msg=EBMessage)		--	make sure we notice any changes made to a script
	if msg<=BufferUpdate then do
		bu = BufferUpdate msg
		if bu.getWhat="SAVED" then do
			if df then say "NetRexxScript handleMessage called:" bu
			bi=bu.getBuffer
			if df then say "name="bi.getName
			bpath=bi.getPath
			if df then say "path="bpath
			if Rexx(bi.getName).pos(".nrx")=0 then return
			backcache[cache[bpath]]=null		--	remove it from the cache
			cache[bpath]=null		--	remove it from the cache
			revcache[File(bpath).getName]=null
			if Rexx(bpath).pos("macros")>0 then Macros.loadMacros	--	rescan macros
			end
		end

method runmacro(script=String) -- called by macro menu selection
	if df then say "execute from macro menu="script
	if df then trace results
	commonentry
	if outwin=null then parms=""
		else do
			parms=" "outwin.getcmdline.getText
			outwin.commandstarted
			end
	if Rexx(script).pos(".class")>0 then do
		classmacro=myloader.loadThisClass(script)
		justgo(classmacro,script,parms)
		catch loadfail=Exception
			say "macro="script loadfail
		finally
			return
		end
		
	execute(script||parms)
		
method runbysearch(cmd=Rexx)			--	called by dockable window command line
	if df then say "execute by search="cmd
	if df then trace all
	commonentry
	parse cmd cmdname parms
	if cmdname.right(4)=".nrx" then cmdnrx=cmdname
							   else cmdnrx=cmdname".nrx"
	cmdbare=cmdnrx.left(cmdnrx.pos(".nrx")-1)
	if revcache.exists(cmdnrx) then do
		usename=revcache[cmdnrx]
		execute(usename' 'parms)
		return
		end
	findname=searchlibs(cmdbare)
	if findname\="" then execute(findname' 'parms)
					else loadandgo(cmdbare,parms)

method runcurrent(v=View,buf=Buffer,parms="") 
	if df then trace all
	commonentry
	tmpdir=setdir||fs||"NetRexx"fs"temp"
	tdf=File(tmpdir);if \tdf.exists then tdf.mkdirs
			
	if df then say 'parms='parms
	if df then say 'buf.getPath='buf.getPath
		on=buf.getPath
	if buf.isDirty then do
		if buf.isUntitled then tn=tmpdir||fs'current.nrx'		--		give it a temp name
			else tn=tmpdir||fs||buf.getName					--		give it a temp name
		tf=File(tn)
		if tf.exists then tf.delete							--		delete any old temp copy
		buf.save(v,tn,f)									--		save a temp copy of the file
		VFSManager.waitForRequests()						--		wait til save is done
		if cache.exists(tn) then backcache[cache[tn]]=null	--		invalidate any cache entry for the file
		if cache.exists(tn) then cache[tn]=null				--		invalidate any cache entry for the file
		if cache.exists(buf.getPath) then cache[buf.getPath]=null  --  invalidate any cache entry for the file
		if revcache.exists(tf.getName) then revcache[tf.getName]=null	--	invalidate any cache entry for the file
		if tf.canRead then execute(tn' 'parms,on)						--		run it if we got it
		if cache.exists(tn) then backcache[cache[tn]]=null	--		invalidate any cache entry for the file
		if cache.exists(tn) then cache[tn]=null				--		invalidate any cache entry for the file
		if revcache.exists(tf.getName) then revcache[tf.getName]=null	--	invalidate any cache entry for the file
		return
		end
		
	execute(buf.getPath' 'parms)										--	run an unmodified script

method getClassPath
	if df then trace results
	ucp=jEdit.getProperty(OPTION_PREFIX"classpath","")			--	get the user specified classpath
	return Rexx(jcp||ps||nrcpath||ps||ucp).strip('b',ps)

method getScriptPath
	if df then trace results
	usp=jEdit.getProperty(OPTION_PREFIX"scriptpath","")			--	get the user specified scriptpath
	md=setdir||fs||"macros"										--	jEdit macro directories
	return Rexx(usp||ps||md).strip('b',ps)
	
method optionflush		--	clears the cache and resets classpath/scriptpath if options are changed

	df=jEdit.getBooleanProperty(OPTION_PREFIX"debug",f) 		--	options may have changed
	if df then trace results
		
	newcpath=getClassPath
	if newcpath\=lastcpath then do
		setclasspath("on")
		newinterpreter					--	if class path changed, rebuild interpreter
		setclasspath("off")
		end
	
	newspath=getScriptPath
	lastcpath=newcpath
	lastspath=newspath
	flush													--	if path changes, flush memory
	
method flush		--	clears the cache by user menu request
	say "NetRexxScript flush called"
	cache="empty"
	backcache="empty"
	revcache="empty"
	newloader				--		rebuild loader to clear any classes from memory
	if jEdit.getBooleanProperty(OPTION_PREFIX"preparse") then -
	  if \parseall then jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)	--	try to parse all current nrx script files
	
method newloader	--	create a new classloader (and flush any loaded classes from memory)
	
	thisloader=this.getClass.getClassLoader
	md=setdir||fs||"macros"
	myloader=NetRexxScriptClassLoader(thisloader,jEdit.getProperty(OPTION_PREFIX"classpath","")||ps||md)
	myloader.setDebug(df)
			
method cache		--		change the cache flag
	say "NetRexxScript cache called"
	if jEdit.getBooleanProperty(OPTION_PREFIX"cache") then do
			jEdit.setBooleanProperty(OPTION_PREFIX"cache",f)		--	turn off cache
			jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)	--	cannot preparse if no cache
			cache='empty'
			backcache='empty'
			revcache="empty"
			end
		else jEdit.setBooleanProperty(OPTION_PREFIX"cache",t)
	
method preparse		--	sets the preparse flag and parses all scripts as requested
	say "NetRexxScript preparse called"
	if jEdit.getBooleanProperty(OPTION_PREFIX"preparse") then 		--	turn off preparse and empty the cache
		do
		jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)
		cache='empty'
		backcache='empty'
		revcache="empty"
		end
		else do
			jEdit.setBooleanProperty(OPTION_PREFIX"cache",t)		--	requires cacheing
			jEdit.setBooleanProperty(OPTION_PREFIX"preparse",t)	--	turn on preparse flag
			if \parseall then jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)	--	try to parse all current nrx script files
			end

-------------------------------------------------	start of internal utility methods: ------------------------			

method buildparseset	--	build an array of strings with file names to parse from the script name cache		
	cc=0;loop cn over cache;cc=cc+1;end	--	count cached files
	if cc>0 then do						--	rebuild the cache of parsed scripts if any left
		parseset=String[cc]					--	reserve name array space
		cc=0;loop cn over cache;parseset[cc]=cache[cn];
			if df then say cn'='cache[cn]
			cc=cc+1;end	--	build an array of file names to parse
		end
		else parseset=String[0]			--	nothing to parse

method setclasspath(o=Rexx)				--	temporarily alter the classpath for the NetRexx interpreter	

--	if df then say "java.class.path was="System.getProperty( "java.class.path" )			
	if 'on init'.pos(o)>0 then do
		newcpath=getClassPath
		System.setProperty(String "java.class.path",newcpath)		--	add NetRexx and user stuff to the classpath
		System.setOut(tee3)
		System.setErr(tee2)
		if o="init" then do
			lastcpath=newcpath
			lastspath=getScriptPath
			end
		end
	else do						--	reset all to vanilla (don't confuse other programs using this thread)
		System.setProperty(String "java.class.path",jcp)
		System.setOut(sysout)
		System.setErr(syserr)
		end
--	if df then say "java.class.path is="System.getProperty( "java.class.path" )			

method newinterpreter

		interpreter = NetRexxA()   -- make a NetRexx interpreter with current classpath
--		say "NetRexx interpreter loaded"  --  see if this sets printstream for "say" instructions
	
method parseall							--		if preparse flag is set then we parse all found scripts here:
	if df then say "NetRexxScript parseall called"
	buildcache													--	get all script file names
	success=parse('all') 					--  parse the file(s), using the flags
	return success
	
method parse(fn=Rexx)
	buildparseset												--	build array of file name strings for parse call
	getoptions													--	set parse options array from properties
	setclasspath('on')
	if errorsource\= null then errorsource.clear
--	if outwin\=null then outwin.clearparseout	
	
	if parseset.length >0 then success=interpreter.parse(parseset, flags) --  parse the file(s), using the flags
		else success=1
	if df then say "script parse completed with code=" success

--	report any errors to ErrorList plugin and dock window:		
--				[C:\Documents and Settings\dad\.jedit\NetRexx\prefixed\error.nrx 1 424 4] Error: Keyword symbol expected
	ereader=BufferedReader(InputStreamReader(ByteArrayInputStream(bas1.toByteArray)),1000)
	loop while ereader.ready
		erl=ereader.readLine
		if df then say "parse out==>"erl
		if Rexx(erl).left(1)="[" then do
			parse erl '[' erlpref ']' emsg
			parse erlpref tfn eln eloc elen .
			parse emsg etype .
			if tfn.pos('prefixed')>0 then -					--	is file prefixed
				if eln = 1 then do;pff=File(setdir||fs||'NetRexx'fs'prefix.txt');eloc=eloc-pff.length;if df then say eloc pff.length;end	
			tfn=backcache[tfn.translate(' ','\0')]
			if errorsource \= null then do
--			if errpath \= null then do
				if etype="Warning:" then errorsource.addError(NetRexxScriptErrorList.WARNING,tfn,eln-1,eloc-1,eloc+elen-1,emsg)
					else errorsource.addError(NetRexxScriptErrorList.ERROR,tfn,eln-1,eloc-1,eloc+elen-1,emsg)
/* 				if etype="Warning:" then errorsource.addError(ErrorSource.WARNING,tfn,eln-1,eloc-1,eloc+elen-1,emsg)
					else errorsource.addError(ErrorSource.ERROR,tfn,eln-1,eloc-1,eloc+elen-1,emsg) */
				end
			if outwin\=null then outwin.addparseout('['tfn eln eloc elen']' emsg||"\n")
			end
		  else if outwin\=null then outwin.addparseout(erl||"\n")
		catch eio=IOException
			say eio
		end	
	
	if success=0 then do		--	handle any error in parse here
		if fn='all' then say "NetRexxScript parse all failed."
			else say "NetRexxScript execute failed:" fn
		av=jEdit.getActiveView;if av=null then return 0
		wm=jEdit.getActiveView.getDockableWindowManager()
		if outwin=null then do
			wm.showDockableWindow("log-viewer")
			if \wm.isDockableWindowVisible("log-viewer") then wm.toggleDockableWindow("log-viewer")
			jc=Component wm.getDockableWindow("log-viewer")
			end
			else do;jc=av;outwin.show('parseout');outwin.commandended;end
		if fn='all' then do
			cache='empty'	--	clear the cache
			backcache='empty'	--	clear the cache
			revcache="empty"
			if outwin=null then -
				 Macros.error(jc,"One or more NetRexx scripts failed to parse correctly - cache flushed - please check the activity log for messages:\n")
			else Macros.error(jc,"One or more NetRexx scripts failed to parse correctly - cache flushed - please check the parse log for messages:\n")
			end
		  else do
			backcache[cache[fn]]=null		--	remove it from the cache
			cache[fn]=null		--	remove it from the cache
			revcache[File(fn).getName]=null
			if outwin=null then -			
				 Macros.error(jc,"The script failed to parse correctly - please check the activity log for messages:\n" fn )
			else Macros.error(jc,"The script failed to parse correctly - please check the parse log for messages:\n" fn )
			buildparseset			--	build array of file name strings for parse call
			if parseset.length>0 then do					--	rebuild the cache of parsed scripts if any left
				redosuccess=interpreter.parse(parseset, flags) 	-- parse the file(s), using the flags
				if df then say "script reparse completed with code=" redosuccess
				end		  	  
		    end
		end	
		
	setclasspath('off')
	bas1.reset			 	
	bas2.reset			 	
	return success
	
method getoptions				--		read parse options and use to build a parse flags array
	
	if jEdit.getBooleanProperty(OPTION_PREFIX"trace") then popts=parseflags 'trace'
													  else popts=parseflags 'notrace'
																		  	  
	popts=popts jEdit.getProperty(OPTION_PREFIX"verbosity","verbose3")	
	if df then say "popts="popts
	flags=String[popts.words]
	loop i=0 to popts.words-1;flags[i]=popts.word(i+1);end

method searchlibs(scriptname)			--	scans script library path for a script by class name
	if df then trace all
	ulp=jEdit.getProperty(OPTION_PREFIX"scriptpath","")  -- get the user specified scriptpath
	loop while ulp\="" 
		parse ulp nextpath (ps) ulp
		if df then say "nextpath="nextpath
		ne=File(nextpath)
		if ne.isFile then if scriptname'.nrx'=ne.getName then return ne.getPath;else nop
			else do
				scriptpath=searchdir(nextpath,scriptname)
				if scriptpath\="" then return scriptpath
				end
		end
		
	d1=setdir||fs'macros'
	return searchdir(d1,scriptname)
	
method searchdir(dir,scriptname)
	if df then trace all
	filter=nrxFilter()
	if df then say "searching dir:"dir
	dirf=File(dir)
	scriptpath=checklist(dir,dirf.list(filter),scriptname)	--	first check any scripts in the dir
	if scriptpath\="" then return scriptpath
		
	fa=dirf.listFiles						--	array of names in the directory
	loop i=0 to fa.length-1					--	second search any subdirectories
		if fa[i].isDirectory then scriptpath=searchdir(fa[i].getPath,scriptname)	--	recursive call to self for subdirs
		if scriptpath\="" then return scriptpath
		end
		
	return ""

method checklist(dir=Rexx,fa=String[],scriptname)
	if df then trace all
	if fa.length=0 then return ""
	loop i=0 to fa.length-1
		if df then say fa[i]
		if scriptname".nrx"=fa[i] then return dir||fs||scriptname".nrx"
		end
	return ""
		
method buildcache			--	builds a cache array of script names to preparse - 1st macro dirs then user dirs
	
	d1=setdir||fs'macros'
	addadirtocache(d1)
	
	ulp=jEdit.getProperty(OPTION_PREFIX"scriptpath","")  -- get the user specified scriptpath
	loop while ulp\="" 
		parse ulp nextpath (ps) ulp
		if df then say "nextpath="nextpath
		ne=File(nextpath)
		if ne.isFile then addtocache(ne.getParent||fs,ne.getName)
			else addadirtocache(nextpath)
		end

	if df then say "---------parseset--------"
	if df then loop cn over cache;say cn'='cache[cn];end
		
method addadirtocache(dir=Rexx)		--	add all NetRexx files in a directory and it's subdirectories to cache		
	filter=nrxFilter()
	if df then say "adding dir to cache:"dir
	dirf=File(dir)
	addalltocache(dir,dirf.list(filter))	--	first add any scripts in the dir to the cache
	
	fa=dirf.listFiles						--	array of names in the directory
	loop i=0 to fa.length-1					--	second add any subdirectories to the cache (lower precedence)
		if fa[i].isDirectory then addadirtocache(fa[i].getPath)	--	recursive call to self for subdirs
		end
	
method addalltocache(dir=Rexx,fa=String[])
	if fa.length=0 then return
	loop i=0 to fa.length-1
		if df then say fa[i]
		addtocache(dir||fs,fa[i])
		end
		
method addtocache(dir=Rexx,sn=Rexx)
	
	if revcache.exists(sn) then return 			--	don't allow duplicate script names
	if df then say "adding dir="dir "name="sn
	if \jEdit.getBooleanProperty(OPTION_PREFIX"addjeditvars") then do
		cache[dir||sn]=dir||sn
		backcache[dir||sn]=dir||sn
		if origname \= "" then backcache[dir||sn]=origname
		revcache[sn]=dir||sn
		return
		end
	do
	scriptreader=BufferedReader(FileReader(dir||sn))
	scriptreader.mark(4096);line1=scriptreader.readline;scriptreader.reset	--	look at the first line of the script
	liner=Rexx(line1);liner=liner.translate(' ','\t');parse liner command .					--	extract a command keyword
	if 'import options package class'.wordpos(command) <>0 then do  	--	if user controlling things, don't prefix the script
		cache[dir||sn]=dir||sn
		backcache[dir||sn]=dir||sn
		if origname \= "" then backcache[dir||sn]=origname		
		revcache[sn]=dir||sn
		return
		end
	
	nrsdir=String setdir||fs'NetRexx'
	tempdir=String setdir||fs'NetRexx'fs"prefixed"
	tdf=File(tempdir);if \tdf.exists then tdf.mkdirs
	tf=File(tempdir||fs||sn)
	if tf.exists then tf.delete					--		clear any old modified file version
	tofw=BufferedWriter(FileWriter(tf,1))		--		open temp file with append
	
	prefixreader=BufferedReader(FileReader(nrsdir||fs'prefix.txt'))
	copyfile(prefixreader,tofw)					--		copy the prefix to the temp script file
	
	copyfile(scriptreader,tofw)					--		copy the script to temp output file
	cache[dir||sn]=tempdir||fs||sn				--		point parse to modified script file
	backcache[tempdir||fs||sn]=dir||sn			--		set back pointer for error reporting	
	if origname \= "" then backcache[tempdir||fs||sn]=origname	--	set back pointer for error reporting	
	revcache[sn]=dir||sn						--		reverse link the script name for duplicate checks
	tofw.close
	prefixreader.close
	scriptreader.close

	catch err=Exception
		say "addtocache error ==>" err
	end

------------------------------------------------------ general purpose routines -------------------------------------------------------

method copyjarentry(jf=JarFile,je=JarEntry,scriptdir=String)	--	method to copy a jarfile entry to a directory
	if df then trace results	
	nrscript=scriptdir||fs||je.getName
	nrs=File(nrscript)
	if \nrs.exists then do
		rc=copyjarentrytofile(jf,je,nrs)
		if rc=1 then say je.getName "copied to:" scriptdir
		end
		
method copyjarentrytofile(jf=JarFile,je=JarEntry,nrs=File)
	if df then trace results
	do
		scriptstream=jf.getInputStream(je)
		if Rexx(je.getName).pos(".class")=0 then do
				scriptreader=BufferedReader(InputStreamReader(scriptstream))
--				scriptwriter=BufferedWriter(OutputStreamWriter(outstream))
				scriptwriter=BufferedWriter(FileWriter(nrs))
				copyfile(scriptreader,scriptwriter)
				scriptwriter.close
				end
			else do
				outstream=FileOutputStream(nrs)
				copybin(scriptstream,outstream)
				outstream.close
				end
		catch badguy=Exception
			say je.getName "copy error =" badguy
			return 0
		end
	return 1
	
/* methods to copy a file:   */

method copyfile(ifq=java.io.BufferedReader,ofq=java.io.BufferedWriter) signals IOException
	if df then trace results
	line=ifq.readline
	if line = null then return
	ofq.write(string line,0,line.length)
	trace off
  loop forever
	line=ifq.readline
	if line = null then leave
	ofq.newline()
	ofq.write(string line,0,line.length)
	end		

method copybin(ifq=InputStream,ofq=OutputStream) binary signals IOException

	bite=ifq.read
  loop while bite \= -1
	ofq.write(bite)
	bite=ifq.read
	end		

-- special class required for .nrx file filtering
	
Class NetRexxScriptPlugin.nrxFilter implements FilenameFilter				--		filter to select .nrx files
	method accept(f=File,n=String) returns boolean
		fn=Rexx(n)
		if fn.right(4)='.nrx' then return 1
			else return 0
	
-- subclass to pass input from dock window to scripts

class NetRexxScriptPlugin.sysin dependent extends BufferedInputStream

	properties private
	
	istring=BufferedInputStream
	
	method sysin(x=InputStream)
		super(x)

	method available returns int signals IOException
		
		if parent.outwin=null then return 0
		if istring\=null then return istring.available
			else return 0
		
	method read returns int signals IOException
	
		if parent.outwin=null then return -1
		
		if istring=null then -
			istring=BufferedInputStream(StringBufferInputStream(parent.outwin.read'\r\n'))
			
		if available>0 then do
			c=istring.read
			if available=0 then istring=null
			return c
			end
		return -1

	method read(b=byte[],off=int,len=int) returns int signals IOException
		
		if parent.outwin=null then return -1
		istring=BufferedInputStream(StringBufferInputStream(parent.outwin.read'\r\n'))		
		
		if available>0 then do
			cnt=istring.read(b,off,len)
			if available=0 then istring=null
			return cnt	
			end
		return -1	

