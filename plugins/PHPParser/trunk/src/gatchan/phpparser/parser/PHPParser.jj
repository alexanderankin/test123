/*
 * PHPParser.java - The PHP Parser
 * :tabSize=8:indentSize=8:noTabs=false:
 * :folding=explicit:collapseFolds=1:
 *
 * Copyright (C) 2003, 2011 Matthieu Casanova
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */

options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = true;/*  */
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  COMMON_TOKEN_ACTION = true;
  TOKEN_EXTENDS = "gatchan.phpparser.parser.PHPToken";
}

PARSER_BEGIN(PHPParser)
package gatchan.phpparser.parser;

//{{{ Imports
import java.util.ArrayList;
import java.io.*;
import java.util.List;
import java.util.Stack;

import net.sourceforge.phpdt.internal.compiler.ast.declarations.VariableUsage;
import net.sourceforge.phpdt.internal.compiler.ast.*;
import net.sourceforge.phpdt.internal.compiler.parser.Outlineable;
//}}}

//{{{ PHPParser class
/**
 * @author Matthieu Casanova <chocolat.mou@gmail.com>
 * @version $Id$
 */
public class PHPParser
{
	//{{{ Fields

	//{{{ constants for methods and function distinction (some keywords are allowed in method classes

	public static final int CONST_METHOD = 0;
	public static final int CONST_FUNCTION = 1;
	//}}}
	public static final int ERROR = 2;
	public static final int WARNING = 1;
	public static final int INFO = 0;

	/** The current segment. */
	private Outlineable currentSegment;

	/** The message of the current ParseException. If it's null it's because the parse exception wasn't handled */
	private String errorMessage;

	private int errorStart = -1;
	private int errorEnd = -1;
	private PHPDocument phpDocument;

	public static final String SYNTAX_ERROR_CHAR = "syntax error";
	/**
	* The point where html starts.
	* It will be used by the token manager to create HTMLCode objects
	*/
	private int htmlStart;
	private int htmlLineStart;
	private int htmlColumnStart;

	//ast stack
	private static final int AstStackIncrement = 100;
	/** The stack of node. */
	private Statement[] nodes;
	/** The cursor in expression stack. */
	private int nodePtr;

	private final List<PHPParserListener> parserListeners = new ArrayList<PHPParserListener>();

	private String path;

	/** Tell if the parsing should be stopped. */
	private boolean shouldStop;

	private Stack<Scope> scopeStack;

	private Scope scope;

	private final List tempList = new ArrayList();

	/**
	 * The current namespace
	 */
	private String namespace;
	//}}}

	//{{{ PHPParser constructor
	public PHPParser()
	{
	} //}}}

	//{{{ setPath() method
	/**
	 * Set the path of the file that is currently parsed.
	 * This path will be sent in parse errors and messages
	 *
	 * @param path the path of the parsed file
	 */
	public void setPath(String path)
	{
	 	 this.path = path;
	} //}}}

	//{{{ getPath()
	public String getPath()
	{
		return path;
	} //}}}

	//{{{ stop()
	/**
	 * Ask the parser to stop his work.
	 */
	public void stop()
	{
		shouldStop = true;
	} //}}}

	//{{{ isStopped()
	public boolean isStopped()
	{
		return shouldStop;
	} //}}}

	//{{{ addParserListener(PHPParserListener listener)
	public void addParserListener(PHPParserListener listener)
	{
		if (!parserListeners.contains(listener))
			parserListeners.add(listener);
	} //}}}

	//{{{ removeParserListener(PHPParserListener listener)
	public void removeParserListener(PHPParserListener listener)
	{
		parserListeners.remove(listener);
	} //}}}

	//{{{ fireParseError(PHPParseErrorEvent e)
	public void fireParseError(PHPParseErrorEvent e)
	{
		for (PHPParserListener listener : parserListeners) 
			listener.parseError(e);
	} //}}}

	//{{{ fireParseError() methods
	public void fireParseError(String message, String expected, Token token)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
						      path,
						      message,
						      expected,
						      token));
	}

	public void fireParseError(String message, AstNode node)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
						      path,
						      message,
						      node.getSourceStart(),
						      node.getSourceEnd(),
						      node.getBeginLine(),
						      node.getEndLine(),
						      node.getBeginColumn(),
						      node.getEndColumn()));
	} //}}}

	//{{{ fireParseMessage(PHPParseMessageEvent e)
	public void fireParseMessage(PHPParseMessageEvent e)
	{
		for (PHPParserListener listener: parserListeners) 
			listener.parseMessage(e);
	} //}}}

	//{{{ phpParserTester(String strEval)
	public void phpParserTester(String strEval) throws ParseException
	{
		StringReader stream = new StringReader(strEval);
		if (jj_input_stream == null)
		{
			jj_input_stream = new SimpleCharStream(stream, 1, 1);
			token_source = new PHPParserTokenManager(jj_input_stream);
		}
		ReInit(new StringReader(strEval));
		init();
		phpDocument = new PHPDocument("_root");
		scope = new Scope();
		scopeStack = new Stack<Scope>();
		scopeStack.push(scope);
		currentSegment = phpDocument;
		token_source.SwitchTo(PHPPARSING);
		phpTest();
	} //}}}

	//{{{ htmlParserTester() methods
	public void htmlParserTester(File fileName) throws FileNotFoundException, ParseException
	{
		Reader stream = new FileReader(fileName);
		if (jj_input_stream == null)
		{
			jj_input_stream = new SimpleCharStream(stream, 1, 1);
			token_source = new PHPParserTokenManager(jj_input_stream);
		}
		ReInit(stream);
		init();
		phpDocument = new PHPDocument("_root");
		scope = new Scope();
		scopeStack = new Stack<Scope>();
		scopeStack.push(scope);
		currentSegment = phpDocument;
		phpFile();
	}

	public void htmlParserTester(String strEval) throws ParseException
	{
		StringReader stream = new StringReader(strEval);
		if (jj_input_stream == null)
		{
			jj_input_stream = new SimpleCharStream(stream, 1, 1);
			token_source = new PHPParserTokenManager(jj_input_stream);
		}
		ReInit(stream);
		init();
		phpDocument = new PHPDocument("_root");
		scope = new Scope();
		scopeStack = new Stack<Scope>();
		scopeStack.push(scope);
		currentSegment = phpDocument;
		phpFile();
	} //}}}

	//{{{ init()
	/**
	 * Reinitialize the parser.
	 */
	private void init()
	{
		nodes = new Statement[AstStackIncrement];
		nodePtr = -1;
		htmlStart = 0;
		htmlColumnStart = 0;
		htmlLineStart = 0;
	} //}}}

	//{{{ pushOnAstNodes(Statement node)
	/**
	 * Add an php node on the stack.
	 * @param node the node that will be added to the stack
	 */
	private void pushOnAstNodes(Statement node)
	{
		try
		{
			nodes[++nodePtr] = node;
		}
		catch (IndexOutOfBoundsException e)
		{
			int oldStackLength = nodes.length;
			Statement[] oldStack = nodes;
			nodes = new Statement[oldStackLength + AstStackIncrement];
			System.arraycopy(oldStack, 0, nodes, 0, oldStackLength);
			nodePtr = oldStackLength;
			nodes[nodePtr] = node;
		}
	} //}}}

	//{{{ parse() methods
	 public void parse() throws ParseException
	 {
	 	 phpFile();
	 }

	public void parse(String s) throws ParseException
	{
		Reader reader = new StringReader(s);
		parse(reader);
	}

	public void parse(Reader reader) throws ParseException
	{
		phpDocument = new PHPDocument("_root");
		scope = new Scope();
		scopeStack = new Stack<Scope>();
		scopeStack.push(scope);
		currentSegment = phpDocument;
		if (jj_input_stream == null)
		{
			jj_input_stream = new SimpleCharStream(reader, 1, 1);
			jj_input_stream.setTabSize(1);
			token_source = new PHPParserTokenManager(jj_input_stream);
		}
		ReInit(reader);
		init();
		parse();
		Statement[] astNodes = new Statement[nodes.length];
		phpDocument.setNodes(astNodes);
		System.arraycopy(nodes,0,astNodes,0,nodes.length);
		phpDocument.analyzeCode(this);
	} //}}}

	//{{{ createNewHTMLCode()
	/**
	 * Put a new html block in the stack.
	 */
	public void createNewHTMLCode()
	{
		int currentPosition = token.sourceStart;
		if (currentPosition == htmlStart ||
		    currentPosition < htmlStart ||
		    currentPosition > jj_input_stream.getCurrentBuffer().length())
		{
			return;
		}
		// todo : reactivate this
		//String html = jj_input_stream.getCurrentBuffer().substring(htmlStart, currentPosition);
		String html = "";
		pushOnAstNodes(new HTMLCode(html, htmlStart,currentPosition,htmlLineStart,token.endLine,htmlColumnStart,token.endColumn));
	} //}}}

	//{{{ error_skipto(int kind)
	Token error_skipto(int kind)
	{
		//  ParseException e = generateParseException();  // generate the exception object.
		//  System.out.println(e.toString());  // print the error message
		Token t;
		do
		{
			t = getNextToken();
		}
		while (t.kind != kind && t.kind != EOF && t.kind != RBRACE);
		return t;
	} //}}}

	//{{{ getPHPDocument()
	public PHPDocument getPHPDocument()
	{
		return phpDocument;
	} //}}}

	//{{{ setTypeFromScope(Variable variable)
	private void setTypeFromScope(Variable variable)
	{
		VariableUsage usage = scope.getVariable(variable.getName(),variable.getBeginLine(),variable.getBeginColumn());
		if (usage != null)
		{
			variable.setType(usage.getType());
		}
	} //}}}
} //}}}


PARSER_END(PHPParser)

TOKEN_MGR_DECLS:
{
	// CommonTokenAction: use the begins/ends fields added to the Jack
	// CharStream class to set corresponding fields in each Token (which was
	// also extended with new fields). By default Jack doesn't supply absolute
	// offsets, just line/column offsets
	void CommonTokenAction(Token t)
	{
		t.sourceStart = input_stream.getBeginOffset();
		t.sourceEnd = input_stream.getEndOffset();

	} // CommonTokenAction
} // TOKEN_MGR_DECLS

//{{{ TOKEN declarations

<DEFAULT> TOKEN :
{
  <PHPSTARTSHORT : "<?">    : PHPPARSING
| <PHPSTARTLONG  : "<?php"> : PHPPARSING
| <PHPECHOSTART  : "<?=">   : PHPPARSING
}

<PHPPARSING, IN_SINGLE_LINE_COMMENT,IN_VARIABLE> TOKEN :
{
  <PHPEND :"?>"> : DEFAULT
}

/* Skip any character if we are not in php mode */
<DEFAULT> SKIP :
{
  < ~[] >
| "<?xml"
}


//{{{ WHITE SPACE
<PHPPARSING> SKIP :
{
	"\n"
}

<IN_NAMESPACE,PHPPARSING> SKIP :
{
	" "
	| "\t"
	| "\r"
	| "\f"
}
//}}}


<IN_VARIABLE> SPECIAL_TOKEN :
{
  " "  : PHPPARSING
| "\t" : PHPPARSING
| "\n" : PHPPARSING
| "\r" : PHPPARSING
| "\f" : PHPPARSING
}

//{{{ COMMENTS
<PHPPARSING> SPECIAL_TOKEN :
{
  "//" : IN_SINGLE_LINE_COMMENT
| "#"  : IN_SINGLE_LINE_COMMENT
| <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}


<IN_SINGLE_LINE_COMMENT> SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : PHPPARSING
| < ~[] >
}

<IN_FORMAL_COMMENT> SPECIAL_TOKEN :
{
  "*/" : PHPPARSING
}

<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN :
{
  "*/" : PHPPARSING
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
} //}}}


//{{{ PHP5 tokens
/* VISIBILITY */
<PHPPARSING> TOKEN :
{
  <PUBLIC    : "public">
| <PROTECTED : "protected">
| <PRIVATE   : "private">
}

<PHPPARSING> TOKEN :
{
  <ABSTRACT : "abstract">
}

<PHPPARSING> TOKEN :
{
  <INTERFACE  : "interface">
| <IMPLEMENTS : "implements">
| <FINAL      : "final">
}

/* Exceptions */
<PHPPARSING> TOKEN :
{
  <TRY   : "try">
| <CATCH : "catch">
| <THROW : "throw">
}
//}}}


//{{{ KEYWORDS
<PHPPARSING> TOKEN:
{
  <CLASS:	"class">
| <FUNCTION:	"function">
| <NAMESPACE:	"namespace"> : IN_NAMESPACE
| <USE:		"use">
| <VAR:		"var">
| <IF:		"if">
| <ELSEIF:	"elseif">
| <ELSE:	"else">
| <ARRAY:	"array">
| <BREAK:	"break">
| <LIST:	"list">
} //}}}


//{{{ LANGUAGE CONSTRUCT
<PHPPARSING> TOKEN :
{
  <PRINT              : "print">
| <ECHO               : "echo">
| <INCLUDE            : "include">
| <REQUIRE            : "require">
| <INCLUDE_ONCE       : "include_once">
| <REQUIRE_ONCE       : "require_once">
| <GLOBAL             : "global">
| <STATIC             : "static">
| <CASE               : "case">
| <CONST              : "const">
| <CONTINUE           : "continue">
| <_DEFAULT           : "default">
| <DO                 : "do">
| <EXTENDS            : "extends">
| <FOR                : "for">
| <NEW                : "new">
| <CLONE              : "clone">
| <RETURN             : "return">
| <SWITCH             : "switch">
| <WHILE              : "while">
| <ENDWHILE           : "endwhile">
| <ENDSWITCH          : "endswitch">
| <ENDIF              : "endif">
| <ENDFOR             : "endfor">
| <ENDFOREACH         : "endforeach">
| <FOREACH            : "foreach">
| <AS                 : "as" >
} //}}}


<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <CLASSACCESS:		"->"> : PHPPARSING
| <STATICCLASSACCESS:	"::"> : PHPPARSING
| <ARRAYASSIGN:		"=>"> : PHPPARSING
}

/* RESERVED WORDS AND LITERALS */

<PHPPARSING> TOKEN :
{
  <DEFINE     : "define">
| <GOTO       : "goto">
| <NULL       : "null">
| <SUPER      : "super">
| <THIS       : "this">
| <TRUE       : "true">
| <FALSE      : "false">
| <INSTANCEOF : "instanceof">
}

//{{{ TYPES
<PHPPARSING> TOKEN :
{
  <STRING  : "string">
| <OBJECT  : "object">
| <BOOL    : "bool">
| <BOOLEAN : "boolean">
| <REAL    : "real">
| <DOUBLE  : "double">
| <FLOAT   : "float">
| <INT     : "int">
| <INTEGER : "integer">
} //}}}


//{{{ Misc token
<PHPPARSING,IN_VARIABLE> TOKEN:
{
  <AT:		"@"> : PHPPARSING
| <BANG:	"!"> : PHPPARSING
| <TILDE:	"~"> : PHPPARSING
| <HOOK:	"?"> : PHPPARSING
| <COLON:	":"> : PHPPARSING
} //}}}


//{{{ OPERATORS
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <OR_OR          : "||">  : PHPPARSING
| <AND_AND        : "&&">  : PHPPARSING
| <PLUS_PLUS      : "++">  : PHPPARSING
| <MINUS_MINUS    : "--">  : PHPPARSING
| <PLUS           : "+">   : PHPPARSING
| <MINUS          : "-">   : PHPPARSING
| <STAR           : "*">   : PHPPARSING
| <SLASH          : "/">   : PHPPARSING
| <BACKSLASH      : "\\">  : PHPPARSING
| <BIT_AND        : "&">   : PHPPARSING
| <BIT_OR         : "|">   : PHPPARSING
| <BIT_XOR        : "^">   : PHPPARSING
| <REMAINDER      : "%">   : PHPPARSING
| <LSHIFT         : "<<">  : PHPPARSING
| <RSIGNEDSHIFT   : ">>">  : PHPPARSING
| <RUNSIGNEDSHIFT : ">>>"> : PHPPARSING
| <_ORL           : "OR">  : PHPPARSING
| <XOR            : "XOR"> : PHPPARSING
| <_ANDL          : "AND"> : PHPPARSING
} //}}}


//{{{ LITERALS
<PHPPARSING> TOKEN :
{
  <INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  <#DECIMAL_LITERAL: (["0"-"9"])+ >
|
  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  <#OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  <FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  <STRING_LITERAL: (/*<STRING_1> |*/ <STRING_2> | <STRING_3>)>
/*|   <STRING_1: "\"" ( ~["\"","\\"] | "\\" ~[] )* "\"">*/
|   <STRING_2: "'"  ( ~["'","\\"]  | "\\" ~[] )* "'">
|   <STRING_3: "`"  ( ~["`","\\"]  | "\\" ~[] )* "`">
}

<PHPPARSING> TOKEN :
{
	<DOUBLEQUOTE: "\""> : IN_STRING
}

<IN_STRING> TOKEN :
{
	<DOLLARBRACE: "${">
|
	<DOLLARS: "$">
|
	<DOUBLEQUOTE2: "\""> : PHPPARSING
}

<PHPPARSING> TOKEN :
{
	<HEREDOCSTARTTOKEN : "<<<"> : HEREDOC
}


<PHPPARSING,IN_VARIABLE> TOKEN:
{
	<DOLLAR: "$"> : IN_VARIABLE
}

<HEREDOC, PHPPARSING, IN_VARIABLE, IN_STRING> TOKEN :
{
	<IDENTIFIER: (<LETTER>|<SPECIAL>) (<LETTER>|<DIGIT>|<SPECIAL>)* ("\\" (<LETTER>|<SPECIAL>) (<LETTER>|<DIGIT>|<SPECIAL>)*)*>
|
	<NAMESPACE_IDENTIFIER: ("\\" (<LETTER>|<SPECIAL>) (<LETTER>|<DIGIT>|<SPECIAL>)* | "\\" (<LETTER>|<SPECIAL>) (<LETTER>|<DIGIT>|<SPECIAL>)*) ("\\" (<LETTER>|<SPECIAL>) (<LETTER>|<DIGIT>|<SPECIAL>)*)*>
|								   
	< #LETTER: ["a"-"z"] | ["A"-"Z"] >
|
	< #DIGIT: ["0"-"9"] >
|
	< #SPECIAL: "_" | ["\u007f"-"\u00ff"] >
}

<HEREDOC,IN_STRING> SKIP:
{
	<("\\" ~[])>
|
	<~[]>
}
//}}}


//{{{ SEPARATORS
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <LPAREN    : "("> : PHPPARSING
| <RPAREN    : ")"> : PHPPARSING
| <RBRACE    : "}"> : PHPPARSING
| <LBRACKET  : "["> : PHPPARSING
| <RBRACKET  : "]"> : PHPPARSING
| <SEMICOLON : ";"> : PHPPARSING
| <COMMA     : ","> : PHPPARSING
| <DOT       : "."> : PHPPARSING
}

<PHPPARSING,IN_VARIABLE, IN_NAMESPACE> TOKEN :
{
 <LBRACE    : "{"> : PHPPARSING
} //}}}

//{{{ COMPARATOR
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <GT                 : ">"  > : PHPPARSING
| <LT                 : "<"  > : PHPPARSING
| <EQUAL_EQUAL        : "==" > : PHPPARSING
| <LE                 : "<=" > : PHPPARSING
| <GE                 : ">=" > : PHPPARSING
| <NOT_EQUAL          : "!=" > : PHPPARSING
| <DIF                : "<>" > : PHPPARSING
| <BANGDOUBLEEQUAL    : "!=="> : PHPPARSING
| <TRIPLEEQUAL        : "==="> : PHPPARSING
}
//}}}

//{{{ ASSIGNATION
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <ASSIGN             : "="  > : PHPPARSING
| <PLUSASSIGN         : "+=" > : PHPPARSING
| <MINUSASSIGN        : "-=" > : PHPPARSING
| <STARASSIGN         : "*=" > : PHPPARSING
| <SLASHASSIGN        : "/=" > : PHPPARSING
| <ANDASSIGN          : "&=" > : PHPPARSING
| <ORASSIGN           : "|=" > : PHPPARSING
| <XORASSIGN          : "^=" > : PHPPARSING
| <DOTASSIGN          : ".=" > : PHPPARSING
| <REMASSIGN          : "%=" > : PHPPARSING
| <TILDEEQUAL         : "~=" > : PHPPARSING
| <LSHIFTASSIGN       : "<<="> : PHPPARSING
| <RSIGNEDSHIFTASSIGN : ">>="> : PHPPARSING
}
//}}}


<IN_NAMESPACE,PHPPARSING> TOKEN:
{
	<NAMESPACE_NAME: ((<LETTER>|<SPECIAL>) (<LETTER>|<DIGIT>|<SPECIAL>|<BACKSLASH>)*)> : PHPPARSING
}
//}}}



//{{{ PHP Structures

//{{{ phpTest()
void phpTest() :
{}
{
  Php()
  <EOF>
} //}}}

//{{{ phpFile()
void phpFile() :
{}
{
	try
	{
		(PhpBlock())*
		{
			createNewHTMLCode();
		}
	}
	catch (TokenMgrError e)
	{
		//{{{ Parse Error
		fireParseError(new PHPParseErrorEvent(ERROR,
						      path,
						      e.getMessage(),
						      e.getMessage(),
						      null,
						      jj_input_stream.getBeginOffset(),
						      jj_input_stream.getEndOffset(),
						      jj_input_stream.getBeginLine(),
						      jj_input_stream.getEndLine(),
						      jj_input_stream.getBeginColumn(),
						      jj_input_stream.getEndColumn())); //}}}
	}
} //}}}

//{{{ PhpBlock()
/**
 * A php block is a <?= expression [;]?>
 * or <?php somephpcode ?>
 * or <? somephpcode ?>
 */
void PhpBlock() :
{
	PHPEchoBlock phpEchoBlock;
	Token token,phpEnd;
}
{
	phpEchoBlock = phpEchoBlock()
	{
		pushOnAstNodes(phpEchoBlock);
	}
|
	//{{{ <? | <?php
	[
  	<PHPSTARTLONG>
	|
	token = <PHPSTARTSHORT>
	{
		fireParseMessage(new PHPParseMessageEvent(INFO,
							  PHPParseMessageEvent.MESSAGE_SHORT_OPEN_TAG,
							  path,
							  "You should use '<?php' instead of '<?' it will avoid some problems with XML",
							  token));
	}
	]
	//}}}
	{
		createNewHTMLCode();
	}
	Php()
	try
	{
		phpEnd = <PHPEND>
		{
			htmlStart = phpEnd.sourceEnd;
			htmlLineStart = phpEnd.endLine;
			htmlColumnStart = phpEnd.endColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseMessage(new PHPParseMessageEvent(INFO,
							  PHPParseMessageEvent.MESSAGE_PHP_CLOSING_MISSING,
							  path,
							  "'?>' is missing",
							  e.currentToken));
	}
} //}}}

//{{{ phpEchoBlock()
PHPEchoBlock phpEchoBlock() :
{
	Expression expr;
	PHPEchoBlock echoBlock;
	Token echoStartToken;
	Token echoEndToken;
}
{
	echoStartToken = <PHPECHOSTART> {createNewHTMLCode();}
	expr = Expression() [ <SEMICOLON> ]
	try
	{
		echoEndToken = <PHPEND>
		{
			htmlStart = echoEndToken.sourceEnd;
			htmlLineStart = echoEndToken.endLine;
			htmlColumnStart = echoEndToken.endColumn;

			echoBlock = new PHPEchoBlock(expr,echoStartToken.sourceStart,
						     echoEndToken.sourceEnd,
						     echoStartToken.beginLine,
						     echoEndToken.endLine,
						     echoStartToken.beginColumn,
						     echoEndToken.endColumn);
		}
	}
	catch (ParseException e)
	{
		fireParseMessage(new PHPParseMessageEvent(INFO,
							  PHPParseMessageEvent.MESSAGE_PHP_CLOSING_MISSING,
							  path,
							  "'?>' is missing",
							  e.currentToken));
		echoBlock = new PHPEchoBlock(expr,
					     echoStartToken.sourceStart,
					     e.currentToken.sourceEnd,
					     echoStartToken.beginLine,
					     e.currentToken.endLine,
					     echoStartToken.beginColumn,
					     e.currentToken.endColumn);
	}
	{
		pushOnAstNodes(echoBlock);
		return echoBlock;
	}
} //}}}

//{{{ Php()
void Php() :
{}
{
	(
		namespace()
	|
		constantStatement()
	|
		BlockStatement()
	)*
} //}}}

//}}}

//{{{ namespace() method
Namespace namespace():
{
	Token namespaceToken;
	Token namespaceNameToken = null;
	Token semicolon;
	int sourceEnd;
	int endLine;
	int endColumn;
}
{
	//{{{ <NAMESPACE>
	{
		namespace = null;
	}
	namespaceToken = <NAMESPACE>
	{
		sourceEnd = namespaceToken.sourceEnd;
		endLine = namespaceToken.endLine;
		endColumn = namespaceToken.endColumn;
	} //}}}

	(
		//{{{ block
		<LBRACE>
		(
			constantStatement()
		|
			BlockStatement()
		)*
		<RBRACE>
		{
			String namespaceName = namespaceNameToken == null ? null : namespaceNameToken.image;
			namespace = Namespace.getNamespace(namespaceName);
			return new Namespace(namespace,
					     namespaceToken.sourceStart,
					     sourceEnd,
					     namespaceToken.beginLine,
					     endLine,
					     namespaceToken.beginColumn,
					     endColumn);
		} //}}}

	|

		namespaceNameToken = <NAMESPACE_NAME>
		try
		{

			(
				//{{{ { block()* }
				<LBRACE>
				(
					constantStatement()
				|
					BlockStatement()
				)*
				<RBRACE>
				{
					namespace = Namespace.getNamespace(namespaceNameToken.image);
					return new Namespace(namespace,
							     namespaceToken.sourceStart,
							     sourceEnd,
							     namespaceToken.beginLine,
							     endLine,
							     namespaceToken.beginColumn,
							     endColumn);
				}
				//}}}
			|
				semicolon = <SEMICOLON>
				{
					sourceEnd = semicolon.sourceEnd;
					endLine = semicolon.endLine;
					endColumn = semicolon.endColumn;
				}
			)
		}
		catch (ParseException e)
		{
			fireParseError("{ ...} or ; expected",";",e.currentToken.next);
		}
		{
			namespace = Namespace.getNamespace(namespaceNameToken.image);
			return new Namespace(namespace,
					     namespaceToken.sourceStart,
					     sourceEnd,
					     namespaceToken.beginLine,
					     endLine,
					     namespaceToken.beginColumn,
					     endColumn);
		}
	)

} //}}}

//{{{ interfaceDeclaration()
InterfaceDeclaration interfaceDeclaration():
{
	Token modifierToken;
	Token interfaceToken, rBraceToken;
	Token nameToken;
	InterfaceDeclaration interfaceDeclaration;
	String interfaceNameImage = SYNTAX_ERROR_CHAR;
	MethodDeclaration methodDeclaration;
	List<ConstantIdentifier> superInterfaces = null;
	List<Modifier> modifiers = new ArrayList<Modifier>(1);
	List<ClassConstant> classConstants;
}
{
	//{{{ interface <IDENTIFIER>
	interfaceToken = <INTERFACE>
	try
	{
		nameToken = <IDENTIFIER>
		{
			interfaceNameImage = nameToken.image;
		}
	}
	catch (ParseException e)
	{
		fireParseError("identifier expected","identifier",e.currentToken.next);
	} //}}}
	[
		//{{{ extends <IDENTIFIER [, IDENTIFIER]
		<EXTENDS> nameToken = <IDENTIFIER>
		{
			superInterfaces = new ArrayList<ConstantIdentifier>();
			superInterfaces.add(new ConstantIdentifier(nameToken));
		}
		(
		<COMMA> nameToken = <IDENTIFIER>
		{
			superInterfaces.add(new ConstantIdentifier(nameToken));
		}
		)* //}}}
	]

	{
		interfaceDeclaration = new InterfaceDeclaration(namespace,
								path,
								currentSegment,
								interfaceNameImage,
								superInterfaces,
								interfaceToken.sourceStart,
								interfaceToken.beginLine,
								interfaceToken.beginColumn);
		currentSegment.add(interfaceDeclaration);
		currentSegment = interfaceDeclaration;
		scope = new Scope();
		scopeStack.push(scope);
	}
	try
	{
		<LBRACE>
	}
	catch (ParseException e)
	{
		fireParseError("{ expected","{",e.currentToken.next);
	}
	(
	 	 [
		 (
			 //{{{ public [static]
			 modifierToken = <PUBLIC>
			 {
				 modifiers.add(new Modifier(modifierToken));
			 }
			 [
			 try
			 {
				 modifierToken = <STATIC>
				 {
					 modifiers.add(new Modifier(modifierToken));
				 }
			 }
			 catch (ParseException e)
			 {
				 fireParseError("static or function token expected","static|function",e.currentToken.next);
			 }
			 ] //}}}
		 |
			 //{{{ static [public]
			 modifierToken = <STATIC>
			 {
				 modifiers.add(new Modifier(modifierToken));
			 }
			 [
			 try
			 {
				 modifierToken = <PUBLIC>
				 {
					 modifiers.add(new Modifier(modifierToken));
				 }
			 }
			 catch (ParseException e)
			 {
				 fireParseError("public or function token expected","public|function",e.currentToken.next);
			 }
			 ] //}}}
		 )
		 ]
		 methodDeclaration = interfaceMethodDeclaration(modifiers)
		 {
			 interfaceDeclaration.add(methodDeclaration);
		 }
		 |
		 classConstants = classConstant()
		 {
		 	 for (ClassConstant classConstant : classConstants)
		 	 {
		 	 	 interfaceDeclaration.addConstant(classConstant);
		 	 }	 
		 }
	)*
	try
	{
		rBraceToken = <RBRACE>
		{
			interfaceDeclaration.setSourceEnd(rBraceToken.sourceEnd);
			interfaceDeclaration.setEndLine(rBraceToken.endLine);
			interfaceDeclaration.setEndColumn(rBraceToken.endColumn);
		}
	}
	catch (ParseException e)
	{
		fireParseError("} expected","}",e.currentToken.next);
	}
	{
		currentSegment = interfaceDeclaration.getParent();
		scope = scopeStack.pop();
		return interfaceDeclaration;
	}
} //}}}

//{{{ classConstant() method
List<ClassConstant> classConstant():
{
	Token constToken, token;
	String constName = SYNTAX_ERROR_CHAR;
	List<ClassConstant> constants = new ArrayList<ClassConstant>();
	ClassConstant classConstant;
}
{
	constToken = <CONST>
	classConstant = _classConstant(constToken)
	{
		constants.add(classConstant);
	}
	(
		token = <COMMA>
		classConstant = _classConstant(token)
		{
			constants.add(classConstant);
		}
	)*
	//{{{ <SEMICOLON>
	try
	{
		token = <SEMICOLON>
	}
	catch (ParseException e)
	{
		fireParseError("';' expected",";",e.currentToken.next);
	} //}}}
	{
		return constants;
	}
} //}}}

//{{{ _classConstant() method
ClassConstant _classConstant(Token startToken):
{
	Token identifier;
	Token token;
	String constName = SYNTAX_ERROR_CHAR;
	Expression initializer = null;
	int end, endLine, endColumn;
}
{
	{
		end = startToken.sourceEnd;
		endLine = startToken.endLine;
		endColumn = startToken.endColumn;
	}
	//{{{ <IDENTIFIER>
	try
	{
		identifier = methodIdentifier()
		{
			startToken = identifier;
			constName = identifier.image;
			end = identifier.sourceEnd;
			endLine = identifier.endLine;
			endColumn = identifier.endColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError("constant expected","constant",e.currentToken.next);
	} //}}}
	//{{{ <ASSIGN>
	try
	{
		token = <ASSIGN>
		{
			end = token.sourceEnd;
			endLine = token.endLine;
			endColumn = token.endColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError("'=' expected","=",e.currentToken.next);
	} //}}}
	//{{{ VariableInitializer()
	try
	{
		initializer = VariableInitializer()
		{
			end = initializer.getSourceEnd();
			endLine = initializer.getEndLine();
			endColumn = initializer.getEndColumn();
		}
	}
	catch (ParseException e)
	{
		fireParseError("expression expected","expression",e.currentToken.next);
	} //}}}
	{
		return new ClassConstant(namespace,
			path,
			currentSegment,
			constName,
			initializer,
			startToken.sourceStart,
			end,
			startToken.beginLine,
			endLine,
			startToken.beginColumn,
			endColumn);
	}
} //}}}


//{{{ interfaceMethodDeclaration(Liscodifiers)
/**
 * A Method Declaration.
 * <b>function</b> MetodDeclarator() Block()
 *
 * @return a MethodDeclaration
 */
MethodDeclaration interfaceMethodDeclaration(List<Modifier> modifiers):
{
	MethodDeclaration functionDeclaration;
	MethodHeader methodHeader;
	Token functionToken;
}
{
	functionToken = <FUNCTION>

	methodHeader = methodHeader(functionToken,CONST_METHOD, modifiers)
	{
		functionDeclaration = new MethodDeclaration(currentSegment,methodHeader);
	}
	try
	{
		<SEMICOLON>
	}
	catch (ParseException e)
	{
		fireParseError("unexpected token : "+e.currentToken.image, ";",
			       e.currentToken);
	}
	{
		return functionDeclaration;
	}
} //}}}

//{{{ Class methods

//{{{ classDeclaration()
/**
 * A Class declaration.
 * class <IDENTIFIER> [extends <IDENTIFIER>] Class body
 *
 * @return a ClassDeclaration
 */
ClassDeclaration classDeclaration():
{
	ClassHeader classHeader;
	ClassDeclaration classDeclaration;
	Token abstractToken = null;
	Token finalToken = null;
}
{
	abstractToken = <ABSTRACT>
	classHeader = classHeader(abstractToken)
	{
		classDeclaration = new ClassDeclaration(currentSegment,
			classHeader,
			classHeader.getSourceStart(),
			classHeader.getSourceEnd(),
			classHeader.getBeginLine(),
			classHeader.getEndLine(),
			classHeader.getBeginColumn(),
			classHeader.getEndColumn());
		currentSegment.add(classDeclaration);
		currentSegment = classDeclaration;
		scope = new Scope();
		scopeStack.push(scope);
	}
	//todo change this
	abstractClassBody(classDeclaration)
	{
		currentSegment = currentSegment.getParent();
		scope = scopeStack.pop();
		pushOnAstNodes(classDeclaration);
		return classDeclaration;
	}
|
	[
		finalToken = <FINAL>
	]
	classHeader = classHeader(finalToken)
	{
		if (finalToken != null)
		{
			classHeader.addModifier(new Modifier(finalToken));
		}
		classDeclaration = new ClassDeclaration(currentSegment,
			classHeader,
			classHeader.getSourceStart(),
			classHeader.getSourceEnd(),
			classHeader.getBeginLine(),
			classHeader.getEndLine(),
			classHeader.getBeginColumn(),
			classHeader.getEndColumn());
		currentSegment.add(classDeclaration);
		currentSegment = classDeclaration;
		scope = new Scope();
		scopeStack.push(scope);
	}
	//todo change this
	classBody(classDeclaration)
	{
		currentSegment = currentSegment.getParent();
		scope = scopeStack.pop();
		pushOnAstNodes(classDeclaration);
		return classDeclaration;
	}
} //}}}

//{{{ classHeader(Token abstractToken)
ClassHeader classHeader(Token abstractToken):
{
	Token classToken;
	Token className = null;
	Token superclassName = null;
	Token firstToken = abstractToken;
	List<InterfaceIdentifier> interfaces = null;
}
{
	//{{{ class
	try
	{
		classToken = <CLASS>
		{
			if (firstToken == null) firstToken = classToken;
		}
	}
	catch (ParseException e)
	{
		fireParseError("identifier expected","identifier", e.currentToken.next);
	} //}}}

	//{{{ identifier
	try
	{
		className = <IDENTIFIER>
	}
	catch (ParseException e)
	{
		fireParseError("identifier expected","identifier",e.currentToken.next);
	} //}}}

	//{{{ extends XXX
	[
	<EXTENDS>
	try
	{
		(superclassName = <IDENTIFIER> | superclassName = <OBJECT>)
	}
	catch (ParseException e)
	{
		//{{{ Parse error
		fireParseError("identifier expected", "identifier", e.currentToken.next);
		error_skipto(LBRACE);//}}}
	}
	] //}}}

	//{{{ implements xxx,yyy
	[
		<IMPLEMENTS>
		{
			interfaces = new ArrayList<InterfaceIdentifier>();
			Token interfaceToken;
		}
		try
		{
			interfaceToken = <IDENTIFIER>
			{
				interfaces.add(new InterfaceIdentifier(interfaceToken));
			}
		}
		catch (ParseException e)
		{
			fireParseError("interface identifier expected", "identifier", e.currentToken.next);
		}
		(
			 <COMMA>
			 try
			{
				interfaceToken = <IDENTIFIER>
				{
					interfaces.add(new InterfaceIdentifier(interfaceToken));
				}
			}
			catch (ParseException e)
			{
				fireParseError("interface identifier expected", "identifier", e.currentToken.next);
			}
		)*
	] //}}}

	{
		int end,endLine,endColumn;
		if (interfaces != null && !interfaces.isEmpty())
		{
			InterfaceIdentifier id = interfaces.get(interfaces.size() - 1);
			end = id.getSourceEnd();
			endLine = id.getEndLine();
			endColumn = id.getEndColumn();
		}
		else
		{
			if (superclassName != null)
			{
				end = superclassName.sourceEnd;
				endLine = superclassName.endLine;
				endColumn = superclassName.endColumn;
			}
			else
			{
				if (className == null)
				{
					end         = firstToken.sourceEnd;
					endLine     = firstToken.endLine;
					endColumn   = firstToken.endColumn;
				}
				else
				{
					end         = className.sourceEnd;
					endLine     = className.endLine;
					endColumn   = className.endColumn;
				}
			}
		}
		
		return new ClassHeader(namespace,
				       path,
				       className == null ? null : new ClassIdentifier(className),
				       superclassName == null ? null : new ClassIdentifier(superclassName),
				       interfaces,
				       firstToken.sourceStart,
				       end,
				       firstToken.beginLine,
				       endLine,
				       firstToken.beginColumn,
				       endColumn);
	}
}//}}}

//{{{ classBody(ClassDeclaration classDeclaration)
void classBody(ClassDeclaration classDeclaration):
{
	Token lBraceToken;
	Token rBraceToken;
}
{
	try
	{
		lBraceToken = <LBRACE>
		{
			classDeclaration.setBodyLineStart(lBraceToken.beginLine);
			classDeclaration.setBodyColumnStart(lBraceToken.beginColumn);
		}
	}
	catch (ParseException e)
	{
		fireParseError("'{' expected", "{", e.currentToken);
	}
	(
		classBodyDeclaration(classDeclaration)
	)*
	try
	{
		rBraceToken = <RBRACE>
		{
			classDeclaration.setBodyLineEnd(rBraceToken.endLine);
			classDeclaration.setBodyColumnEnd(rBraceToken.endColumn);
		}
	}
	catch (ParseException e)
	{
		fireParseError("'}' expected", "}", e.currentToken.next);
		rBraceToken = error_skipto(RBRACE);
		classDeclaration.setBodyLineEnd(rBraceToken.endLine);
		classDeclaration.setBodyColumnEnd(rBraceToken.endColumn);
	}
} //}}}

//{{{ abstractClassBody(ClassDeclaration classDeclaration)
void abstractClassBody(ClassDeclaration classDeclaration) :
{
  Token lBraceToken;
  Token rBraceToken;
}
{
  try {
    lBraceToken = <LBRACE>
    {
      classDeclaration.setBodyLineStart(lBraceToken.beginLine);
      classDeclaration.setBodyColumnStart(lBraceToken.beginColumn);
    }
  } catch (ParseException e) {
    //{{{ Parse error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'{' expected",
                                          "{",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
  }
  ( abstractClassBodyDeclaration(classDeclaration) )*
  try {
    rBraceToken = <RBRACE>
    {
      classDeclaration.setBodyLineEnd(rBraceToken.endLine);
      classDeclaration.setBodyColumnEnd(rBraceToken.endColumn);
    }
  } catch (ParseException e) {
    //{{{ Parse error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'}' expected",
                                          "}",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
    rBraceToken = error_skipto(RBRACE);
    classDeclaration.setBodyLineEnd(rBraceToken.endLine);
    classDeclaration.setBodyColumnEnd(rBraceToken.endColumn);
  }
} //}}}

//{{{ classBodyDeclaration(ClassDeclaration classDeclaration)
/**
 * A class can contain only methods and fields.
 */
void classBodyDeclaration(ClassDeclaration classDeclaration):
{
	MethodDeclaration method;
	List<FieldDeclaration> fieldList;
	Modifier modifier;
	List<Modifier> modifiers = new ArrayList<Modifier>();
	List<FieldDeclaration> fields;
	List<ClassConstant> classConstants;
}
{
	(
		classConstants = classConstant()
		{
			for (ClassConstant classConstant:classConstants)
			{
				classDeclaration.addConstant(classConstant);
			}
		}
	|
		//{{{ modifiers
		(
			modifier = commonModifiers()
			{
				modifiers.add(modifier);
			}
		)* //}}}
		//{{{ fields or method
		try 
		{
			(
				fields = fieldDeclarationPHP5(modifiers)
				{
					for (FieldDeclaration field : fields)
						classDeclaration.addField(field);
				}
			|
				(
					modifier = methodModifiers()
					{
						modifiers.add(modifier);
					}
					(
						modifier = commonModifiers()
						{
							modifiers.add(modifier);
						}
						)*
					)*
				method = methodDeclaration(CONST_METHOD,modifiers)
				{
					//  method.analyzeCode(this);
					classDeclaration.addMethod(method);
				}
			)
		} 
		catch (ParseException e) 
		{
			fireParseError("unexpected token " + e.currentToken.image, "", e.currentToken);
		} //}}}

	|
		fieldList  = fieldDeclaration()
		{
			if (fieldList != null)
			{
				for (FieldDeclaration field:fieldList) 
					classDeclaration.addField(field);
			}
		}
	)
} //}}}

//{{{ commonModifiers()
/**
 * A class can contain only methods and fields.
 */
Modifier commonModifiers() :
{
	Token token;
}
{
	(
		token = <STATIC>
	|
		token = <PUBLIC>
	| 
		token = <PROTECTED>
	|
		token = <PRIVATE>
	)
	{
		return new Modifier(token);
	}
} //}}}

//{{{ methodModifiers()
Modifier methodModifiers() :
{
  Token token;
}
{
  (
  token = <FINAL>
  |
  token = <ABSTRACT>
  )
  {
    return new Modifier(token);
  }

} //}}}

//{{{ abstractClassBodyDeclaration(ClassDeclaration classDeclaration)
/**
 * A class can contain only methods and fields.
 */
void abstractClassBodyDeclaration(ClassDeclaration classDeclaration):
{
	MethodDeclaration method;
	List<FieldDeclaration> fieldList;
	Modifier modifier;
	List<Modifier> modifiers = new ArrayList<Modifier>();
	List<FieldDeclaration> fields;
	List<ClassConstant> classConstants;
}
{
	classConstants = classConstant()
	{
		for (ClassConstant classConstant:classConstants)
		{
			classDeclaration.addConstant(classConstant);
		}
	}
|
	(
		modifier = commonModifiers()
		{
			modifiers.add(modifier);
		}
	)*
	try
	{
		(
			fields = fieldDeclarationPHP5(modifiers)
			{
				for (FieldDeclaration field:fields)
					classDeclaration.addField(field);
			}
		|
			(
				modifier = methodModifiers()
				{
					modifiers.add(modifier);
				}
				(
					modifier = commonModifiers()
					{
						modifiers.add(modifier);
					}
					)*
				)*
			method = methodDeclaration(CONST_METHOD, modifiers)
			{
				//method.analyzeCode(this);
				classDeclaration.addMethod(method);
			}
		)
	} 
	catch (ParseException e)
	{
		fireParseError("unexpected token " + e.currentToken.image, "", e.currentToken);
	}
|
	fieldList = fieldDeclaration()
	{
		if (fieldList != null) 
		{
			for (FieldDeclaration field:fieldList)
			{
				classDeclaration.addField(field);
			}
		}
	}
} //}}}

//{{{ fieldDeclaration()
/**
 * A class field declaration : it's var VariableDeclarator() (, VariableDeclarator())*;.
 * it is only used by classBodyDeclaration()
 */
List<FieldDeclaration> fieldDeclaration():
{
	List<FieldDeclaration> arrayList;
}
{
	//{{{ <VAR>
	<VAR>
	{
		fireParseMessage(new PHPParseMessageEvent(INFO,
			PHPParseMessageEvent.MESSAGE_DEPRECATED_VAR_TOKEN,
			path,
			"The var token is deprecated in php 5",
			token));
	} //}}}
	arrayList = fieldDeclarationPHP5(null)
	{
		return arrayList;
	}
} //}}}

//{{{ fieldDeclarationPHP5()
/**
 * A class field declaration : it's var VariableDeclarator() (, VariableDeclarator())*;.
 * it is only used by ClassBodyDeclaration()
 */
List<FieldDeclaration> fieldDeclarationPHP5(List<Modifier> modifiers):
{
	VariableDeclaration variableDeclaration;
	List<FieldDeclaration> fields = new ArrayList<FieldDeclaration>();
}
{
	//{{{ first field
	try
	{
		variableDeclaration = field()
		{
			fields.add(new FieldDeclaration(namespace,
				currentSegment,
				modifiers,
				path,
				variableDeclaration));
		}
	}
	catch (ParseException e)
	{
		Token semicolon = error_skipto(SEMICOLON);
		fireParseError("field declaration expected","field declaration",semicolon);
	} //}}}
	(
		<COMMA>
		//{{{ additional fields
		try
		{
			variableDeclaration = field()
			{
				fields.add(new FieldDeclaration(namespace,
					currentSegment,
					modifiers,
					path,
					variableDeclaration));
                        }
                }
                catch (ParseException e)
                {
                	Token semicolon = error_skipto(SEMICOLON);
                	fireParseError("field declaration expected","field declaration",semicolon);
                } //}}}
	)*
	try
	{
		<SEMICOLON>
	}
	catch (ParseException e)
	{
		Token semicolon = error_skipto(SEMICOLON);
		fireParseError("semicolon expected",";",e.currentToken);
	}
	{
		return fields;
	}
}//}}}

//}}}

//{{{ Variables

//{{{ field()
/**
 * One field declaration
 */
VariableDeclaration field():
{
	Token identifierToken, lbrace,rbrace;
	Expression expr;
	Expression initializer = null;
	Token assignToken = null;
	Token dollarToken;
	Variable variable;
}
{
	dollarToken = <DOLLAR>
	try
	{
		(
			identifierToken = methodIdentifier()
			{
				variable = new Variable(identifierToken.image,
					dollarToken.sourceStart,
					identifierToken.sourceEnd,
					dollarToken.beginLine,
					identifierToken.endLine,
					dollarToken.beginColumn,
					identifierToken.endColumn);
			}
		|
			lbrace = <LBRACE> expr = Expression() rbrace = <RBRACE>
			{
				variable = new Variable(expr,
					lbrace.sourceStart,
					rbrace.sourceEnd,
					lbrace.beginLine,
					rbrace.endLine,
					lbrace.beginColumn,
					rbrace.endColumn);
			}
		)
	}
	catch (ParseException e)
	{
		fireParseError("identifier expected", "", e.currentToken);
		variable = new Variable("",
			e.currentToken.sourceStart,
			e.currentToken.sourceEnd,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.beginColumn,
			e.currentToken.endColumn);
	}
	//{{{ = VariableInitializer()
	[
		assignToken = <ASSIGN>
		try
		{
			initializer = VariableInitializer()
		}
		catch (ParseException e)
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"Literal expression expected in variable initializer",
				"literal",
				e.currentToken.image,
				assignToken.sourceEnd,
				assignToken.sourceEnd +1,
				e.currentToken.beginLine,
				e.currentToken.endLine,
				e.currentToken.endColumn,
				e.currentToken.endColumn+1));
		}
	] //}}}
	{
		setTypeFromScope(variable);
		if (assignToken == null)
		{
			return new VariableDeclaration(currentSegment, variable);
		}
		if (initializer == null)
		{
			return new VariableDeclaration(currentSegment,
				variable,
				null,
				"=",
				variable.getSourceStart(),
				assignToken.sourceEnd,
				variable.getBeginLine(),
				assignToken.endLine,
				variable.getBeginColumn(),
				assignToken.endColumn);
		}
		return new VariableDeclaration(currentSegment,
			variable,
			initializer,
			"=",
			variable.getSourceStart(),
			initializer.getSourceEnd(),
			variable.getBeginLine(),
			initializer.getEndLine(),
			variable.getBeginColumn(),
			initializer.getEndColumn());
	}
} //}}}

//{{{ VariableDeclaratorNoSuffix()
/**
 * a strict variable declarator : there cannot be a suffix here.
 * It will be used by fields and formal parameters
 */
VariableDeclaration VariableDeclaratorNoSuffix() :
{
	Token identifierToken, lbrace,rbrace;
	Expression expr;
	Expression initializer = null;
	Token assignToken = null;
	Token dollarToken;
	Variable variable;
}
{
	dollarToken = <DOLLAR>
	try
	{
		(
			identifierToken = <IDENTIFIER>
			{
				variable = new Variable(identifierToken.image,
					dollarToken.sourceStart,
					identifierToken.sourceEnd,
					dollarToken.beginLine,
					identifierToken.endLine,
					dollarToken.beginColumn,
					identifierToken.endColumn);
			}
		|
			lbrace = <LBRACE> expr = Expression() rbrace = <RBRACE>
			{
				variable = new Variable(expr,
					lbrace.sourceStart,
					rbrace.sourceEnd,
					lbrace.beginLine,
					rbrace.endLine,
					lbrace.beginColumn,
					rbrace.endColumn);
			}
		)
	}
	catch (ParseException e)
	{
		fireParseError("identifier expected", "", e.currentToken);
		variable = new Variable("",
			e.currentToken.sourceStart,
			e.currentToken.sourceEnd,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.beginColumn,
			e.currentToken.endColumn);
	}
	[
		assignToken = <ASSIGN>
		try
		{
			initializer = VariableInitializer()
		}
		catch (ParseException e)
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"Literal expression expected in variable initializer",
				"literal",
				e.currentToken.image,
				assignToken.sourceEnd,
				assignToken.sourceEnd +1,
				e.currentToken.beginLine,
				e.currentToken.endLine,
				e.currentToken.endColumn,
				e.currentToken.endColumn+1));
		}
	]
	{
		setTypeFromScope(variable);
		if (assignToken == null)
		{
			return new VariableDeclaration(currentSegment,
				variable);
		}
		if (initializer == null)
		{
			return new VariableDeclaration(currentSegment,
				variable,
				null,
				"=",
				variable.getSourceStart(),
				assignToken.sourceEnd,
				variable.getBeginLine(),
				assignToken.endLine,
				variable.getBeginColumn(),
				assignToken.endColumn);
		}
		return new VariableDeclaration(currentSegment,
			variable,
			initializer,
			"=",
			variable.getSourceStart(),
			initializer.getSourceEnd(),
			variable.getBeginLine(),
			initializer.getEndLine(),
			variable.getBeginColumn(),
			initializer.getEndColumn());
	}
} //}}}

//{{{ VariableDeclarator()
/**
 * this will be used by static statement
 */
VariableDeclaration VariableDeclarator() :
{
	AbstractVariable variable;
	Expression initializer = null;
	Token assignToken = null;
}
{
	variable = VariableDeclaratorId()
	[
		assignToken = <ASSIGN>
		try 
		{
			initializer = VariableInitializer()
		} 
		catch (ParseException e) 
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"Literal expression expected in variable initializer",
				"literal",
				e.currentToken.image,
				token.sourceEnd,
				token.sourceEnd+1,
				e.currentToken.beginLine,
				e.currentToken.endLine,
				e.currentToken.endColumn,
				e.currentToken.endColumn+1));
		}
	]
	{
		if (assignToken == null) 
		{
			return new VariableDeclaration(currentSegment,
				variable);
		}
		if (initializer == null) 
		{
			return new VariableDeclaration(currentSegment,
				variable,
				null,
				"=",
				variable.getSourceStart(),
				assignToken.sourceEnd,
				variable.getBeginLine(),
				assignToken.endLine,
				variable.getBeginColumn(),
				assignToken.endColumn);
		}
		return new VariableDeclaration(currentSegment,
			variable,
			initializer,
			"=",
			variable.getSourceStart(),
			initializer.getSourceEnd(),
			variable.getBeginLine(),
			initializer.getEndLine(),
			variable.getBeginColumn(),
			initializer.getEndColumn());
	}
} //}}}

//{{{ VariableDeclaratorId()
/**
 * A Variable name.
 * @return the variable name (with suffix)
 */
AbstractVariable VariableDeclaratorId():
{
	AbstractVariable var;
}
{
	var = Variable()
	(
		var = VariableSuffix(var)
		)*
	{
		return var;
	}
} //}}}

//{{{ Variable()
Variable Variable():
{
	Variable variable;
	Token dollarToken;
}
{
	dollarToken = <DOLLAR>
	try 
	{
		variable = Var()
	}
	catch (ParseException e)
	{
		fireParseError("'variable' expected","=",e.currentToken);
		variable = new  Variable("",
			dollarToken.sourceStart,
			e.currentToken.next.sourceStart,
			dollarToken.beginLine,
			e.currentToken.next.beginLine,
			dollarToken.beginColumn,
			e.currentToken.next.beginColumn);
	}
	{
		return variable;
	}
}

//}}}

//{{{ Var()
Variable Var():
{
	Variable variable;
	Token token, token2;
	Expression expression;
}
{
	(
		//{{{ <DOLLAR>
		token = <DOLLAR> variable = Var()
		{
			fireParseMessage(new PHPParseMessageEvent(INFO,
				PHPParseMessageEvent.MESSAGE_DOUBLE_DOLLAR,
				path,
				"You have several $$, this may be a bug",
				token.sourceStart,
        			token.sourceEnd,
        			token.beginLine,
        			token.endLine,
        			token.beginColumn,
        			token.endColumn));
			variable = new Variable(variable,
				variable.getSourceStart(),
				variable.getSourceEnd(),
				variable.getBeginLine(),
				variable.getEndLine(),
				variable.getBeginColumn(),
				variable.getBeginColumn());
		} //}}}

	|
		token = <LBRACE> expression = Expression() token2 = <RBRACE>
		{
			variable = new Variable(expression,
				token.sourceStart,
				token2.sourceEnd,
				token.beginLine,
				token2.endLine,
				token.beginColumn,
				token2.endColumn);
		}
		|
		token = <IDENTIFIER>
		{
			variable = new Variable(token);
		}
	)
	{
		setTypeFromScope(variable);
		return variable;
	}
} //}}}

//{{{ VariableInitializer()
 Expression VariableInitializer() :
{
  Expression expr;
}
{
  //{{{ literal
  LOOKAHEAD(2)
  expr = Literal()
  {
    return expr;
  } //}}}
|
  //{{{ +/- integer
  {
	  Token value;
	  Token operator;
  }
  (operator = <PLUS> | operator = <MINUS>) (value = <INTEGER_LITERAL> | value = <FLOATING_POINT_LITERAL>)
  {
    return new PrefixedUnaryExpression(new NumberLiteral(Type.INTEGER,value),
                                       operator);
  } //}}}
|
  //{{{ array
  expr = ArrayDeclarator()
  {
	  return expr;
  } //}}}
  // expr = methodDeclaration(CONST_FUNCTION,null)
  // {
	//   return expr;
  // }
|
    (
        expr = classIdentifier()
        (
         expr = VariableSuffix(expr)
        )*
      |
        expr = VariableDeclaratorId()
    )
    {
      return expr;
    }
} //}}}


//}}}

//{{{ Arrays

//{{{ ArrayVariable()

ArrayVariableDeclaration ArrayVariable() :
{
Expression expr,expr2;
Token arrayAssignToken;
}
{
  expr = Expression()
  [
    arrayAssignToken = <ARRAYASSIGN> expr2 = Expression()
    {
      int sourceEnd,endLine,endColumn;
      if (expr2 == null) {
        sourceEnd = arrayAssignToken.sourceEnd;
        endLine   = arrayAssignToken.endLine;
        endColumn = arrayAssignToken.endColumn;
      } else {
        sourceEnd = expr2.getSourceEnd();
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }

      return new ArrayVariableDeclaration(expr,expr2,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);}
  ]
  {
    return new ArrayVariableDeclaration(expr,expr.getSourceEnd(),expr.getBeginLine(),expr.getEndLine(),expr.getBeginColumn(),expr.getEndColumn());
  }
}

//}}}

//{{{ ArrayInitializer()
ArrayVariableDeclaration[] ArrayInitializer():
{
	ArrayVariableDeclaration expr;
	List<ArrayVariableDeclaration> list = new ArrayList<ArrayVariableDeclaration>();
}
{
	<LPAREN>
	[
		expr = ArrayVariable()
		{
			list.add(expr);
		}
		(
			LOOKAHEAD(2) <COMMA> expr = ArrayVariable()
			{
				list.add(expr);
			}
		)*
	]
	[
		<COMMA> {list.add(null);}
	]
	<RPAREN>
	{
		ArrayVariableDeclaration[] vars = new ArrayVariableDeclaration[list.size()];
		list.toArray(vars);
		return vars;
	}
} //}}}


//}}}

//{{{ METHODS

//{{{ methodDeclaration()
/**
 * A Method Declaration.
 * <b>function</b> MetodDeclarator() Block()
 *
 * @return a MethodDeclaration
 */
MethodDeclaration methodDeclaration(int type, List<Modifier> modifiers):
{
	MethodDeclaration functionDeclaration;
	MethodHeader methodHeader;
	Block block;
	Outlineable seg = currentSegment;
	Token functionToken;
	Token semicolon;
}
{
	functionToken = <FUNCTION>
	methodHeader = methodHeader(functionToken,type, modifiers)
	{
		functionDeclaration = new MethodDeclaration(currentSegment,methodHeader);
		currentSegment = functionDeclaration;
		scope = new Scope();
		scopeStack.push(scope);
	}
	(
		block = Block()
		{
			functionDeclaration.setStatements(block.getStatements());
			functionDeclaration.setBodyLineStart(block.getBeginLine());
			functionDeclaration.setBodyColumnStart(block.getBeginColumn());
			functionDeclaration.setBodyLineEnd(block.getEndLine());
			functionDeclaration.setBodyColumnEnd(block.getEndColumn());
		}
		|
		semicolon = <SEMICOLON>
		{
			functionDeclaration.setBodyLineStart(semicolon.beginLine);
			functionDeclaration.setBodyColumnStart(semicolon.beginColumn);
			functionDeclaration.setBodyLineEnd(semicolon.endLine);
			functionDeclaration.setBodyColumnEnd(semicolon.endColumn);
		}
	)
	{
		currentSegment = seg;
		scope = new Scope();
		scopeStack.push(scope);
		return functionDeclaration;
	}
}//}}}

//{{{ closureDeclaration()
MethodDeclaration closureDeclaration():
{
	MethodDeclaration functionDeclaration;
	List<FormalParameter> formalParameters = new ArrayList<FormalParameter>();
	MethodHeader methodHeader;
	Block block;
	Outlineable seg = currentSegment;
	Token functionToken;
	Token use;
	ArgumentList useArguments = null;
}
{
	functionToken = <FUNCTION>
	formalParameters(formalParameters)
	[
		use = <USE>
		try
		{
			useArguments = arguments()
		}
		catch (ParseException e)
		{
			fireParseError("arguments list expected","($a,$b)",e.currentToken.next);
			error_skipto(LBRACE);
		}
	]
	
	{
		methodHeader = new MethodHeader(namespace,
			path,
			null,
			"",
			false,
			useArguments,
			formalParameters,
			functionToken.sourceStart,
			token.sourceEnd,
			functionToken.beginLine,
			token.endLine,
			functionToken.beginColumn,
			token.endColumn);
		functionDeclaration = new MethodDeclaration(currentSegment,methodHeader);
		currentSegment = functionDeclaration;
		scope = new Scope();
		scopeStack.push(scope);
	}
	block = Block()
	{
		functionDeclaration.setStatements(block.getStatements());
		functionDeclaration.setBodyLineStart(block.getBeginLine());
		functionDeclaration.setBodyColumnStart(block.getBeginColumn());
		functionDeclaration.setBodyLineEnd(block.getEndLine());
		functionDeclaration.setBodyColumnEnd(block.getEndColumn());
	}
	{
		currentSegment = seg;
		scope = new Scope();
		scopeStack.push(scope);
		return functionDeclaration;
	}
}//}}}

//{{{ methodHeader()
/**
 * A MethodDeclarator.
 * [&] IDENTIFIER(parameters ...).
 *
 * @return a function description for the outline
 */
MethodHeader methodHeader(Token functionToken,int type, List<Modifier> modifiers):
{
	Token reference = null;
	List<FormalParameter> formalParameters = new ArrayList<FormalParameter>();
	Token methodNameToken;
	String identifierChar = SYNTAX_ERROR_CHAR;
}
{
	[
		reference = <BIT_AND>
	]
	{
		try
		{
			if (type == CONST_FUNCTION)
			{
				methodNameToken = functionIdentifier();
			}
			else
			{
				methodNameToken = methodIdentifier();
			}
			identifierChar = methodNameToken.image;
		}
		catch (ParseException e)
		{
			if (e.currentToken.next.kind == LPAREN)
			{
				//{{{ Parse error
				fireParseError(new PHPParseErrorEvent(ERROR,
								      path,
								      "identifier expected",
								      "identifier",
								      e.currentToken.image,
								      functionToken.sourceStart,
								      e.currentToken.sourceStart,
								      e.currentToken.beginLine,
								      e.currentToken.endLine,
								      e.currentToken.beginColumn-1,
								      e.currentToken.endColumn)); //}}}
			}
			else
			{
				fireParseError("unexpected token","identifier",e.currentToken.next);
			}
		}
	}
	formalParameters(formalParameters)
	{
		return new MethodHeader(namespace,
					path,
					modifiers,
					identifierChar,
					reference != null,
					null,// use
					formalParameters,
					functionToken.sourceStart,
					token.sourceEnd,
					functionToken.beginLine,
					token.endLine,
					functionToken.beginColumn,
					token.endColumn);
	}
} //}}}

//{{{ functionIdentifier()
/**
 * This is a function identifier.
 * It's not exactly the same as methodIdentifier since methods can use a lot of keywords for their names.
 *
 * @return an identifier for a function
 */
Token functionIdentifier():
{
	Token functionIdentifier;
}
{
	(
		functionIdentifier = <IDENTIFIER>
	|
		functionIdentifier = <NULL>
	)
	{
		return functionIdentifier;
	}
} //}}}

//{{{ methodIdentifier()
/**
 * This is a method identifier.
 * It can returns a lot of keywords since those are allowed (but discouraged for method names).
 *
 * @return an identifier for a function
 */
Token methodIdentifier():
{
	Token methodIdentifier;
}
{
	(
	 methodIdentifier = <IDENTIFIER>
	 | methodIdentifier = <DEFINE>
	 | methodIdentifier = <GOTO>
	 | methodIdentifier = <NEW>
	 | methodIdentifier = <SUPER>
	 | methodIdentifier = <THIS>
	 | methodIdentifier = <TRUE>
	 | methodIdentifier = <FALSE>
	 | methodIdentifier = <STRING>
	 | methodIdentifier = <OBJECT>
	 | methodIdentifier = <BOOL>
	 | methodIdentifier = <BOOLEAN>
	 | methodIdentifier = <REAL>
	 | methodIdentifier = <DOUBLE>
	 | methodIdentifier = <FLOAT>
	 | methodIdentifier = <INT>
	 | methodIdentifier = <INTEGER>
	 | methodIdentifier = <CLASS>
	 | methodIdentifier = <_DEFAULT>
	 | methodIdentifier = <FUNCTION>
	 | methodIdentifier = <VAR>
	 | methodIdentifier = <IF>
	 | methodIdentifier = <ELSEIF>
	 | methodIdentifier = <ELSE>
	 | methodIdentifier = <BREAK>
	 | methodIdentifier = <NULL>
	 | methodIdentifier = <CLONE>
	 )
	{
		return methodIdentifier;
	}
} //}}}

//{{{ constantIdentifier()
/**
 * This is a constant identifier.
 * It can returns a lot of keywords
 *
 * @return an identifier for a function
 */
Token constantIdentifier():
{
	Token constantIdentifier;
}
{
	(
		constantIdentifier = <IDENTIFIER>
	|
		constantIdentifier = <DEFINE>
	|
		constantIdentifier = <GOTO>
	|
		constantIdentifier = <SUPER>
	|
		constantIdentifier = <THIS>
	|
		constantIdentifier = <STRING>
	|
		constantIdentifier = <OBJECT>
	|
		constantIdentifier = <BOOL>
	|
		constantIdentifier = <BOOLEAN>
	|
		constantIdentifier = <REAL>
	|
		constantIdentifier = <DOUBLE>
	|
		constantIdentifier = <FLOAT>
	|
		constantIdentifier = <INT>
	|
		constantIdentifier = <INTEGER>
	)
	{
		return constantIdentifier;
	}
} //}}}

//{{{ formalParameters(List parameters)
/**
 * formalParameters follows method identifier.
 * (formalParameter())
 */
void formalParameters(List<FormalParameter> parameters):
{
	FormalParameter var;
}
{
	//{{{ LPAREN
	try
	{
		<LPAREN>
	}
	catch (ParseException e)
	{
		fireParseError("'(' expected", "(",e.currentToken);
	} //}}}

	//{{{ Parameters
	[
		//{{{ parameter
		try
		{
			var = formalParameter()
			{
				parameters.add(var);
			}
		}
		catch (ParseException e)
		{
			fireParseError("parameter expected",
					"parameter",e.currentToken);
		} //}}}
		(
			<COMMA>
			try
			{
				var = formalParameter()
				{
					parameters.add(var);
				}
			}
			catch (ParseException e)
			{
				fireParseError("parameter expected",
					"parameter",e.currentToken);
			}
		)*
	] //}}}

	//{{{ RPAREN
	try
	{
		<RPAREN>
	}
	catch (ParseException e)
	{ //recup rparen si avant lbrace
		Token nextToken = getNextToken();
		while (nextToken.kind != EOF && nextToken.kind != RPAREN && nextToken.kind != LBRACE)
		{
			nextToken = getNextToken();
		}
		if (nextToken.kind == EOF)
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"unexpected end of file",
				")",
				e.currentToken.next.image,
				e.currentToken.sourceEnd,
				nextToken.sourceStart,
				e.currentToken.beginLine,
				nextToken.endLine,
				e.currentToken.endColumn,
				nextToken.endColumn));
		}
		else if (nextToken.kind == RPAREN)
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"unexpected tokens",
				"",
				e.currentToken.next.image,
				e.currentToken.next.sourceEnd,
				nextToken.sourceStart,
				e.currentToken.next.beginLine,
				nextToken.beginLine,
				e.currentToken.next.endColumn+1,
				nextToken.beginColumn-1));
		}
		else
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"')' expected",
				")",
				e.currentToken.next.image,
				e.currentToken.sourceEnd,
				nextToken.sourceStart,
				e.currentToken.beginLine,
				nextToken.endLine,
				e.currentToken.endColumn+1,
				nextToken.endColumn-1));
		}
	} //}}}
} //}}}

//{{{ formalParameter()
/**
 * A formal parameter.
 * $varname[=value] (,$varname[=value])
 */
FormalParameter formalParameter():
{
	VariableDeclaration variableDeclaration;
	FormalParameter parameter;
	Token bitAndToken = null;
	ConstantIdentifier typeHint = null;
	int startOffset = -1;
	int startLine = -1;
	int startColumn = -1;
}
{
	[
		{
			Token typeToken;
		}
		(
			typeToken = methodIdentifier()
			{
				typeHint = new ObjectIdentifier(typeToken);
				startOffset = typeToken.sourceStart;
				startLine = typeToken.beginLine;
				startColumn = typeToken.beginColumn;
			}
		)
	|
		(
			typeToken = <ARRAY>
			{
				typeHint = new ConstantIdentifier(typeToken);
				startOffset = typeToken.sourceStart;
				startLine = typeToken.beginLine;
				startColumn = typeToken.beginColumn;
			}
		)

	]
	[
		bitAndToken = <BIT_AND>
		{
			if (startOffset == -1)
			{
				startOffset = bitAndToken.sourceStart;
				startLine = bitAndToken.beginLine;
				startColumn = bitAndToken.beginColumn;
			}
		}
	] 
	variableDeclaration = VariableDeclaratorNoSuffix()
	{
		if (bitAndToken != null)
		{
			variableDeclaration.setReference(true,
				bitAndToken.sourceStart,bitAndToken.beginLine,
				bitAndToken.beginColumn);
		}
		if (startOffset == -1)
		{
			startOffset = variableDeclaration.getSourceStart();
			startLine = variableDeclaration.getBeginLine();
			startColumn = variableDeclaration.getBeginColumn();

		}
		Expression initialization = variableDeclaration.getInitialization();
		if (initialization == null)
		{
			parameter = new FormalParameter(typeHint,
				variableDeclaration.getName(),
				bitAndToken != null,
				startOffset,
				variableDeclaration.getSourceEnd(),
				startLine,
				variableDeclaration.getEndLine(),
				startColumn,
				variableDeclaration.getEndColumn());
		}
		else
		{
			parameter = new FormalParameter(typeHint,
				variableDeclaration.getName(),
				bitAndToken != null,
				variableDeclaration.getInitialization().toStringExpression(),
				startOffset,
				variableDeclaration.getSourceEnd(),
				startLine,
				variableDeclaration.getEndLine(),
				startColumn,
				variableDeclaration.getEndColumn());
		}
		return parameter;
	}
} //}}}

//}}}

//{{{ Type()
ConstantIdentifier Type():
{
	Token token;
}
{
	(
		token = <STRING>
	|
		token = <BOOL>
	|
		token = <BOOLEAN>
	|
		token = <REAL>
	|
		token = <DOUBLE>
	|
		token = <FLOAT>
	|
		token = <INT>
	|
		token = <INTEGER>
	|
		token = <OBJECT>
	)
	{
		return new ConstantIdentifier(token);
	}
} //}}}

//{{{ EXPRESSIONS

//{{{ Expression()
Expression Expression():
{
	Expression expr;
}
{
	(
		expr = PrintExpression()
	|
		try
		{
			expr = ConditionalExpression()
		}
		catch (ParseException e)
		{
			//{{{ Parse Exception
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"expression expected",
				"expression",
				e.currentToken.image,
				token.sourceEnd,
				token.sourceEnd,
				e.currentToken.beginLine,
				e.currentToken.endLine,
				e.currentToken.endColumn,
				e.currentToken.endColumn)); //}}}
			return new DummyExpression(e.currentToken);
		}
	)
	{
		return expr;
	}
} //}}}

//{{{ assignment()
Expression assignment():
{
	Expression expr;
	Expression initializer;
	Token assignOperator;
}
{
	(
		LOOKAHEAD(prefixedPrimaryExpression() AssignmentOperator())
		expr = prefixedPrimaryExpression()
		assignOperator = AssignmentOperator()
		(
			initializer = assignment()
		|
			initializer = closureDeclaration()
		)
		{
			if (initializer == null)
			{
				initializer = new DummyExpression(assignOperator.next);
			}
			expr = new Assignment(expr,
				initializer,
				assignOperator.kind,
				expr.getSourceStart(),
				initializer.getSourceEnd(),
				expr.getBeginLine(),
				initializer.getEndLine(),
				expr.getBeginColumn(),
				initializer.getEndColumn());
		}
	|
		expr = InclusiveOrExpression()
	)
	{
		return expr;
	}
} //}}}

//{{{ prefixedPrimaryExpression()
 Expression prefixedPrimaryExpression() :
{
	Expression expr;
	Token prefix = null;
}
{
	(
		prefix = <BANG> expr = prefixedPrimaryExpression()
	|
		prefix = <AT> expr = prefixedPrimaryExpression()
	|
		prefix = <TILDE> expr = prefixedPrimaryExpression()
	|
		expr = PrimaryExpression()
	)
	{
		if (prefix != null)
			expr = new PrefixedUnaryExpression(expr, prefix);
		return expr;
	}
} //}}}

//}}}

//{{{ AssignmentOperator()
/**
 * Any assignement operator.
 *
 * @return the assignement operator token
 */
Token AssignmentOperator():
{
	Token assignOperator;
}
{
	(
		assignOperator = <ASSIGN>
		| assignOperator = <STARASSIGN>
		| assignOperator = <SLASHASSIGN>
		| assignOperator = <REMASSIGN>
		| assignOperator = <PLUSASSIGN>
		| assignOperator = <MINUSASSIGN>
		| assignOperator = <LSHIFTASSIGN>
		| assignOperator = <RSIGNEDSHIFTASSIGN>
		| assignOperator = <ANDASSIGN>
		| assignOperator = <XORASSIGN>
		| assignOperator = <ORASSIGN>
		| assignOperator = <DOTASSIGN>
		| assignOperator = <TILDEEQUAL>
		)
	{
		return assignOperator;
	}
} //}}}

//{{{ ConditionalExpression()
Expression ConditionalExpression():
{
	Expression expr;
	Expression expr2 = null;
	Expression expr3 = null;
}
{
	expr = ConditionalOrExpression()
	[
		<HOOK>
		(
			<COLON> expr3 = Expression()
		|
			expr2 = Expression()
			<COLON> expr3 = Expression()
		)

	]
	{
		if (expr3 == null)
		{
			return expr;
		}
		ConditionalExpression conditionalExpression = new ConditionalExpression(expr,expr2,expr3);
		//conditionalExpression.analyzeCode(this);
		return conditionalExpression;
	}
} //}}}

//{{{ ConditionalOrExpression()
Expression ConditionalOrExpression():
{
	Expression expr,expr2;
	int sourceEnd,endLine,endColumn;
	Token orToken;
}
{
	expr = ConditionalAndExpression()
	(
		(
			orToken = <OR_OR>
		|
			orToken = <_ORL>
		|
			orToken = <XOR>
		)
		expr2 = ConditionalAndExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = orToken.sourceEnd;
				endLine   = orToken.endLine;
				endColumn = orToken.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,orToken.kind,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ ConditionalAndExpression()
Expression ConditionalAndExpression():
{
	Expression expr,expr2;
	int sourceEnd,endLine,endColumn;
	Token andToken;
}
{
	expr = ConcatExpression()
	(
		(
			andToken = <AND_AND>
		|
			andToken = <_ANDL>
		)
		expr2 = ConcatExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = andToken.sourceEnd;
				endLine   = andToken.endLine;
				endColumn = andToken.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,andToken.kind,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ ConcatExpression()
Expression ConcatExpression():
{
	Expression expr,expr2;
	Token dotToken;
	int sourceEnd,endLine,endColumn;
}
{
	expr = assignment()
	(
		dotToken = <DOT> expr2 = assignment()
		{
			if (expr2 == null)
			{
				sourceEnd = dotToken.sourceEnd;
				endLine   = dotToken.endLine;
				endColumn = dotToken.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,
				DOT,expr.getSourceStart(),
				sourceEnd,expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ InclusiveOrExpression()
Expression InclusiveOrExpression():
{
	Expression expr,expr2;
	Token bitOrToken;
	int sourceEnd,endLine,endColumn;
}
{
	expr = ExclusiveOrExpression()
	(
		bitOrToken = <BIT_OR> expr2 = ExclusiveOrExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = bitOrToken.sourceEnd;
				endLine   = bitOrToken.endLine;
				endColumn = bitOrToken.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,
				BIT_OR,expr.getSourceStart(),
				sourceEnd,expr.getBeginLine(),
				endLine,expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ ExclusiveOrExpression()
Expression ExclusiveOrExpression():
{
	Expression expr,expr2;
	Token bitXorToken;
	int sourceEnd,endLine,endColumn;
}
{
	expr = AndExpression()
	(
		bitXorToken = <BIT_XOR> expr2 = AndExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = bitXorToken.sourceEnd;
				endLine   = bitXorToken.endLine;
				endColumn = bitXorToken.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,
				BIT_XOR,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ AndExpression()
Expression AndExpression():
{
	Expression expr,expr2;
	Token bitAndToken;
	int sourceEnd,endLine,endColumn;
}
{
	expr = EqualityExpression()
	(
		LOOKAHEAD(1)
		bitAndToken = <BIT_AND> expr2 = EqualityExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = bitAndToken.sourceEnd;
				endLine   = bitAndToken.endLine;
				endColumn = bitAndToken.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,
				BIT_AND,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ EqualityExpression()
Expression EqualityExpression() :
{
	Expression expr,expr2;
	Token token;
	int sourceEnd,endLine,endColumn;
}
{
	expr = instanceofExpression()
	(
		(
			token = <EQUAL_EQUAL>
		|
			token = <DIF>
		|
			token = <NOT_EQUAL>
		|
			token = <BANGDOUBLEEQUAL>
		|
			token = <TRIPLEEQUAL>
		)
		try
		{
			expr2 = instanceofExpression()
		}
		catch (ParseException e)
		{
			if (errorMessage != null)
			{
				throw e;
			}
			expr2 = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
				token.sourceEnd +1,
				token.sourceEnd +1,
				token.beginLine,
				token.endLine,
				token.beginColumn,
				token.endColumn);
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"expression expected",
				"expression",
				e.currentToken.image,
				token.sourceEnd,
				token.sourceEnd+1,
				e.currentToken.beginLine,
				e.currentToken.endLine,
				e.currentToken.endColumn,
				e.currentToken.endColumn+1));
		}
		{
			if (expr2 == null)
			{
				sourceEnd = token.sourceEnd;
				endLine   = token.endLine;
				endColumn = token.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,
				token.kind,expr.getSourceStart(),
				sourceEnd,expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
		)*
	{
		return expr;
	}
} //}}}

//{{{ instanceofExpression()
Expression instanceofExpression():
{
	Expression expr;
	Expression expr2 = null;
	int sourceEnd,endLine,endColumn;
}
{
	expr = RelationalExpression()
	[
		<INSTANCEOF>
		try
		{
			(
				expr2 = classIdentifier()
			|
				expr2 = VariableDeclaratorId()
			)
		}
		catch (ParseException e)
		{
			fireParseError("string or object expected","string or object",e.currentToken.next);
		}
		{
			if (expr2 == null)
			{
				sourceEnd = token.sourceEnd;
				endLine   = token.endLine;
				endColumn = token.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,
				INSTANCEOF,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	]
	{
		return expr;
	}
} //}}}

//{{{ RelationalExpression()
Expression RelationalExpression() :
{
	Expression expr,expr2;
	int sourceEnd,endLine,endColumn;
	Token token;
}
{
	expr = ShiftExpression()
	(
		(
			token = <LT>
		|
			token = <GT>
		|
			token = <LE>
		|
			token = <GE>
		)
		expr2 = ShiftExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = token.sourceEnd;
				endLine   = token.endLine;
				endColumn = token.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,token.kind,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ ShiftExpression()
Expression ShiftExpression():
{
	Expression expr,expr2;
	int sourceEnd,endLine,endColumn;
	Token shiftToken;
}
{
	expr = AdditiveExpression()
	(
		(
			shiftToken = <LSHIFT>
		|
			shiftToken = <RSIGNEDSHIFT>
		|
			shiftToken = <RUNSIGNEDSHIFT>
		)
		expr2 = AdditiveExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = shiftToken.sourceEnd;
				endLine   = shiftToken.endLine;
				endColumn = shiftToken.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,shiftToken.kind,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ AdditiveExpression()
Expression AdditiveExpression():
{
	Expression expr,expr2;
	int sourceEnd,endLine,endColumn;
	Token token;
}
{
	expr = MultiplicativeExpression()
	(
		LOOKAHEAD(1)
		(
			token = <PLUS>
		|
			token = <MINUS>
		)
		expr2 = MultiplicativeExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = token.sourceEnd;
				endLine   = token.endLine;
				endColumn = token.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,token.kind,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ MultiplicativeExpression()
Expression MultiplicativeExpression():
{
	Expression expr;
	Expression expr2;
	int sourceEnd,endLine,endColumn;
	Token token;
}
{
	try
	{
		expr = UnaryExpression()
	}
	catch (ParseException e)
	{
		if (errorMessage != null) throw e;
		errorMessage = "unexpected token "+e.currentToken.next.image;
		errorStart = this.token.sourceStart;
		errorEnd   = this.token.sourceEnd;
		throw e;
	}
	(
		(
			token = <STAR>
		|
			token = <SLASH>
		|
			token = <REMAINDER>
		)
		expr2 = UnaryExpression()
		{
			if (expr2 == null)
			{
				sourceEnd = token.sourceEnd;
				endLine   = token.endLine;
				endColumn = token.endColumn;
			}
			else
			{
				sourceEnd = expr2.getSourceEnd();
				endLine   = expr2.getEndLine();
				endColumn = expr2.getEndColumn();
			}
			expr = new BinaryExpression(expr,expr2,token.kind,
				expr.getSourceStart(),sourceEnd,
				expr.getBeginLine(),endLine,
				expr.getBeginColumn(),endColumn);
		}
	)*
	{
		return expr;
	}
} //}}}

//{{{ UnaryExpression()
/**
 * An unary expression starting with @, & or nothing.
 *
 * @return the unary expression
 */
Expression UnaryExpression() :
{
	Expression expr;
}
{
	try
	{
		expr = AtNotTildeUnaryExpression() {return expr;}
	}
	catch (ParseException e)
	{
		fireParseError("unexpected token : "+e.currentToken.image, "", e.currentToken);
		Token nextToken = getNextToken();
		while (nextToken.kind != EOF && nextToken.kind != SEMICOLON)
		{
			nextToken = getNextToken();
		}
		if (nextToken.kind == EOF)
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"unexpected end of file",
				")",
				e.currentToken.next.image,
				e.currentToken.sourceEnd,
				nextToken.sourceStart,
				e.currentToken.beginLine,
				nextToken.endLine,
				e.currentToken.endColumn,
				nextToken.endColumn));
		}
		else
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"expression expected",
				")",
				e.currentToken.next.image,
				e.currentToken.sourceEnd,
				nextToken.sourceStart,
				e.currentToken.beginLine,
				nextToken.endLine,
				e.currentToken.endColumn+1,
				nextToken.endColumn-1));
		}
		return null;
		/*



		getNextToken();
		return UnaryExpression();
		*/
	}
} //}}}

//{{{ AtNotTildeUnaryExpression()
Expression AtNotTildeUnaryExpression() :
{
	if (shouldStop)
		throw new ParsingAbortedError();
	Expression expr;
	Token prefix = null;
}
{
	(
		prefix = <AT> expr = AtNotTildeUnaryExpression()
	|
		prefix = <TILDE> expr = AtNotTildeUnaryExpression()
	|
		prefix = <BANG> expr = AtNotUnaryExpression()
	|
		expr = UnaryExpressionNoPrefix()
	)
	{
		if (prefix != null)
			expr = new PrefixedUnaryExpression(expr, prefix);
		return expr;
	}
} //}}}

//{{{ AtNotUnaryExpression()
/**
 * An expression prefixed (or not) by one or more @ and !.
 * @return the expression
 */
Expression AtNotUnaryExpression() :
{
	Expression expr;
	Token prefix = null;
}
{
	(
		prefix = <AT> expr = AtNotUnaryExpression()
	|
		prefix = <BANG> expr = AtNotUnaryExpression()
	|
		expr = UnaryExpressionNoPrefix()
	)
	{
		if (prefix != null)
			expr = new PrefixedUnaryExpression(expr, prefix);
		return expr;
	}
} //}}}

//{{{ UnaryExpressionNoPrefix()
Expression UnaryExpressionNoPrefix() :
{
	Expression expr;
	Token prefix = null;
}
{
	(
		prefix = <PLUS> expr = AtNotTildeUnaryExpression()
	|
		prefix = <MINUS> expr = AtNotTildeUnaryExpression()
	|
		expr = PreIncDecExpression()
	|
		expr = UnaryExpressionNotPlusMinus()
	)
	{
		if (prefix != null)
			expr = new PrefixedUnaryExpression(expr, prefix);
		return expr;
	}
} //}}}

//{{{ PreIncDecExpression()
Expression PreIncDecExpression() :
{
	Expression expr;
	Token prefix;
}
{
	(
		prefix = <PLUS_PLUS>
	|
		prefix = <MINUS_MINUS>
	)
	expr = PrimaryExpression()
	{
		return new PrefixedUnaryExpression(expr, prefix);
	}
} //}}}

//{{{ UnaryExpressionNotPlusMinus()
Expression UnaryExpressionNotPlusMinus():
{
	Expression expr;
}
{
	LOOKAHEAD( <LPAREN> (Type() | <ARRAY>) <RPAREN> )
	expr = CastExpression()         {return expr;}
	| expr = PostfixExpression()      {return expr;}
	| expr = Literal()                {return expr;}
	| <LPAREN> expr = Expression()
	try
	{
		<RPAREN>
	}
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"')' expected",
			")",
			e.currentToken.image,
			expr.getSourceEnd(),
			expr.getSourceEnd()+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	{
		return expr;
	}
} //}}}

//{{{ CastExpression()
CastExpression CastExpression():
{
	ConstantIdentifier type;
	Expression expr;
	Token lParen;
	Token arrayToken;
}
{
	lParen = <LPAREN>
	(
		type = Type()
	|
		arrayToken = <ARRAY>
		{
			type = new ConstantIdentifier(arrayToken);
		}
	)
	<RPAREN> expr = UnaryExpression()
	{
		return new CastExpression(type,
			expr,
			lParen.sourceStart,
			expr.getSourceEnd(),
			lParen.beginLine,
			expr.getEndLine(),
			lParen.beginColumn,
			expr.getEndColumn());
	}
} //}}}

//{{{ PostfixExpression()
Expression PostfixExpression():
{
	Expression expr;
	Token token = null;
}
{
	expr = PrimaryExpression()
	[
		token = <PLUS_PLUS>
	|
		token = <MINUS_MINUS>
	]
	{
		if (token == null)
		{
			return expr;
		}
		return new PostfixedUnaryExpression(expr,
			token.kind,
			token.sourceEnd,
			token.endLine,
			token.endColumn);
	}
} //}}}

//{{{ PrimaryExpression()
Expression PrimaryExpression():
{
	Expression expr;
	Token bitAndToken = null;
}
{
	(
		[bitAndToken = <BIT_AND>] expr = refPrimaryExpression(bitAndToken)
	|
		expr = cloning()
	|
		expr = ArrayDeclarator()
	|
		expr = ListExpression()
	|
		expr = IncludeExpression()
	)
	{
		return expr;
	}
} //}}}

//{{{ refPrimaryExpression(Token reference)
/**
 * @param bitAndToken it is the token with the &, it can be null if there is no
 * such token
 */
Expression refPrimaryExpression(Token bitAndToken):
{
	Expression expr;
	Token identifier;
}
{
	(
		expr = instantiation(bitAndToken)
	|
		(
			identifier = constantIdentifier()
			{
				expr = new ConstantIdentifier(identifier);
			}
		|
			identifier = <STATIC>
			{
				expr = new ConstantIdentifier(identifier);
			}
		|
			expr = Variable()  //todo use the bitAndToken parameter ...
		)
		(
			{
				ArgumentList argumentList;
			}
			argumentList = arguments()
			{
				expr = new FunctionCall(expr,
					argumentList);
			}
		|
			expr = staticClassAccess(expr)
		|
			expr = classAccess(expr)
		|
			expr = arrayDeclarator(expr)
		)*
	)
	{
		return expr;
	}
} //}}}

//{{{ fullyQualifiedIdentifier() method
Expression fullyQualifiedIdentifier():
{
	Token token;
}
{
	<BACKSLASH> token = <NAMESPACE_NAME>
	{
		return new ConstantIdentifier(token);
	}
|
	 token = <NAMESPACE_NAME>
	 {
	 	 return new ConstantIdentifier(token);
	 }
} //}}}


//{{{ instantiation()
Expression instantiation(Token reference):
{
	Token newToken;
	Expression expr;
	Expression arguments;
	Expression namespace;
}
{
	newToken = <NEW>
	try
	{
		(
			expr = fullyQualifiedIdentifier()
		|
			expr = classIdentifier()
		|
			expr = VariableDeclaratorId()
		)

		{
			expr.setType(new Type(Type.OBJECT_INT,expr.toString()));
		}
	}
	catch (ParseException e)
	{
		//{{{ Exception
		Token token = error_skipto(SEMICOLON);
		expr = new DummyExpression(newToken.sourceEnd,
			token.sourceStart,
			newToken.endLine,
			token.beginLine,
			newToken.endColumn,
			token.beginColumn);
		expr.setType(Type.OBJECT);
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"class identifier expected",
			"class identifier",
			newToken.next.image,
			newToken.next.sourceStart,
			token.sourceStart,
			newToken.next.beginLine,
			token.beginLine,
			newToken.next.beginColumn,
			token.beginColumn)); //}}}

	}
	{
		int start, beginLine, beginColumn;
		if (reference == null)
		{
			start       = newToken.sourceStart;
			beginLine   = newToken.beginLine;
			beginColumn = newToken.beginColumn;
		}
		else
		{
			start       = reference.sourceStart;
			beginLine   = reference.beginLine;
			beginColumn = reference.beginColumn;
		}
	}
	[
		{
			ArgumentList args;
		}
		args = arguments()
		{
			expr = new FunctionCall(expr,args);
		}
	]
	{
		expr = new ClassInstantiation(expr,
			reference != null,
			start,
			beginLine,
			beginColumn);
		return expr;
	}
} //}}}

//{{{ cloning()
Expression cloning():
{
	AbstractVariable variable;
}
{
	<CLONE>
	(
		variable = VariableDeclaratorId()
	|
		<LPAREN>
		try
		{
			variable = VariableDeclaratorId()
		}
		catch (ParseException e)
		{
			variable = new Variable(SYNTAX_ERROR_CHAR,
			e.currentToken.sourceStart,e.currentToken.sourceEnd,
					       e.currentToken.beginLine,
					       e.currentToken.endLine,
					       e.currentToken.beginColumn,
					       e.currentToken.endColumn);
			fireParseError("variable expected","variable",e.currentToken.next);
		}
		try
		{
			<RPAREN>
		}
		catch (ParseException e)
		{
			fireParseError(") expected",")",e.currentToken.next);
		}
		
	)
	{
		return variable;
	}
} //}}}

//{{{ ArrayDeclarator()
/**
 * An array declarator.
 * array(vars)
 * @return an array
 */
ArrayInitializer ArrayDeclarator():
{
	ArrayVariableDeclaration[] vars;
	Token arrayToken;
}
{
	arrayToken = <ARRAY> vars = ArrayInitializer()
	{
		return new ArrayInitializer(vars,
			arrayToken.sourceStart,
			token.sourceEnd,
			arrayToken.beginLine,
			token.endLine,
			arrayToken.beginColumn,
			token.endColumn);
	}
} //}}}

//{{{ ClassIdentifier()
/**
 * A ClassIdentifier is anything that could be a class name that can be use in <code>class ClassIdentifier {}</code>
 */
ClassIdentifier classIdentifier():
{
	Token identifierToken;
}
{
	identifierToken = methodIdentifier()
	{
		return new ClassIdentifier(identifierToken);
	}
} //}}}

//{{{ SUFFIXES

//{{{ VariableSuffix()
/**
 * Used by VariableDeclaratorId
 */
AbstractVariable VariableSuffix(Expression prefix):
{
	AbstractVariable abstractVariable;
}
{
	(
		abstractVariable = classAccess(prefix)
	|
		abstractVariable = staticClassAccess(prefix)
	|
		abstractVariable = arrayDeclarator(prefix)
	)
	{
		return abstractVariable;
	}
} //}}}

//{{{ staticClassAccess()
/**
 * staticClassAccess
 * @param expr the expression in the left of the ::
 */
ClassAccess staticClassAccess(Expression expr):
{
	Expression expr2;
	ClassAccess ca;
	Token staticClassAccess;
	Token dollarToken, identifierToken;
}
{
	staticClassAccess = <STATICCLASSACCESS>
	try
	{
		(
			//{{{ field access
			dollarToken = <DOLLAR>
			try {
				identifierToken = <IDENTIFIER>
				{
					expr2 = new ConstantIdentifier(identifierToken);
					ca = new ClassAccess(expr,expr2,STATICCLASSACCESS,expr2.getSourceEnd(),expr2.getEndLine(),expr2.getEndColumn());
				}
			} catch (ParseException e)
			{
				ca = new ClassAccess(expr,
						     null,
						     STATICCLASSACCESS,
						     dollarToken.sourceEnd,
						     dollarToken.endLine,
						     dollarToken.endColumn);
				fireParseError("identifier expected","identifier",e.currentToken);
			} //}}}
		|
			//{{{ method access
			{
				Expression arguments = null;
				Token methodIdentifier;
			}
			try
			{
				methodIdentifier = methodIdentifier()
				{
					expr2 =  new ConstantIdentifier(methodIdentifier);
				}
				[ 
					LOOKAHEAD(<LPAREN>)
					{
						ArgumentList args;
					}
					args = arguments()
					{
						arguments = new FunctionCall(expr2, args); 
					}
				]
				{
					expr2.setType(new Type(Type.OBJECT_INT,expr2.toString()));
					if (arguments == null)
						arguments = expr2;
					ca = new ClassAccess(expr,
							     arguments,
							     STATICCLASSACCESS,
							     arguments.getSourceEnd(),
							     arguments.getEndLine(),
							     arguments.getEndColumn());
				}
			}
			catch (ParseException e)
			{
				ca = new ClassAccess(expr,
						     null,
						     STATICCLASSACCESS,
						     staticClassAccess.sourceEnd,
						     staticClassAccess.endLine,
						     staticClassAccess.endColumn);
				fireParseError("identifier expected","identifier",e.currentToken);
			} //}}}
		)
	}
	catch (ParseException e)
	{
		ca = new ClassAccess(expr,
				     null,
				     STATICCLASSACCESS,
				     staticClassAccess.sourceEnd,
				     staticClassAccess.endLine,
				     staticClassAccess.endColumn);
		fireParseError("field or method expected","identifier",e.currentToken);
	}
	{
		return ca;
	}
} //}}}

//{{{ classAccess()
ClassAccess classAccess(Expression prefix) :
{
	Token lbrace, rbrace, listToken;
	Token classAccess; 
	Expression expression;
}
{
	classAccess = <CLASSACCESS>
	try
	{
		(
			 //{{{ ->{expression}
			 lbrace = <LBRACE> expression = Expression() rbrace = <RBRACE>
			 {
				 expression = new Variable(expression,
							   lbrace.sourceStart,
							   rbrace.sourceEnd,
							   lbrace.beginLine,
							   rbrace.endLine,
							   lbrace.beginColumn,
							   rbrace.endColumn);
				 setTypeFromScope((Variable) expression);
			 }
			 //}}}
		 |
			 //{{{ method access
			{
				Expression arguments = null;
				Token methodIdentifier;
			}
			try
			{
				methodIdentifier = methodIdentifier()
				{
					expression =  new ConstantIdentifier(methodIdentifier);
				}
				[ 
					LOOKAHEAD(<LPAREN>)
					{
						ArgumentList args;
					}
					args = arguments()
					{
						expression = new FunctionCall(expression, args); 
					}
				]
				{
					expression.setType(new Type(Type.OBJECT_INT,prefix.toString()));
				}
			}
			catch (ParseException e)
			{
				expression = new ClassAccess(prefix,
				     null,
				     CLASSACCESS,
				     classAccess.sourceEnd,
				     classAccess.endLine,
				     classAccess.endColumn);
				fireParseError("identifier expected","identifier",e.currentToken);
			} //}}}
		 |
			 listToken = <LIST>
			 {
				 expression = new ConstantIdentifier(listToken);
			 }
		 |
		 	expression = Variable()
		 )
	}
	catch (ParseException e)
	{
		fireParseError("expression expected", "expression", e.currentToken);
		expression = new DummyExpression(e.currentToken);
	}
	{
		return new ClassAccess(prefix,
				       expression,
				       CLASSACCESS,
				       expression.getSourceEnd(),
				       expression.getEndLine(),
				       expression.getEndColumn());
	}
} //}}}

//{{{ arrayDeclarator(Expression prefix)
ArrayDeclarator arrayDeclarator(Expression prefix) :
{
	Token open;
	Token close = null;
	Expression expression = null;
	int sourceEnd,endLine,endColumn;
}
{
	(
		open = <LBRACKET>
	 	[ expression = Expression() ]
	 	try
	 	{
	 		close = <RBRACKET>
	 	}
	 	catch (ParseException e)
	 	{
	 		fireParseError("']' expected", "]", e.currentToken);
	 	}
	|
		open = <LBRACE>
		[ expression = Expression() ]
		try
		{
			close = <RBRACE>
		}
		catch (ParseException e)
		{
			fireParseError("'}' expected", "}", e.currentToken);
		}
	)
	{
		if (close == null)
		{
			if (expression == null)
			{
				sourceEnd = open.sourceEnd;
				endLine   = open.endLine;
				endColumn = open.endColumn;
			}
			else
			{
				sourceEnd = expression.getSourceEnd();
				endLine   = expression.getEndLine();
				endColumn = expression.getEndColumn();
			}
		}
		else
		{
			sourceEnd = open.sourceEnd;
			endLine   = open.endLine;
			endColumn = open.endColumn;
		}
		return new ArrayDeclarator(prefix,
					   expression,
					   sourceEnd,
					   endLine,
					   endColumn);
	}
} //}}}

//}}}

//{{{ LITERAL

//{{{ Literal()
Literal Literal() :
{
	Token token;
	StringLiteral stringLiteral;
}
{
	token = <INTEGER_LITERAL>         {return new NumberLiteral(Type.INTEGER,token);}
	| token = <FLOATING_POINT_LITERAL>  {return new NumberLiteral(Type.INTEGER,token);}
	| token = <STRING_LITERAL>          {return new StringLiteral(token);}
	| token = <TRUE>                    {return new TrueLiteral(token);}
	| token = <FALSE>                   {return new FalseLiteral(token);}
	| token = <NULL>                    {return new NullLiteral(token);}
	| stringLiteral = heredoc()         {return stringLiteral;}
	| stringLiteral = evaluableString() {return stringLiteral;}
} //}}}

//{{{ heredoc()
StringLiteral heredoc():
{
	Token heredocStart;
	Token startToken;
	Token endToken;
	String endImage;
	String startImage;
}
{
	heredocStart = <HEREDOCSTARTTOKEN>
	try
	{
		startToken = <IDENTIFIER>
		{
			startImage = startToken.image;
			if(heredocStart.sourceEnd != startToken.sourceStart)
			{
				//{{{ Parse error
				fireParseError(new PHPParseErrorEvent(ERROR,
					path,
					"unexpected spaces",
					"",
					"",
					heredocStart.sourceEnd+1,
					startToken.sourceStart-1,
					startToken.beginLine,
					startToken.endLine,
					heredocStart.endColumn+1,
					startToken.beginColumn-1)); //}}}
			}
		}
	}
	catch (ParseException e)
	{
		//{{{ Parse error
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"identifier expected",
			"identifier",
			e.currentToken.image,
			errorStart,
			errorEnd,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1)); //}}}
		return new StringLiteral("",
			jj_input_stream.getBeginOffset(),
			jj_input_stream.getBeginOffset()+1,
			jj_input_stream.getBeginLine(),
			jj_input_stream.getEndLine(),
			jj_input_stream.getBeginColumn(),
			jj_input_stream.getEndColumn());
	}
	{
		while (true)
		{
			endToken = getNextToken();
			if (endToken.kind == EOF)
			{
				fireParseError("unexpected EOF","",endToken);
				break;
			}

			if (endToken.beginLine == startToken.beginLine)
			{
				fireParseError("unexpected token","identifier",endToken);
				continue;
			}
			if (endToken.beginColumn != 1) 
				continue;
			endImage = (endToken.image.charAt(endToken.image.length()-1) == ';') ? endToken.image.substring(0,endToken.image.length()-2) : endToken.image;
			if (endImage.equals(startImage))
			{
				break;
			}
		}
		token_source.SwitchTo(PHPPARSING);
		//  return new StringLiteral(jj_input_stream.getCurrentBuffer().substring(startToken.sourceEnd+1,endToken.sourceStart-1),
		return new StringLiteral("",
			startToken.sourceEnd+1,
			endToken.sourceStart-1,
			startToken.beginLine,
			endToken.endLine,
			startToken.beginColumn,
			endToken.endColumn);
	}
} //}}}

//{{{ evaluableString()
StringLiteral evaluableString():
{
	List<Expression> list = new ArrayList<Expression>();
	Token start,end;
	Expression expr;
	Token identifier;
	boolean hasDollar = false;
}
{
	start = <DOUBLEQUOTE>
	(
		identifier = <IDENTIFIER>
		{
			if (hasDollar)
			{
				hasDollar = false;
				expr = new Variable(identifier);
				list.add(expr);
			}	
		}
	|
		<DOLLARBRACE>
		{
			hasDollar = true;
		}
	|
		<DOLLARS>
		{
			hasDollar = true;
		}
	)*
	//{{{ <DOUBLEQUOTE2>
		(
			end = <DOUBLEQUOTE>
		|
			end = <DOUBLEQUOTE2>
		)
		{
			token_source.SwitchTo(PHPPARSING);
			Expression[] expressions = new Expression[list.size()];
			list.toArray(expressions);
			return new StringLiteral("",
						 start.sourceStart,
						 end.sourceEnd,
						 start.beginLine,
						 end.endLine,
						 start.beginColumn,
						 end.endColumn,
						 expressions);
		} //}}}
} //}}}

//}}}

//{{{ arguments()
ArgumentList arguments():
{
	Expression[] args = null;
	Token rparen,lparen;
}
{
	lparen = <LPAREN> [ args = ArgumentList() ]
	try
	{
		rparen = <RPAREN>
		{
			return new ArgumentList(args,
				lparen.sourceStart,
				rparen.sourceEnd,
				lparen.beginLine,
				rparen.endLine,
				lparen.beginColumn,
				rparen.endColumn);
		}
	} 
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"')' expected",
			")",
			e.currentToken.image,
			errorStart,
			errorEnd,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	{
		int sourceEnd, line, column;
		if (args == null || args.length == 0)
		{
			sourceEnd = lparen.sourceEnd+1;
			line = lparen.beginLine;
			column = lparen.beginColumn;
		}
		else
		{
			sourceEnd = args[args.length-1].getSourceEnd();
			line = args[args.length-1].getBeginLine();
			column = args[args.length-1].getBeginColumn();
		}
		
		return new ArgumentList(args,
			lparen.sourceStart,
			sourceEnd,
			lparen.beginLine,
			line,
			lparen.beginColumn,
			column);
	}
} //}}}

//{{{ ArgumentList()
/**
 * An argument list is a list of arguments separated by comma :
 * argumentDeclaration() (, argumentDeclaration)*
 * @return an array of arguments
 */
Expression[] ArgumentList():
{
	Expression arg;
	List<Expression> list = new ArrayList<Expression>();
}
{
	arg = _argument()
	{
		list.add(arg);
	}
	(
		<COMMA>
		try
		{
			arg = _argument()
			{
				list.add(arg);
			}
		}
		catch (ParseException e)
		{
			fireParseError("expression expected", "expression", e.currentToken);
		}
	)*
	{
		Expression[] arguments = new Expression[list.size()];
		list.toArray(arguments);
		return arguments;
	}
} //}}}

//{{{ _argument() method
Expression _argument():
{
	Expression arg;
}
{
	(
		arg = Expression()
	|
		arg = closureDeclaration()
	)
	{
		return arg;
	}
} //}}}


//{{{ StatementNoBreak()
/**
 * A Statement without break.
 * @return a statement
 */
Statement StatementNoBreak() :
{
	Statement statement;
}
{
	(
		LOOKAHEAD(2)
		statement = expressionStatement()
	|
		LOOKAHEAD(2)
		statement = LabeledStatement()
	|
		statement = Block()
	|
		statement = EmptyStatement()
	|
		statement = SwitchStatement()
	|
		statement = IfStatement()
	|
		statement = WhileStatement()
	|
		statement = DoStatement()
	|
		statement = ForStatement()
	|
		statement = ForeachStatement()
	|
		statement = ContinueStatement()
	|
		statement = ReturnStatement()
	|
		statement = EchoStatement()
	|
		statement = StaticStatement()
	|
		statement = GlobalStatement()
	|
		statement = tryStatement()
	|
		statement = throwStatement()
	|
		statement = defineStatement()
		{
			currentSegment.add((Outlineable)statement);
		}
	)
	{
		return statement;
	}
} //}}}

//{{{ TRY

//{{{ throwStatement()
ThrowStatement throwStatement() :
{
	Token throwToken;
	Expression expr;
	Token semicolonToken;
	int sourceEnd,endLine,endColumn;
}
{
	throwToken = <THROW>
	expr = Expression()
	try
	{
		semicolonToken = <SEMICOLON>
		{
			sourceEnd = semicolonToken.sourceEnd;
			endLine   = semicolonToken.endLine;
			endColumn = semicolonToken.endColumn;
		}
	}
	catch (ParseException e)
	{
		sourceEnd = e.currentToken.sourceEnd;
		endLine   = e.currentToken.endLine;
		endColumn = e.currentToken.endColumn;
		fireParseError("catch expected", "catch", e.currentToken);
	}
	{
		return new ThrowStatement(expr,
			throwToken.sourceStart,
			sourceEnd,
			throwToken.beginLine,
			endLine,
			throwToken.beginColumn,
			endColumn);
	}
} //}}}

//{{{ tryStatement()
TryStatement tryStatement() :
{
	Token tryToken;
	Block block;
	Catch catchClause;
	List<Catch> catches = new ArrayList<Catch>(5);
}
{
	tryToken = <TRY>
	block = Block()
	catchClause = catchClause()
	{
		catches.add(catchClause);
	}
	(
		catchClause = catchClause()
		{
			catches.add(catchClause);
		}
	)*
	{
		return new TryStatement(block,
			catches,
			tryToken.sourceStart,
			catchClause.getSourceEnd(),
			tryToken.beginLine,
			catchClause.getEndLine(),
			tryToken.beginColumn,
			catchClause.getEndColumn());
	}
}//}}}

//{{{ catchClause()
Catch catchClause() :
{
	Token catchToken;
	Token catchedException;
	Token dollarToken;
	Token identifierToken;
	Block block;
	int start,beginLine,beginColumn;
	int startVar,beginLineVar,beginColumnVar;
	int endVar,endLineVar,endColumnVar;
	String identifierString = null;
	String catchedString = null;
}
{
	//{{{ <CATCH>
	try
	{
		catchToken = <CATCH>
		{
			start       = catchToken.sourceStart;
			beginLine   = catchToken.beginLine;
			beginColumn = catchToken.beginColumn;
		}
	}
	catch (ParseException e)
	{
		start       = e.currentToken.sourceStart;
		beginLine   = e.currentToken.beginLine;
		beginColumn = e.currentToken.beginColumn;
		fireParseError("catch expected", "catch", e.currentToken);
	} //}}}

	//{{{ <LPAREN>
	try
	{
		<LPAREN>
	}
	catch (ParseException e)
	{
		fireParseError("'(' expected", "(", e.currentToken);
	} //}}}

	//{{{ <NAMESPACE_IDENTIFIER>
	try
	{
		catchedException = <NAMESPACE_IDENTIFIER>
		{
			catchedString = catchedException.image;
		}
	}
	catch (ParseException e)
	{
		fireParseError("identifier expected", "identifier", e.currentToken);
	} //}}}

	//{{{ <DOLLAR>
	try
	{
		dollarToken = <DOLLAR>
		{
			startVar       = dollarToken.sourceStart;
			beginLineVar   = dollarToken.beginLine;
			beginColumnVar = dollarToken.beginColumn;
		}
	} //}}}

	catch (ParseException e)
	{
		startVar       = e.currentToken.sourceStart;
		beginLineVar   = e.currentToken.beginLine;
		beginColumnVar = e.currentToken.beginColumn;
		fireParseError("$ expected", "$", e.currentToken);
	}
	try
	{
		identifierToken = <IDENTIFIER>
		{
			identifierString = identifierToken.image;
			endVar       = identifierToken.sourceStart;
			endLineVar   = identifierToken.beginLine;
			endColumnVar = identifierToken.beginColumn;
		}
	}
	catch (ParseException e)
	{
		endVar       = e.currentToken.sourceEnd;
		endLineVar   = e.currentToken.endLine;
		endColumnVar = e.currentToken.endColumn;
		fireParseError("identifier expected", "identifier", e.currentToken);
	}
	try
	{
		<RPAREN>
	}
	catch (ParseException e)
	{
		fireParseError("')' expected", ")", e.currentToken);
	}
	block = Block()
	{
		return new Catch(catchedString,
			new Variable(identifierString,
				startVar,
				endVar,
				beginLineVar,
				endLineVar,
				beginColumnVar,
				endColumnVar),
			block,
			start,
			block.getSourceEnd(),
			beginLine,
			block.getEndLine(),
			beginColumn,
			block.getEndColumn());
	}
} //}}}

//}}}

//{{{ expressionStatement()
/**
 * A statement expression.
 * expression ;
 * @return an expression
 */
Statement expressionStatement():
{
	Statement statement;
	Token token;
}
{
	try
	{
		statement = Expression()
	}
	catch (ParseException e)
	{
		token = error_skipto(SEMICOLON);
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"expression expected",
			"expression",
			e.currentToken.image,
			e.currentToken.sourceEnd,
			token.sourceEnd,
			e.currentToken.beginLine,
			token.endLine,
			e.currentToken.endColumn,
			token.beginColumn));
		return new EmptyStatement(e.currentToken.sourceStart,
			token.sourceEnd,
			e.currentToken.beginLine,
			token.endLine,
			e.currentToken.beginColumn,
			token.endColumn);
	}
	try
	{
		token = <SEMICOLON>
		{
			statement.setSourceEnd(token.sourceEnd);
		}
	}
	catch (ParseException e)
	{
		if (e.currentToken.next.kind != PHPEND)
		{
			fireParseError("';' expected", ";", e.currentToken);
		}
	}
	{
		return statement;
	}
} //}}}

//{{{ constantStatement()
List<Const> constantStatement():
{
	Token constToken;
	Token identifierToken;
	Expression identifier;
	Expression value = null;
	List<Const> constList = new ArrayList<Const>();
	Const constant;
}
{
	constToken = <CONST>
	constant = _const()
	{
		constList.add(constant);
	}
	(
		<COMMA>
		try
		{
			constant = _const()
			{
				constList.add(constant);
			}
		}
		catch (ParseException e)
		{
			fireParseError("const expected", "const", e.currentToken);
		}
		
	)*
	try
	{
		<SEMICOLON>
	}
	catch (ParseException e)
	{
		error_skipto(SEMICOLON);
		fireParseError("; expected", ";", e.currentToken);
	}
	{
		return constList;
	}
	
} //}}}

//{{{ _const()
Const _const():
{
	Token identifierToken;
	Expression identifier;
	Expression value = null;
}
{
	//{{{ IDENTIFIER
	try
	{
		identifierToken = <IDENTIFIER>
		{
			identifier = new ConstantIdentifier(identifierToken);
		}
	}
	catch (ParseException e)
	{
		identifier = new StringLiteral(SYNTAX_ERROR_CHAR,
			e.currentToken.sourceStart,e.currentToken.sourceEnd,
					       e.currentToken.beginLine,
					       e.currentToken.endLine,
					       e.currentToken.endColumn,
					       e.currentToken.endColumn+1);
	} //}}}
	//{{{ ASSIGN
	try
	{
		<ASSIGN>
	}
	catch (ParseException e)
	{
		error_skipto(ASSIGN);
		fireParseError("= expected", "=", e.currentToken);
	} //}}}
	//{{{ Literal()
	try
	{
		value  = Literal()
	}
	catch (ParseException e)
	{
		fireParseError("value expected", "value", e.currentToken);
		value = new StringLiteral(SYNTAX_ERROR_CHAR,
			e.currentToken.sourceStart,e.currentToken.sourceEnd,
					       e.currentToken.beginLine,
					       e.currentToken.endLine,
					       e.currentToken.endColumn,
					       e.currentToken.endColumn+1);
	} //}}}
	{
		return new Const(currentSegment,
				  identifier,
				  value,
				  identifier.getSourceStart(),
				  value.getSourceEnd(),
				  identifier.getBeginLine(),
				  value.getEndLine(),
				  identifier.getBeginColumn(),
				  value.getEndColumn());
	}
} //}}}


//{{{ defineStatement()
Define defineStatement():
{
	Expression defineName;
	Expression defineValue;
	Token defineToken;
	Token token;
	int pos;
}
{
	defineToken = <DEFINE> {pos = defineToken.sourceEnd+1;}
	try
	{
		token = <LPAREN>
		{pos = token.sourceEnd+1;}
	}
	catch (ParseException e)
	{
		fireParseError("'(' expected", "(", e.currentToken);
	}
	try
	{
		defineName = Expression()
		{
			pos = defineName.getSourceEnd()+1;
		}
	}
	catch (ParseException e)
	{
		fireParseError("expression expected", "expression", e.currentToken);
		defineName = new StringLiteral(SYNTAX_ERROR_CHAR,pos,pos,
					       e.currentToken.beginLine,
					       e.currentToken.endLine,
					       e.currentToken.endColumn,
					       e.currentToken.endColumn+1);
	}
	try
	{
		<COMMA>
		{
			pos = defineName.getSourceEnd()+1;
		}
	}
	catch (ParseException e)
	{
		fireParseError("',' expected", ",",e.currentToken);
	}
	try
	{
		defineValue = Expression()
		{
			pos = defineValue.getSourceEnd()+1;
		}
	}
	catch (ParseException e)
	{
		fireParseError("expression expected", "expression", e.currentToken);
		defineValue = new StringLiteral(SYNTAX_ERROR_CHAR,pos,pos,
						e.currentToken.beginLine,
						e.currentToken.endLine,
						e.currentToken.endColumn,
						e.currentToken.endColumn+1);
	}
	try
	{
		token = <RPAREN>
		{pos = token.sourceEnd+1;}
	}
	catch (ParseException e)
	{
		fireParseError("')' expected", ")", e.currentToken);
	}
	{
		return new Define(currentSegment,
				  defineName,
				  defineValue,
				  defineToken.sourceStart,
				  pos,
				  defineToken.beginLine,
				  defineToken.endLine,
				  defineToken.beginColumn,
				  defineToken.endColumn);
	}
}//}}}

//{{{ Statement() method
/**
 * A Normal statement.
 */
Statement Statement():
{
	Statement statement;
}
{
	(
		statement = StatementNoBreak()
	|
		statement = BreakStatement()
	)
	{
		if (statement != null)
		{
			statement.getModifiedVariable(tempList);
			scope.addVariablesList(tempList);
			tempList.clear();
		}
		return statement;
	}
} //}}}


//{{{ htmlBlock()
/**
 * An html block inside a php syntax.
 */
HTMLBlock htmlBlock():
{
	int startIndex = nodePtr;
	AstNode[] blockNodes;
	int nbNodes;
	Token phpEnd;
}
{
	phpEnd = <PHPEND>
	{
		htmlStart       = phpEnd.sourceEnd;
		htmlLineStart   = phpEnd.endLine;
		htmlColumnStart = phpEnd.endColumn;
	}
	(phpEchoBlock())*
	try
	{
		(
			<PHPSTARTLONG>
		|
			<PHPSTARTSHORT>
		)
		{
			createNewHTMLCode();
		}
	}
	catch (ParseException e)
	{
		fireParseError("'<?php' expected","<?php",e.currentToken);
	}
	{
		nbNodes = nodePtr - startIndex;
		if (nbNodes == 0)
		{
			return null;
		}
		blockNodes = new AstNode[nbNodes];
		System.arraycopy(nodes,startIndex+1,blockNodes,0,nbNodes);
		nodePtr = startIndex;
		HTMLBlock block = new HTMLBlock(blockNodes);
		return block;
	}
} //}}}

//{{{ IncludeExpression()
/**
 * An include statement. It's "include" an expression;
 */
InclusionExpression IncludeExpression() :
{
	Expression expr;
	InclusionExpression inclusionExpression;
	Token token;
	int end,line,column;
}
{
	(
		token = <REQUIRE>
	|
		token = <REQUIRE_ONCE>
	|
		token = <INCLUDE>
	|
		token = <INCLUDE_ONCE>
	)
	{
		end = token.sourceEnd;
		line = token.beginLine;
		column = token.beginColumn;
	}
	try
	{
		(
			expr = PrimaryExpression()
		|
			expr = Literal()
		|
			<LPAREN> expr = Expression()
		try
		{
			<RPAREN>
		}
		catch (ParseException e)
		{
			//{{{ Parse Error
			fireParseError(new PHPParseErrorEvent(ERROR,
							      path,
							      "')'n expected",
							      ")",
							      e.currentToken.image,
							      expr.getSourceEnd(),
							      expr.getSourceEnd()+1,
							      e.currentToken.beginLine,
							      e.currentToken.endLine,
							      e.currentToken.endColumn,
							      e.currentToken.endColumn+1)); //}}}
		}
		)

		{
			end    = expr.getSourceEnd();
			line   = expr.getBeginLine();
			column = expr.getBeginColumn();
		}
	}
	catch (ParseException e)
	{
		if (errorMessage != null)
			throw e;

		expr = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
					      token.sourceEnd,
					      token.sourceEnd+1,
					      token.endLine,
					      token.endLine,
					      token.endColumn,
					      token.endColumn+1);
		//{{{ Parse Error
		fireParseError(new PHPParseErrorEvent(ERROR,
						      path,
						      "expression expected",
						      "expression",
						      e.currentToken.image,
						      e.currentToken.next.sourceStart,
						      e.currentToken.next.sourceEnd,
						      e.currentToken.beginLine,
						      e.currentToken.endLine,
						      e.currentToken.endColumn,
						      e.currentToken.endColumn+1)); //}}}
	}
	{
		inclusionExpression = new InclusionExpression(currentSegment,
							      token.kind,
							      expr,
							      token.sourceStart,
							      end,
							      token.beginLine,
							      line,
							      token.beginColumn,
							      column);
		currentSegment.add(inclusionExpression);
		return inclusionExpression;
	}
} //}}}

//{{{ PrintExpression()
PrintExpression PrintExpression():
{
	Expression expr;
	Token printToken;
}
{
	printToken = <PRINT> expr = Expression()
	{
		return new PrintExpression(expr,printToken.sourceStart,
			expr.getSourceEnd(),printToken.beginLine,
			expr.getEndLine(),printToken.beginColumn,
			expr.getEndColumn());
	}
} //}}}

//{{{ ListExpression()
ListExpression ListExpression():
{
	AbstractVariable expr = null;
	List<AbstractVariable> list = new ArrayList<AbstractVariable>();
	int pos,line,column;
	Token listToken, rParen;
	Token token;
}
{
	listToken = <LIST> {pos = listToken.sourceEnd;line=listToken.beginLine;column=listToken.beginColumn;}
	try
	{
		token = <LPAREN>
		{
			pos = token.sourceEnd;
			line = token.beginLine;
			column = token.beginColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"'(' expected",
			"(",
			e.currentToken.image,
			listToken.sourceEnd,
			listToken.sourceEnd+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	[
		expr = VariableDeclaratorId()
		{
			list.add(expr);
			pos = expr.getSourceEnd();
			line = expr.getBeginLine();
			column = expr.getBeginColumn();
		}
	]
	{
		if (expr == null)
			list.add(null);
	}
	(
		try
		{
			token = <COMMA>
			{
				pos = token.sourceEnd;
				line=token.beginLine;
				column=token.beginColumn;
			}
		}
		catch (ParseException e)
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"',' expected",
				",",
				e.currentToken.image,
				pos,
				pos+1,
				e.currentToken.beginLine,
				e.currentToken.endLine,
				e.currentToken.endColumn,
				e.currentToken.endColumn+1));
		}
		[
			expr = VariableDeclaratorId()
			{
				list.add(expr);
				pos = expr.getSourceEnd();
				line = expr.getBeginLine();
				column = expr.getBeginColumn();
			}
		]
	)*
	try
	{
		rParen = <RPAREN>
		{
			pos = rParen.sourceEnd;
			line = rParen.beginLine;
			column = rParen.beginColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"')' expected",
			")",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	{
		AbstractVariable[] vars = new AbstractVariable[list.size()];
		list.toArray(vars);
		return new ListExpression(vars,
			listToken.sourceStart,
			pos,
			listToken.beginLine,
			line,
			listToken.beginColumn,
			column);
	}
} //}}}

//}}}

//{{{ STATEMENTS

//{{{ EchoStatement()
/**
 * An echo statement.
 * echo anyexpression (, otherexpression)*
 */
EchoStatement EchoStatement() :
{
	List<Expression> expressions = new ArrayList<Expression>();
	Expression expr;
	Token echoToken;
	Token semicolonToken = null;
}
{
	echoToken = <ECHO>

	//{{{ expression
	expr = Expression()
	{
		if (expr != null)
			expressions.add(expr);
	}
	//}}}

	//{{{ [,expression]*
	(
		<COMMA> expr = Expression()
		{
			if (expr != null)
				expressions.add(expr);
		}
	)*
	//}}}

	//{{{ ;
	try
	{
		semicolonToken = <SEMICOLON>
	}
	catch (ParseException e)
	{
		if (e.currentToken.next.kind != 4)
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"';' expected",
				";",
				e.currentToken.image,
				e.currentToken.sourceEnd,
				e.currentToken.sourceEnd,
				e.currentToken.beginLine,
				e.currentToken.endLine,
				e.currentToken.endColumn,
				e.currentToken.endColumn));
		}
	} //}}}

	//{{{ returning the echo expression
	{
		Expression[] exprs = new Expression[expressions.size()];
		expressions.toArray(exprs);

		//{{{ missing ;
		if (semicolonToken == null)
		{
			
			int end,endLine,endColumn;
			if (exprs.length != 0)
			{
				Expression lastExpression = exprs[exprs.length-1];
				end = lastExpression.getSourceEnd();
				endLine = lastExpression.getEndLine();
				endColumn = lastExpression.getEndColumn();
			}
			else
			{
				end = echoToken.sourceEnd;
				endLine = echoToken.endLine;
				endColumn = echoToken.endColumn;
			}
			return new EchoStatement(exprs,
				echoToken.sourceStart,
				end,
				echoToken.beginLine,
				endLine,
				echoToken.beginColumn,
				endColumn);
		} //}}}

		return new EchoStatement(exprs,
			echoToken.sourceStart,
			semicolonToken.sourceEnd,
			echoToken.beginLine,
			semicolonToken.endLine,
			echoToken.beginColumn,
			semicolonToken.endColumn);
	} //}}}

} //}}}

//{{{ GlobalStatement()
GlobalStatement GlobalStatement():
{
	Variable expr;
	List<Variable> vars = new ArrayList<Variable>();
	GlobalStatement global;
	Token globalToken;
	Token semicolonToken;
	int pos,line,column;
}
{
	globalToken = <GLOBAL>
	expr = Variable()
	{
		vars.add(expr);
		pos = expr.getSourceEnd()+1;
		line = expr.getEndLine();
		column = expr.getEndColumn();
	}
	(
		<COMMA>
		expr = Variable()
		{
			vars.add(expr);
			pos = expr.getSourceEnd()+1;
			line=expr.getEndLine();
			column=expr.getEndColumn();
		}
	)*
	try
	{
		semicolonToken = <SEMICOLON>
		{
			pos = semicolonToken.sourceEnd+1;
			line = semicolonToken.endLine;
			column = semicolonToken.endColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError("';' expected", ";", e.currentToken);
	}
	{
		Variable[] variables = new Variable[vars.size()];
		vars.toArray(variables);
		global = new GlobalStatement(currentSegment,
			variables,
			globalToken.sourceStart,
			pos,
			globalToken.beginLine,
			line,
			globalToken.beginColumn,
			column);
		currentSegment.add(global);
		//global.analyzeCode(this);
		return global;
	}
} //}}}

//{{{ StaticStatement()
StaticStatement StaticStatement():
{
	List<VariableDeclaration> vars = new ArrayList<VariableDeclaration>();
	VariableDeclaration expr;
	Token token, token2;
	int pos,line,column;
}
{
	token = <STATIC> expr = VariableDeclarator() 
	{
		vars.add(expr);
		pos = expr.getSourceEnd()+1;
		line=expr.getEndLine();
		column=expr.getEndColumn();
	}
	(
		<COMMA> expr = VariableDeclarator() 
		{
			vars.add(expr);
			pos = expr.getSourceEnd()+1;
			line=expr.getEndLine();
			column=expr.getEndColumn();
		}
	)*
	try
	{
		token2 = <SEMICOLON>
		{pos = token2.sourceEnd+1;line=token2.endLine;column=token2.endColumn;}
	} 
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"';' expected",
			";",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	{
		VariableDeclaration[] variables = new VariableDeclaration[vars.size()];
		vars.toArray(variables);
		return new StaticStatement(variables,
			token.sourceStart,
			pos,
			token.beginLine,
			line,
			token.beginColumn,
			column);
	}
} //}}}

//{{{ LabeledStatement()

LabeledStatement LabeledStatement() :
{
	Token label;
	Statement statement = null;
}
{
	label = <IDENTIFIER>
	try
	{
		<COLON>
	}
	catch (ParseException e)
	{
		fireParseError("':' expected", ":",e.currentToken);
	}
	try
	{
		statement = Statement()
	}
	catch (ParseException e)
	{
		fireParseError("statement expected", "statement",e.currentToken);
		return new LabeledStatement(label.image,
					    statement,
					    label.sourceStart,
					    e.currentToken.sourceEnd,
					    e.currentToken.beginLine,
					    label.beginLine,
					    e.currentToken.beginColumn,
					    label.endColumn);
	}
	{
		return new LabeledStatement(label.image,
					    statement,
					    label.sourceStart,
					    statement.getSourceEnd(),
					    label.beginLine,
					    statement.getEndLine(),
					    label.beginColumn,
					    statement.getEndColumn());
	}
}

//}}}

//{{{ Block()
/**
 * A Block is
 * {
 * statements
 * }.
 * @return a block
 */
Block Block():
{
	List<Statement> list = new ArrayList<Statement>();
	Statement statement;
	Token lbrace;
	Token rbrace;
	int pos,endLine,endColumn;
	int start, beginLine, beginColumn;
}
{
	//{{{ <LBRACE>
	try
	{
		lbrace = <LBRACE>
		{
			pos         = lbrace.sourceEnd+1;
			start       = lbrace.sourceStart;
			beginLine   = lbrace.beginLine;
			beginColumn = lbrace.beginColumn;
			endLine     = lbrace.endLine;
			endColumn   = lbrace.endColumn;
		}
	}
	catch (ParseException e)
	{
		pos         = token.sourceEnd+1;
		start       = pos;
		beginLine   = token.endLine;
		beginColumn = token.endColumn;
		endLine     = token.endLine;
		endColumn   = token.endColumn;
		fireParseError("'{' expected","{",e.currentToken);
	} //}}}

	(
	//{{{ BlockStatement()
	statement = BlockStatement()
	{
		if (statement != null)
		{
			list.add(statement);
			pos         = statement.getSourceEnd()+1;
			endLine     = statement.getEndLine();
			endColumn   = statement.getEndColumn();
		}
	} //}}}
	|
	//{{{ htmlBlock()
	statement = htmlBlock()
	{
		if (statement != null)
		{
			list.add(statement);
			pos       = statement.getSourceEnd()+1;
			endLine   = statement.getEndLine();
			endColumn = statement.getEndColumn();
		}
		else
		{
			pos       = token.sourceEnd+1;
			endLine   = token.endLine;
			endColumn = token.endColumn;
		}
	} //}}}

	)*
	try
	{
		rbrace = <RBRACE>
		{
			pos       = rbrace.sourceEnd+1;
			endLine   = rbrace.endLine;
			endColumn = rbrace.endColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError("'}' expected", "}", e.currentToken);
	}
	{
		Statement[] statements = new Statement[list.size()];
		list.toArray(statements);
		return new Block(statements,
				 start,
				 pos,
				 beginLine,
				 endLine,
				 beginColumn,
				 endColumn);
	}
} //}}}

//{{{ BlockStatement()
Statement BlockStatement() :
{
	Statement statement = null;
}
{
(
	try
	{
		statement = Statement()
		{
			if (phpDocument == currentSegment)
				pushOnAstNodes(statement);
		}
	}
	catch (ParseException e)
	{
		Token semicolumn = error_skipto(SEMICOLON);
		Token nextToken = e.currentToken.next;
		if (nextToken == semicolumn)
		{
			//{{{ Parse Error
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"statement expected",
				"statement",
				nextToken.image,
				nextToken.sourceEnd,
				semicolumn.sourceStart,
				nextToken.endLine,
				semicolumn.beginLine,
				nextToken.endColumn,
				semicolumn.beginColumn)); //}}}
		}
		else
		{
			fireParseError("statement expected","statement",nextToken);
		}
	}
	|
	statement = classDeclaration()
	|
	statement = interfaceDeclaration()
	|
	statement = methodDeclaration(CONST_FUNCTION,null)
	{
		if (phpDocument == currentSegment) pushOnAstNodes(statement);
		currentSegment.add((MethodDeclaration) statement);
		//((MethodDeclaration) statement).analyzeCode(this);
	}
)
{
	return statement;
}
} //}}}

//{{{ BlockStatementNoBreak()
/**
 * A Block statement that will not contain any 'break'
 */
Statement BlockStatementNoBreak():
{
	Statement statement;
}
{
	(
		statement = StatementNoBreak()
	|
		LOOKAHEAD(1)
		statement = classDeclaration()
	|
		statement = methodDeclaration(CONST_FUNCTION,null)
		{
			currentSegment.add((MethodDeclaration) statement);
			//((MethodDeclaration) statement).analyzeCode(this);
		}
	)
	{
		return statement;
	}
} //}}}

//{{{ LocalVariableDeclaration()
/**
 * used only by ForInit()
 */
Expression[] LocalVariableDeclaration() :
{
	List<Expression> list = new ArrayList<Expression>();
	Expression var;
}
{
	var = Expression()
	{
		list.add(var);
	}
	( 
		<COMMA> var = Expression() {list.add(var);}
	)*
	{
		Expression[] vars = new Expression[list.size()];
		list.toArray(vars);
		return vars;
	}
} //}}}

//{{{ EmptyStatement()
/**
 * An empty statement.
 * It will generate an INFO marker
 *
 * @return an empty statement
 */
EmptyStatement EmptyStatement() :
{
	Token token;
}
{
	token = <SEMICOLON>
	{
		/*    fireParseMessage(new PHPParseMessageEvent(INFO,
		path,
		"unneeded ';'",
		token.sourceStart,
		token.sourceEnd,
		token.beginLine,
		token.endLine,
		token.endColumn,
		token.endColumn+1));   */
		return new EmptyStatement(token.sourceStart,
			token.sourceEnd,
			token.beginLine,
			token.endLine,
			token.beginColumn,
			token.endColumn);
	}
} //}}}

//}}}

//{{{ SWITCH
//{{{ SwitchStatement()
SwitchStatement SwitchStatement():
{
	Expression variable;
	AbstractCase[] cases;
	Token switchToken,lparenToken,rparenToken;
	int pos;
}
{
	switchToken = <SWITCH> {pos = switchToken.sourceEnd+1;}
	try 
	{
		lparenToken = <LPAREN>
		{
			pos = lparenToken.sourceEnd+1;
		}
	}
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"'(' expected",
			"(",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	try 
	{
		variable = Expression()
		{
			pos = variable.getSourceEnd()+1;
		}
	} 
	catch (ParseException e)
	{
		if (errorMessage != null) 
			throw e;
		
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"expression expected",
			"expression",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
		variable = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
			pos,
			pos,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1);
	}
	try
	{
		rparenToken = <RPAREN> {pos = rparenToken.sourceEnd+1;}
	}
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"')' expected",
			")",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	(
		cases = switchStatementBrace()
	|
		cases = switchStatementColon(switchToken.sourceStart, switchToken.sourceEnd)
	)
	{
		return new SwitchStatement(variable,
			cases,
			switchToken.sourceStart,
			token.sourceEnd,
			switchToken.beginLine,
			token.endLine,
			switchToken.beginColumn,
			token.endColumn);
	}
} //}}}

//{{{ switchStatementBrace()
AbstractCase[] switchStatementBrace():
{
	AbstractCase cas;
	List<AbstractCase> cases = new ArrayList<AbstractCase>();
	Token token;
	int pos;
}
{
	token = <LBRACE>
	{
		pos = token.sourceEnd;
	}
	( 
		cas = switchLabel0()
		{
			cases.add(cas);
			pos = cas.getSourceEnd();
		}
	)*
	try 
	{
		token = <RBRACE>
		{pos = token.sourceEnd;}
	}
	catch (ParseException e) 
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"'}' expected",
			"}",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	{
		AbstractCase[] abcase = new AbstractCase[cases.size()];
		cases.toArray(abcase);
		return abcase;
	}
} //}}}

//{{{ switchStatementColon(int start, int end)
/**
 * A Switch statement with : ... endswitch;
 * @param start the begin offset of the switch
 * @param end the end offset of the switch
 */
AbstractCase[] switchStatementColon(int start, int end) :
{
	AbstractCase cas;
	List<AbstractCase> cases = new ArrayList<AbstractCase>();
	Token token;                                 
	int pos;
}
{
	token = <COLON> {pos = token.sourceEnd;}
	{
		fireParseMessage(new PHPParseMessageEvent(INFO,
			PHPParseMessageEvent.MESSAGE_SWITCH_ENDSWITCH_TAG,
			path,
			"Ugly syntax detected, you should switch () {...} instead of switch (): ... enswitch;",
			start,
			end,
			token.beginLine,
			token.endLine,
			token.beginColumn,
			token.endColumn));
	}
	(
		cas = switchLabel0()
		{
			cases.add(cas);
			pos = cas.getSourceEnd();
		}
	)*
	try
	{
		token = <ENDSWITCH> {pos = token.sourceEnd;}
	}
	catch (ParseException e) 
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"'endswitch' expected",
			"endswitch",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	try 
	{
		token = <SEMICOLON> {pos = token.sourceEnd;}
	}
	catch (ParseException e) 
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"';' expected",
			";",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	{
		AbstractCase[] abcase = new AbstractCase[cases.size()];
		cases.toArray(abcase);
		return abcase;
	}
} //}}}

//{{{ switchLabel0()
AbstractCase switchLabel0():
{
	Expression expr;
	Statement statement;
	List<Statement> stmts = new ArrayList<Statement>();
	int start = token.next.sourceStart;
}
{
	expr = SwitchLabel()
	( 
		statement = BlockStatementNoBreak() {stmts.add(statement);}
	|
		statement = htmlBlock()             {if (statement != null) {stmts.add(statement);}}
	| 
		statement = BreakStatement()        {stmts.add(statement);}
	)*
	//[ statement = BreakStatement()        {stmts.add(statement);}]
	{
		int listSize = stmts.size();
		Statement[] stmtsArray = new Statement[listSize];
		stmts.toArray(stmtsArray);
		if (expr == null)
		{//it's a default
			int end = this.token.next.sourceStart;
			return new DefaultCase(stmtsArray,
				start,
				end,
				this.token.next.beginLine,
				this.token.next.endLine,
				this.token.next.beginColumn,
				this.token.next.endColumn);
		}
		if (listSize == 0) 
		{
			return new Case(expr,
				stmtsArray,
				expr.getSourceStart(),
				expr.getSourceEnd(),
				expr.getBeginLine(),
				expr.getEndLine(),
				expr.getBeginColumn(),
				expr.getEndColumn());
		}
		else 
		{
			return new Case(expr,
				stmtsArray,
				expr.getSourceStart(),
				stmtsArray[listSize-1].getSourceEnd(),
				expr.getBeginLine(),
				stmtsArray[listSize-1].getEndLine(),
				expr.getBeginColumn(),
				stmtsArray[listSize-1].getEndColumn());
		}
	}
} //}}}

//{{{ SwitchLabel()
/**
 * A SwitchLabel.
 * case Expression() :
 * default :
 * @return the if it was a case and null if not
 */
Expression SwitchLabel():
{
	Expression expr;
	Token token;
}
{
	token = <CASE>
	try 
	{
		expr = Expression()
	} 
	catch (ParseException e)
	{
		//todo ameliorer ca
		if (errorMessage != null) throw e;
		errorMessage = "expression expected after 'case' keyword";
		errorStart = token.sourceEnd;
		errorEnd   = token.sourceEnd +1;
		throw e;
	}
	try 
	{
		(
			<COLON>
		| 
			token = <SEMICOLON>
			{
				fireParseMessage(new PHPParseMessageEvent(INFO,
					PHPParseMessageEvent.MESSAGE_CASE_SEMICOLON,
					path,
					"a ; was found in a case statement. You should use :",
					token));
			}
		)
	} 
	catch (ParseException e) 
	{
		//{{{ fireParseError
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"':' expected",
			":",
			e.currentToken.image,
			expr.getSourceEnd(),
			expr.getSourceEnd()+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1)); //}}}
	}
	{
		return expr;
	}
|
	token = <_DEFAULT>
	try 
	{
		<COLON>
	} 
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"':' expected",
			":",
			e.currentToken.image,
			token.sourceEnd,
			token.sourceEnd+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	{
		return null;
	}
} //}}}

//}}}

//{{{ BreakStatement() method
Break BreakStatement():
{
	Expression expression = null;
	Token token, token2;
	int pos;
}
{
	token = <BREAK> {pos = token.sourceEnd+1;}
	[ 
		expression = Expression()
		{
			pos = expression.getSourceEnd()+1;
		}
	]
	try
	{
		token2 = <SEMICOLON>
		{pos = token2.sourceEnd;}
	} 
	catch (ParseException e) 
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"';' expected",
			";",
			e.currentToken.image,
			pos,
			pos+1,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn+1));
	}
	{
		return new Break(expression, token.sourceStart, pos,
			token.beginLine,token.endLine,token.beginColumn,
			token.endColumn);
	}
}

//}}}
//{{{ Condition(String keyword)

Expression Condition(String keyword) :
{
  Expression condition;
}
{
  try {
    <LPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          token.sourceEnd,
                                          token.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  condition = Expression()
  try {
     <RPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          condition.getSourceEnd(),
                                          condition.getSourceEnd()+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return condition;}
}

//}}}

//{{{ IF
//{{{ IfStatement()

IfStatement IfStatement() :
{
  Expression condition;
  IfStatement ifStatement;
  Token ifToken;
}
{
  ifToken = <IF> condition = Condition("if")
  ifStatement = ifStatementAction(condition,ifToken)
  {
    return ifStatement;
  }
}

//}}}

//{{{ statementList()
List<Statement> statementList():
{
	List<Statement> list = new ArrayList<Statement>();
	Statement statement;
}
{
	(
		statement = Statement()
		{
			list.add(statement);
		}
	|
		statement = htmlBlock()
		{
			if (statement != null) 
				list.add(statement);
		}
	)*
	{
		return list;
	}
} //}}}


//{{{ ifStatementAction(Expression condition, Token ifToken)
IfStatement ifStatementAction(Expression condition, Token ifToken) :
{
	Statement statement;
	Statement stmt;
	Statement[] statementsArray;
	ElseIf elseifStatement;
	Else elseStatement = null;
	List<Statement> stmts;
	List<ElseIf> elseIfList = new ArrayList<ElseIf>();
	ElseIf[] elseIfs;
	Token colonToken, elseToken;
	int sourceEnd = 0;
	int endColumn = 0;
	int endLine   = 0;
	Token semiColonToken;
}
{
	colonToken = <COLON>
	stmts = statementList()
	(
		elseifStatement = ElseIfStatementColon() 
		{
			elseIfList.add(elseifStatement);
		}
	)*
	[ elseStatement = elseStatementColon() ]
	
	{
		fireParseMessage(new PHPParseMessageEvent(INFO,
			PHPParseMessageEvent.MESSAGE_IF_ENDIF_TAG,
			path,
			"Ugly syntax detected, you should if () {...} instead of if (): ... endif;",
			colonToken));
	}
	try
	{
		<ENDIF>
	}
	catch (ParseException e)
	{
		errorMessage = "'endif' expected";
		errorStart = e.currentToken.sourceStart;
		errorEnd   = e.currentToken.sourceEnd;
		throw e;
	}
	try
	{
		semiColonToken = <SEMICOLON>
		{
			sourceEnd = semiColonToken.sourceStart;
			endLine   = semiColonToken.beginLine;
			endColumn = semiColonToken.beginColumn;
		}
	} 
	catch (ParseException e)
	{
		errorMessage = "';' expected after 'endif' keyword";
		errorStart = e.currentToken.sourceStart;
		errorEnd   = e.currentToken.sourceEnd;
		throw e;
	}
	{
		elseIfs = new ElseIf[elseIfList.size()];
		elseIfList.toArray(elseIfs);
		if (stmts.size() == 1)
		{
			return new IfStatement(condition,
				stmts.get(0),
				elseIfs,
					elseStatement,
					ifToken.sourceStart,
				sourceEnd,
				ifToken.beginLine,
				endLine,
				ifToken.beginColumn,
				endColumn);
		}
		else 
		{
			statementsArray = new Statement[stmts.size()];
			stmts.toArray(statementsArray);
			return new IfStatement(condition,
				new Block(statementsArray,
					colonToken.sourceEnd,
					sourceEnd,
					colonToken.endLine,
					endLine,
					colonToken.endColumn,
					endColumn),
				elseIfs,
					elseStatement,
					ifToken.sourceStart,
				sourceEnd,
				ifToken.beginLine,
				endLine,
				ifToken.beginColumn,
				endColumn);
		}
	}
	
	|
	(stmt = Statement() | stmt = htmlBlock())
	( LOOKAHEAD(1) elseifStatement = ElseIfStatement() {elseIfList.add(elseifStatement);})*
	[ LOOKAHEAD(1)
	elseToken = <ELSE>
	try
{
		statement = Statement()
		{elseStatement = new Else(statement,
                                elseToken.sourceStart,
                                	statement.getSourceEnd(),
                                elseToken.beginLine,
                                	statement.getEndLine(),
                                elseToken.beginColumn,
                statement.getEndColumn());}
        } 
        catch (ParseException e)
        {
        	if (errorMessage != null)
        	{
        		throw e;
        	}
        	errorMessage = "unexpected token '"+e.currentToken.next.image+"', a statement was expected";
        	errorStart = e.currentToken.sourceStart;
        	errorEnd   = e.currentToken.sourceEnd;
        	throw e;
        }
        ]
        {
        	elseIfs = new ElseIf[elseIfList.size()];
        	elseIfList.toArray(elseIfs);
        	return new IfStatement(condition,
        		stmt,
        		elseIfs,
        			elseStatement,
        			ifToken.sourceStart,
        		sourceEnd,
        		ifToken.beginLine,
        		endLine,
        		ifToken.beginColumn,
        		endColumn);
        }
} //}}}

//{{{ ElseIfStatementColon()
ElseIf ElseIfStatementColon():
{
	Expression condition;
	List<Statement> list;
	Token elseifToken;
}
{
	elseifToken = <ELSEIF> condition = Condition("elseif")
		<COLON>
	list = statementList()
	{
		int sizeList = list.size();
		Statement[] stmtsArray = new Statement[sizeList];
		list.toArray(stmtsArray);
		return new ElseIf(condition,stmtsArray ,
			elseifToken.sourceStart,
				stmtsArray[sizeList-1].getSourceEnd(),
			elseifToken.beginLine,
				stmtsArray[sizeList-1].getEndLine(),
			elseifToken.beginColumn,
	stmtsArray[sizeList-1].getEndColumn());}
} //}}}

//{{{ elseStatementColon()
Else elseStatementColon():
{
	List<Statement> list;
	Token elseToken;
	Token colonToken;
}
{
	elseToken = <ELSE> colonToken = <COLON>
	list = statementList()
	{
		int sizeList = list.size();
		Statement[] stmtsArray = new Statement[sizeList];
		if (sizeList == 0)
		{
			return new Else(stmtsArray,
					elseToken.sourceStart,
					colonToken.sourceEnd,
					elseToken.beginLine,
					colonToken.endLine,
					elseToken.beginColumn,
					colonToken.endColumn);
		}
		
		list.toArray(stmtsArray);
		return new Else(stmtsArray,
			elseToken.sourceStart,
				stmtsArray[sizeList-1].getSourceEnd(),
			elseToken.beginLine,
				stmtsArray[sizeList-1].getEndLine(),
			elseToken.beginColumn,
				stmtsArray[sizeList-1].getEndColumn());
	}
} //}}}

//{{{ ElseIfStatement()
ElseIf ElseIfStatement():
{
	Expression condition;
	Token elseifToken;
	Statement[] statement = new Statement[1];
}
{
	elseifToken = <ELSEIF> condition = Condition("elseif") statement[0] = Statement()
	{
		return new ElseIf(condition,
			statement,
			elseifToken.sourceStart,
				statement[0].getSourceEnd(),
			elseifToken.beginLine,
				statement[0].getEndLine(),
			elseifToken.beginColumn,
				statement[0].getEndColumn());
	}
} //}}}

//}}}

//{{{ WHILE
//{{{ WhileStatement()

WhileStatement WhileStatement() :
{
  Expression condition;
  Statement action;
  Token whileToken;
}
{
  whileToken = <WHILE>
    condition = Condition("while")
    action    = WhileStatementAction(whileToken)
    {
      return new WhileStatement(condition,
                               action,
                               whileToken.sourceStart,
                               action.getSourceEnd(),
                               whileToken.beginLine,
                               action.getEndLine(),
                               whileToken.beginColumn,
                               action.getEndColumn());
    }
} //}}}

//{{{ WhileStatementAction(Token whileToken)
Statement WhileStatementAction(Token whileToken):
{
	Statement statement;
	List<Statement> stmts;
	Token colonToken;
	int end;
	int endLine;
	int endColumn;
	Token semicolonToken;
}
{
	colonToken = <COLON>
	stmts = statementList()
	{
		fireParseMessage(new PHPParseMessageEvent(INFO,
			PHPParseMessageEvent.MESSAGE_WHILE_ENDWHILE_TAG,
			path,
			"Ugly syntax detected, you should while () {...} instead of while (): ... endwhile;",
			colonToken));
	}
	try
	{
		<ENDWHILE>
	}
	catch (ParseException e)
	{
		errorMessage = "'endwhile' expected";
		errorStart = e.currentToken.sourceStart;
		errorEnd   = e.currentToken.sourceEnd;
		throw e;
	}
	try
	{
		semicolonToken = <SEMICOLON>
		{
			end       = semicolonToken.sourceEnd;
			endLine   = semicolonToken.beginLine;
			endColumn = semicolonToken.beginColumn;
			Statement[] stmtsArray = new Statement[stmts.size()];
			stmts.toArray(stmtsArray);
			return new Block(stmtsArray,
				whileToken.sourceStart,
				end,
				whileToken.beginLine,
				endLine,
				whileToken.beginColumn,
				endColumn);
		}
	}
	catch (ParseException e)
	{
		errorMessage = "';' expected after 'endwhile' keyword";
		errorStart = e.currentToken.sourceStart;
		errorEnd   = e.currentToken.sourceEnd;
		throw e;
	}
	|
	statement = Statement()
	{
		return statement;
	}
} //}}}

//}}}

//{{{ DoStatement()
DoStatement DoStatement() :
{
  Statement action;
  Expression condition;
  Token token;
  Token token2 = null;
}
{
  token = <DO> action = Statement() <WHILE> condition = Condition("while")
  try {
    token2 = <SEMICOLON>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          condition.getSourceEnd(),
                                          condition.getSourceEnd()+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    if (token2 == null) {
      return new DoStatement(condition,
                             action,
                             token.sourceStart,
                             condition.getSourceEnd(),
                             token.beginLine,
                             condition.getEndLine(),
                             token.beginColumn,
                             condition.getEndColumn());
    }
    return new DoStatement(condition,
                           action,
                           token.sourceStart,
                           token2.sourceEnd,
                           token.beginLine,
                           token2.endLine,
                           token.beginColumn,
                           token2.endColumn);
  }
} //}}}

//{{{ ForeachStatement()
ForeachStatement ForeachStatement():
{
	Statement statement = null;
	Expression expression = null;
	ArrayVariableDeclaration variable = null;
	Token foreachToken;
	Token lparenToken;
	Token asToken;
	Token rparenToken;
	int pos,endLine,endColumn;
	Token tokenEndForeach, tokenColon, tokenSemicolon;
	List<Statement> list;
}
{
	foreachToken = <FOREACH>
	//{{{ LPAREN
	try
	{
		lparenToken = <LPAREN>
		{
			pos       = lparenToken.sourceEnd+1;
			endLine   = lparenToken.endLine;
			endColumn = lparenToken.endColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError("'(' expected", "(", e.currentToken);
		{
			pos       = foreachToken.sourceEnd+1;
			endLine   = foreachToken.endLine;
			endColumn = foreachToken.endColumn;
		}
	} //}}}

	//{{{ Expression
	try
	{
		expression = Expression()
		{
			pos       = expression.getSourceEnd()+1;
			endLine   = expression.getEndLine();
			endColumn = expression.getEndColumn();
		}
	}
	catch (ParseException e)
	{
		fireParseError("variable expected", "variable", e.currentToken);
	} //}}}

	//{{{ AS
	try
	{
		asToken = <AS>
		{
			pos       = asToken.sourceEnd+1;
			endLine   = asToken.endLine;
			endColumn = asToken.endColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError("'as' expected", "as", e.currentToken);
	} //}}}

	//{{{ ArrayVariable
	try
	{
		variable = ArrayVariable()
		{
			pos       = variable.getSourceEnd()+1;
			endLine   = variable.getEndLine();
			endColumn = variable.getEndColumn();
		}
	}
	catch (ParseException e)
	{
		if (errorMessage != null) throw e;
		fireParseError("variable expected", "variable", e.currentToken);
	} //}}}

	//{{{ RPAREN
	try
	{
		rparenToken = <RPAREN>
		{
			pos       = rparenToken.sourceEnd+1;
			endLine   = rparenToken.endLine;
			endColumn = rparenToken.endColumn;
		}
	}
	catch (ParseException e)
	{
		fireParseError("')' expected", ")", e.currentToken);
	} //}}}

	(
		//{{{ Statement
		try
		{
			statement = Statement()
			{
				pos       = statement.getSourceEnd()+1;
				endLine   = statement.getEndLine();
				endColumn = statement.getEndColumn();
			}
		}
		catch (ParseException e)
		{
			if (errorMessage != null) throw e;
			fireParseError("statement expected", "statement", e.currentToken);
		}
		{
			return new ForeachStatement(expression,
				variable,
				statement,
				foreachToken.sourceStart,
				pos,
				foreachToken.beginLine,
				endLine,
				foreachToken.beginColumn,
				endColumn);
		} //}}}
	|
		//{{{ : statement endforeach;
		tokenColon = <COLON>
		{
			pos = tokenColon.sourceEnd+1;
		}
		list = statementList()
		{
			fireParseMessage(new PHPParseMessageEvent(INFO,
				PHPParseMessageEvent.MESSAGE_FOREACH_ENDFOREACH_TAG,
				path,
				"Ugly syntax detected, you should foreach () {...} instead of foreach (): ... endforeach;",
				tokenColon));
		}
		//{{{ ENDFOREACH
		try
		{
			tokenEndForeach = <ENDFOREACH>
			{
				pos = tokenEndForeach.sourceEnd+1;
			}
		}
		catch (ParseException e)
		{
			fireParseError(new PHPParseErrorEvent(ERROR,
				path,
				"'endforeach' expected",
				"endforeach",
				e.currentToken.image,
				pos,
				pos+1,
				e.currentToken.beginLine,
				e.currentToken.endLine,
				e.currentToken.endColumn,
				e.currentToken.endColumn+1));
		} //}}}
		//}}}
		//{{{ ;
		try
		{
			tokenSemicolon = <SEMICOLON>
			{
				pos = tokenSemicolon.sourceEnd+1;
			}
		}
		catch (ParseException e)
		{
			fireParseError("';' expected", ";", e.currentToken);
		} //}}}
		{
			if (list.isEmpty())
			{
				return new ForeachStatement(expression,
					variable,
					null,
					foreachToken.sourceStart,
					pos,
					foreachToken.beginLine,
					endLine,
					foreachToken.beginColumn,
					endColumn);
			}
			else
			{
				Statement[] stmtsArray = new Statement[list.size()];
				list.toArray(stmtsArray);
				return new ForeachStatement(expression,
					variable,
					new Block(stmtsArray,
						stmtsArray[0].getSourceStart(),
						stmtsArray[stmtsArray.length-1].getSourceEnd(),
						stmtsArray[0].getBeginLine(),
						stmtsArray[stmtsArray.length-1].getEndLine(),
						stmtsArray[0].getBeginColumn(),
						stmtsArray[stmtsArray.length-1].getEndColumn()),
					foreachToken.sourceStart,
					pos,
					foreachToken.beginLine,
					endLine,
					foreachToken.beginColumn,
					endColumn);
			}
		}
	)
} //}}}

//{{{ FOR
//{{{ ForStatement()
/**
 * a for declaration.
 * @return a node representing the for statement
 */
ForStatement ForStatement():
{
	Token forToken,tokenEndFor,token2,tokenColon;
	int pos;
	Expression[] initializations = null;
	Expression condition = null;
	Expression[] increments = null;
	Statement action;
	List<Statement> list;
	int end;
	int endLine;
	int endColumn;
}
{
	forToken = <FOR>
	try
	{
		<LPAREN>
	}
	catch (ParseException e)
	{
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"'(' expected",
			"(",
			e.currentToken.image,
			forToken.sourceEnd,
			forToken.sourceEnd,
			e.currentToken.beginLine,
			e.currentToken.endLine,
			e.currentToken.endColumn,
			e.currentToken.endColumn));
	}
	[ initializations = ForInit() ] <SEMICOLON>
	[ condition = Expression() ] <SEMICOLON>
	[ increments = StatementExpressionList() ] <RPAREN>
	(
		action = Statement()
		{
			return new ForStatement(initializations,
                                condition,
                                increments,
                                action,
                                forToken.sourceStart,
                                action.getSourceEnd(),
                                forToken.beginLine,
                                action.getEndLine(),
                                forToken.beginColumn,
                                action.getEndColumn());
                }
                |
                tokenColon = <COLON>
                {
                	pos = tokenColon.sourceEnd+1;
                }
                list = statementList()
                {
                	fireParseMessage(new PHPParseMessageEvent(INFO,
                		PHPParseMessageEvent.MESSAGE_FOR_ENDFOR_TAG,
                		path,
                		"Ugly syntax detected, you should for () {...} instead of for (): ... endfor;",
                		tokenColon));
                }
                try
                {
                	tokenEndFor = <ENDFOR>
                	{
                		pos = tokenEndFor.sourceEnd+1;
                	}
                }
                catch (ParseException e)
                {
                	fireParseError(new PHPParseErrorEvent(ERROR,
                		path,
                		"'endfor' expected",
                		"endfor",
                		e.currentToken.image,
                		pos,
                		pos,
                		e.currentToken.beginLine,
                		e.currentToken.endLine,
                		e.currentToken.endColumn,
                		e.currentToken.endColumn));
                }
                try
                {
                	token2 = <SEMICOLON>
                	{
                		pos = token2.sourceEnd+1;
                		end       = token2.sourceEnd;
                		endLine   = token2.endLine;
                		endColumn = token2.endColumn;
                	}
                }
                catch (ParseException e)
                {
                	end       = e.currentToken.sourceEnd;
                	endLine   = e.currentToken.endLine;
                	endColumn = e.currentToken.endColumn;
                	fireParseError(new PHPParseErrorEvent(ERROR,
                		path,
                		"';' expected",
                		";",
                		e.currentToken.image,
                		pos,
                		pos+1,
                		e.currentToken.beginLine,
                		e.currentToken.endLine,
                		e.currentToken.endColumn,
                		e.currentToken.endColumn+1));
                }
                {
                	Statement[] stmtsArray = new Statement[list.size()];
                	list.toArray(stmtsArray);
                	return new ForStatement(initializations,
                                condition,
                                increments,
                                new Block(stmtsArray,
                                	stmtsArray[0].getSourceStart(),
                                	stmtsArray[stmtsArray.length-1].getSourceEnd(),
                                	stmtsArray[0].getBeginLine(),
                                	stmtsArray[stmtsArray.length-1].getEndLine(),
                                	stmtsArray[0].getBeginColumn(),
                                	stmtsArray[stmtsArray.length-1].getEndColumn()),
                                forToken.sourceStart,
                                end,
                                forToken.beginLine,
                                endLine,
                                forToken.beginColumn,
                                endColumn);
                }
                )
} //}}}

//{{{ ForInit()
Expression[] ForInit():
{
	Expression[] exprs;
}
{
	LOOKAHEAD(LocalVariableDeclaration())
	exprs = LocalVariableDeclaration()
	{return exprs;}
	|
	exprs = StatementExpressionList()
	{return exprs;}
} //}}}
//}}}

//{{{ StatementExpressionList()
Expression[] StatementExpressionList():
{
	List<Expression> list = new ArrayList<Expression>();
	Expression expr;
}
{
	expr = Expression()
	{
		list.add(expr);
	}
	(
		<COMMA> Expression()
		{
			list.add(expr);
		}
	)*
	{
		Expression[] exprsArray = new Expression[list.size()];
		list.toArray(exprsArray);
		return exprsArray;
	}
} //}}}

//{{{ ContinueStatement()
Continue ContinueStatement():
{
	Expression expr = null;
	Token continueToken;
	Token semicolonToken = null;
}
{
	continueToken = <CONTINUE> [ expr = Expression() ]
	try
	{
		semicolonToken = <SEMICOLON>
	}
	catch (ParseException e)
	{
		fireParseError("';' expected", ";", e.currentToken);
	}
	{
		if (semicolonToken == null)
		{
			if (expr == null)
			{
				return new Continue(expr,
					continueToken.sourceStart,
					continueToken.sourceEnd,
					continueToken.beginLine,
					continueToken.endLine,
					continueToken.beginColumn,
					continueToken.endColumn);
			}
			return new Continue(expr,continueToken.sourceStart,
				expr.getSourceEnd(),continueToken.beginLine,
				expr.getEndLine(),continueToken.beginColumn,
				expr.getEndColumn());
		}
		return new Continue(expr,continueToken.sourceStart,
			semicolonToken.sourceEnd,continueToken.beginLine,
			semicolonToken.endLine,continueToken.beginColumn,
			semicolonToken.endColumn);
	}
} //}}}

//{{{ ReturnStatement()
/**
 * A return statement.
 * It's return [expression];
 * @return a ReturnStatement
 */
ReturnStatement ReturnStatement():
{
	Statement expr = null;
	Token returnToken;
	Token semicolonToken;
	int end       = 0;
	int endLine   = 0;
	int endColumn = 0;
}
{
	returnToken = <RETURN>
	[
		expr = Expression()
		{
			end       = expr.getSourceEnd();
			endLine   = expr.getEndLine();
			endColumn = expr.getEndColumn();
		}
	]
	try
	{
		semicolonToken = <SEMICOLON>
		{
			end       = semicolonToken.sourceEnd;
			endLine   = semicolonToken.endLine;
			endColumn = semicolonToken.endColumn;
		}
	}
	catch (ParseException e)
	{
		if (end == 0)
		{
			end       = e.currentToken.sourceEnd;
			endLine   = e.currentToken.endLine;
			endColumn = e.currentToken.endColumn;
		}
		//{{{ fireParseError
		fireParseError(new PHPParseErrorEvent(ERROR,
			path,
			"';' expected",
			";",
			e.currentToken.image,
			end,
			e.currentToken.sourceEnd,
			endLine,
			e.currentToken.endLine,
			endColumn,
			e.currentToken.endColumn)); //}}}
	}
	{
		return new ReturnStatement(expr,
			returnToken.sourceStart,
			end,
			returnToken.beginLine,
			endLine,
			returnToken.beginColumn,
			endColumn);
	}
} //}}}

//}}}
