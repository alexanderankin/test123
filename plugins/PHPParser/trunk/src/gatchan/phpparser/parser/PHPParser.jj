/*
 * :tabSize=2:indentSize=2:noTabs=true:
 * :folding=explicit:collapseFolds=1:
 */
 
options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  OPTIMIZE_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = false;
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(PHPParser)
package gatchan.phpparser.parser;

import java.util.ArrayList;
import java.io.StringReader;
import java.io.*;
import java.util.List;
import java.util.Stack;

import net.sourceforge.phpdt.internal.compiler.ast.declarations.VariableUsage;
import net.sourceforge.phpdt.internal.compiler.ast.*;
import net.sourceforge.phpdt.internal.compiler.parser.OutlineableWithChildren;
import net.sourceforge.phpdt.internal.compiler.parser.Outlineable;

/**
 * A PHP Parser originaly written for phpeclipse (http://www.phpeclipse.de).
 *
 * @author Matthieu Casanova <chocolat.mou@gmail.com>
 * @version $Id$
 */
public final class PHPParser {

  //{{{ Fields

//{{{ constants for methods and function distinction (some keywords are allowed in method classes

  public static final int CONST_METHOD = 0;
  public static final int CONST_FUNCTION = 1;
  //}}}

  //todo : fix the variables names bug
  //todo : handle tilde operator

  //todo: put this in an interface
  public static final int ERROR = 2;
  public static final int WARNING = 1;
  public static final int INFO = 0;

  /** The current segment. */
  private OutlineableWithChildren currentSegment;

  /** The message of the current ParseException. If it's null it's because the parse exception wasn't handled */
  private String errorMessage;

  private int errorStart = -1;
  private int errorEnd = -1;
  private PHPDocument phpDocument;

  private static final String SYNTAX_ERROR_CHAR = "syntax error";
  /**
  * The point where html starts.
  * It will be used by the token manager to create HTMLCode objects
  */
  private int htmlStart;
  private int htmlLineStart;
  private int htmlColumnStart;

  //ast stack
  private static final int AstStackIncrement = 100;
  /** The stack of node. */
  private Statement[] nodes;
  /** The cursor in expression stack. */
  private int nodePtr;

  public static final boolean PARSER_DEBUG = false;

  private final List parserListeners = new ArrayList();

  private String path;

  /** Tell if the parsing should be stopped. */
  private boolean shouldStop;

  private boolean php5Enabled;
  
  private Stack scopeStack;
  
  private Scope scope;
  
  private List tempList = new ArrayList();
  //}}}

  //{{{ PHPParser()

  public PHPParser() {
  }

  //}}}
  //{{{ getPath()

  /**
   * Set the path of the file that is currently parsed.
   * This path will be sent in parse errors and messages
   *
   * @param path the path of the parsed file
   */
  public void setPath(String path) {
    this.path = path;
  } //}}}
  //{{{ getPath()

  public String getPath() {
    return path;
  } //}}}
  //{{{ setPhp5Enabled(boolean php5Enabled)
  public void setPhp5Enabled(boolean php5Enabled) {
    this.php5Enabled = php5Enabled;
  } //}}}
  
  //{{{ stop()

  /**
   * Ask the parser to stop his work.
   */
  public void stop() {
    shouldStop = true;
  }

  //}}}
  //{{{ isStopped()

  public boolean isStopped() {
    return shouldStop;
  }

  //}}}
  //{{{ addParserListener(PHPParserListener listener)

  public void addParserListener(PHPParserListener listener) {
    if (!parserListeners.contains(listener)) {
      parserListeners.add(listener);
    }
  }

  //}}}
  //{{{ removeParserListener(PHPParserListener listener)

  public void removeParserListener(PHPParserListener listener) {
    parserListeners.remove(listener);
  }

  //}}}
  //{{{ fireParseError(PHPParseErrorEvent e)

  public void fireParseError(PHPParseErrorEvent e) {
    for (int i = 0;i < parserListeners.size();i++) {
        PHPParserListener listener = (PHPParserListener) parserListeners.get(i);
        listener.parseError(e);
    }
  }

  //}}}

  //{{{ fireParseError(String message, String expected, Token token)

  public void fireParseError(String message, String expected, Token token) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          message,
                                          expected,
                                          token));
  } 

  //}}}
  //{{{ fireParseMessage(PHPParseMessageEvent e)

  public void fireParseMessage(PHPParseMessageEvent e) {
    for (int i = 0;i < parserListeners.size();i++) {
        PHPParserListener listener = (PHPParserListener) parserListeners.get(i);
        listener.parseMessage(e);
    }
  }

  //}}}
  //{{{ phpParserTester(String strEval)

  public final void phpParserTester(String strEval) throws ParseException {
    StringReader stream = new StringReader(strEval);
    if (jj_input_stream == null) {
      jj_input_stream = new JavaCharStream(stream, 1, 1);
      token_source = new PHPParserTokenManager(jj_input_stream);
    }
    ReInit(new StringReader(strEval));
    init();
    phpDocument = new PHPDocument("_root");
    scope = new Scope();
    scopeStack = new Stack();
    scopeStack.push(scope);
    currentSegment = phpDocument;
    token_source.SwitchTo(PHPParserTokenManager.PHPPARSING);
    phpTest();
  }//}}}
  
  //{{{ htmlParserTester(File fileName)

  public final void htmlParserTester(File fileName) throws FileNotFoundException, ParseException {
    Reader stream = new FileReader(fileName);
    if (jj_input_stream == null) {
      jj_input_stream = new JavaCharStream(stream, 1, 1);
      token_source = new PHPParserTokenManager(jj_input_stream);
    }
    ReInit(stream);
    init();
    phpDocument = new PHPDocument("_root");
    scope = new Scope();
    scopeStack = new Stack();
    scopeStack.push(scope);
    currentSegment = phpDocument;
    phpFile();
  }

  //}}}
  //{{{ htmlParserTester(String strEval)

  public final void htmlParserTester(String strEval) throws ParseException {
    StringReader stream = new StringReader(strEval);
    if (jj_input_stream == null) {
      jj_input_stream = new JavaCharStream(stream, 1, 1);
      token_source = new PHPParserTokenManager(jj_input_stream);
    }
    ReInit(stream);
    init();
    phpDocument = new PHPDocument("_root");
    scope = new Scope();
    scopeStack = new Stack();
    scopeStack.push(scope);
    currentSegment = phpDocument;
    phpFile();
  }

  //}}}
  //{{{ init()

  /**
   * Reinitialize the parser.
   */
  private void init() {
    nodes = new Statement[AstStackIncrement];
    nodePtr = -1;
    htmlStart = 0;
    htmlColumnStart = 0;
    htmlLineStart = 0;
  }

  //}}}
  //{{{ pushOnAstNodes(Statement node)

  /**
   * Add an php node on the stack.
   * @param node the node that will be added to the stack
   */
  private void pushOnAstNodes(Statement node) {
    try {
      nodes[++nodePtr] = node;
    } catch (IndexOutOfBoundsException e) {
      int oldStackLength = nodes.length;
      Statement[] oldStack = nodes;
      nodes = new Statement[oldStackLength + AstStackIncrement];
      System.arraycopy(oldStack, 0, nodes, 0, oldStackLength);
      nodePtr = oldStackLength;
      nodes[nodePtr] = node;
    }
  }

  //}}}
  //{{{ parse(String s)

  public final void parse(String s) throws ParseException {
    Reader reader = new StringReader(s);
    parse(reader);
  }

  //}}}
  //{{{ parse(Reader reader)

  public final void parse(Reader reader) throws ParseException {
    phpDocument = new PHPDocument("_root");
    scope = new Scope();
    scopeStack = new Stack();
    scopeStack.push(scope);
    currentSegment = phpDocument;
    if (jj_input_stream == null) {
      jj_input_stream = new JavaCharStream(reader, 1, 1);
      token_source = new PHPParserTokenManager(jj_input_stream);
    }
    ReInit(reader);
    init();
    parse();
    Statement[] astNodes = new Statement[nodes.length];
    phpDocument.setNodes(astNodes);
    System.arraycopy(nodes,0,astNodes,0,nodes.length);
    phpDocument.analyzeCode(this);
  }

  //}}}
  //{{{ createNewHTMLCode()

  /**
   * Put a new html block in the stack.
   */
  public final void createNewHTMLCode() {
    int currentPosition = token.sourceStart;
    if (currentPosition == htmlStart ||
          currentPosition < htmlStart ||
          currentPosition > jj_input_stream.getCurrentBuffer().length()) {
      return;
    }
    // todo : reactivate this
    //final String html = jj_input_stream.getCurrentBuffer().substring(htmlStart, currentPosition);
    String html = "";
    pushOnAstNodes(new HTMLCode(html, htmlStart,currentPosition,htmlLineStart,token.endLine,htmlColumnStart,token.endColumn));
  }

  //}}}
  //{{{ error_skipto(int kind)

  Token error_skipto(int kind) {
    //  ParseException e = generateParseException();  // generate the exception object.
    //  System.out.println(e.toString());  // print the error message
    Token t;
    do {
      t = getNextToken();
    } while (t.kind != kind && t.kind != PHPParserConstants.EOF && t.kind != PHPParserConstants.RBRACE);
    return t;
  }

  //}}}
  //{{{ parse()

  public final void parse() throws ParseException {
	  phpFile();
  }

  //}}}
  //{{{ getPHPDocument()

  public PHPDocument getPHPDocument() {
    return phpDocument;
  }

  //}}}
  
  //{{{ setTypeFromScope(Variable variable)
  private void setTypeFromScope(Variable variable) {
    VariableUsage usage = scope.getVariable(variable.getName(),variable.getBeginLine(),variable.getBeginColumn());
    if (usage != null) {
      variable.setType(usage.getType());
    }
  }

  //}}}
}

PARSER_END(PHPParser)

TOKEN_MGR_DECLS:
{
  // CommonTokenAction: use the begins/ends fields added to the Jack
  // CharStream class to set corresponding fields in each Token (which was
  // also extended with new fields). By default Jack doesn't supply absolute
  // offsets, just line/column offsets
  void CommonTokenAction(Token t) {
    t.sourceStart = input_stream.getBeginOffset();
    t.sourceEnd = input_stream.getEndOffset();

  } // CommonTokenAction
} // TOKEN_MGR_DECLS

//{{{ TOKEN declarations

<DEFAULT> TOKEN :
{
  <PHPSTARTSHORT : "<?">    : PHPPARSING
| <PHPSTARTLONG  : "<?php"> : PHPPARSING
| <PHPECHOSTART  : "<?=">   : PHPPARSING
}

<PHPPARSING, IN_SINGLE_LINE_COMMENT,IN_VARIABLE> TOKEN :
{
  <PHPEND :"?>"> : DEFAULT
}

/* Skip any character if we are not in php mode */
<DEFAULT> SKIP :
{
 < ~[] >
}


/* WHITE SPACE */
<PHPPARSING> SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

<IN_VARIABLE> SPECIAL_TOKEN :
{
  " "  : PHPPARSING
| "\t" : PHPPARSING
| "\n" : PHPPARSING
| "\r" : PHPPARSING
| "\f" : PHPPARSING
}
/* COMMENTS */
<PHPPARSING> SPECIAL_TOKEN :
{
  "//" : IN_SINGLE_LINE_COMMENT
| "#"  : IN_SINGLE_LINE_COMMENT
| <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT> SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : PHPPARSING
| < ~[] >
}

<IN_FORMAL_COMMENT> SPECIAL_TOKEN :
{
  "*/" : PHPPARSING
}

<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN :
{
  "*/" : PHPPARSING
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}


//{{{ PHP5 tokens
/* VISIBILITY */
<PHPPARSING> TOKEN :
{
  <PUBLIC    : "public">
| <PROTECTED : "protected">
| <PRIVATE   : "private">
}

<PHPPARSING> TOKEN :
{
  <ABSTRACT : "abstract">
}

<PHPPARSING> TOKEN :
{
  <INTERFACE  : "interface">
| <IMPLEMENTS : "implements">
| <FINAL      : "final">
}

/* Exceptions */
<PHPPARSING> TOKEN :
{
  <TRY   : "try">
| <CATCH : "catch">
| <THROW : "throw">
}
//}}}


/* KEYWORDS */
<PHPPARSING> TOKEN :
{
  <CLASS    : "class">
| <FUNCTION : "function">
| <VAR      : "var">
| <IF       : "if">
| <ELSEIF   : "elseif">
| <ELSE     : "else">
| <ARRAY    : "array">
| <BREAK    : "break">
| <LIST     : "list">
}

/* LANGUAGE CONSTRUCT */
<PHPPARSING> TOKEN :
{
  <PRINT              : "print">
| <ECHO               : "echo">
| <INCLUDE            : "include">
| <REQUIRE            : "require">
| <INCLUDE_ONCE       : "include_once">
| <REQUIRE_ONCE       : "require_once">
| <GLOBAL             : "global">
| <STATIC             : "static">
| <CASE               : "case">
| <CONST              : "const">
| <CONTINUE           : "continue">
| <_DEFAULT           : "default">
| <DO                 : "do">
| <EXTENDS            : "extends">
| <FOR                : "for">
| <NEW                : "new">
| <RETURN             : "return">
| <SWITCH             : "switch">
| <WHILE              : "while">
| <ENDWHILE           : "endwhile">
| <ENDSWITCH          : "endswitch">
| <ENDIF              : "endif">
| <ENDFOR             : "endfor">
| <ENDFOREACH         : "endforeach">
| <FOREACH            : "foreach">
| <AS                 : "as" >
}

<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <CLASSACCESS        : "->"> : PHPPARSING
| <STATICCLASSACCESS  : "::"> : PHPPARSING
| <ARRAYASSIGN        : "=>"> : PHPPARSING
}

/* RESERVED WORDS AND LITERALS */

<PHPPARSING> TOKEN :
{
  <DEFINE   : "define">
| <GOTO     : "goto">
| <NULL     : "null">
| <SUPER    : "super">
| <THIS     : "this">
| <TRUE     : "true">
| <FALSE    : "false">
| <INSTANCEOF : "instanceof" >
}

/* TYPES */
<PHPPARSING> TOKEN :
{
  <STRING  : "string">
| <OBJECT  : "object">
| <BOOL    : "bool">
| <BOOLEAN : "boolean">
| <REAL    : "real">
| <DOUBLE  : "double">
| <FLOAT   : "float">
| <INT     : "int">
| <INTEGER : "integer">
}

//Misc token
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <AT                 : "@"> : PHPPARSING
| <BANG               : "!"> : PHPPARSING
| <TILDE              : "~"> : PHPPARSING
| <HOOK               : "?"> : PHPPARSING
| <COLON              : ":"> : PHPPARSING
}

/* OPERATORS */
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <OR_OR              : "||">  : PHPPARSING
| <AND_AND            : "&&">  : PHPPARSING
| <PLUS_PLUS          : "++">  : PHPPARSING
| <MINUS_MINUS        : "--">  : PHPPARSING
| <PLUS               : "+">   : PHPPARSING
| <MINUS              : "-">   : PHPPARSING
| <STAR               : "*">   : PHPPARSING
| <SLASH              : "/">   : PHPPARSING
| <BIT_AND            : "&">   : PHPPARSING
| <BIT_OR             : "|">   : PHPPARSING
| <BIT_XOR            : "^">   : PHPPARSING
| <REMAINDER          : "%">   : PHPPARSING
| <LSHIFT             : "<<">  : PHPPARSING
| <RSIGNEDSHIFT       : ">>">  : PHPPARSING
| <RUNSIGNEDSHIFT     : ">>>"> : PHPPARSING
| <_ORL               : "OR">  : PHPPARSING
| <XOR                : "XOR"> : PHPPARSING
| <_ANDL              : "AND"> : PHPPARSING
}

/* LITERALS */
<PHPPARSING> TOKEN :
{
  <INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  <#DECIMAL_LITERAL: (["0"-"9"])+ >
|
  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  <#OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  <FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  <STRING_LITERAL: (/*<STRING_1> |*/ <STRING_2> | <STRING_3>)>
/*|   <STRING_1: "\"" ( ~["\"","\\"] | "\\" ~[] )* "\"">*/
|   <STRING_2: "'"  ( ~["'","\\"]  | "\\" ~[] )* "'">
|   <STRING_3: "`"  ( ~["`","\\"]  | "\\" ~[] )* "`">
}
 
<IN_STRING,DOLLAR_IN_STRING,SKIPSTRING> SKIP :
{
  <ESCAPED : ("\\" ~[])> : IN_STRING
}

<PHPPARSING> TOKEN :
{
  <DOUBLEQUOTE : "\""> : IN_STRING
}

<IN_STRING,SKIPSTRING> TOKEN :
{
  <DOLLARS : "$"> : DOLLAR_IN_STRING
}

<IN_STRING,DOLLAR_IN_STRING,SKIPSTRING> TOKEN :
{
  <DOUBLEQUOTE2 : "\""> : PHPPARSING
}

<DOLLAR_IN_STRING> TOKEN :
{
  <LBRACE1 : "{"> : DOLLAR_IN_STRING_EXPR
}

<IN_STRING> SPECIAL_TOKEN :
{
    <"{"> : SKIPSTRING
}

<SKIPSTRING> SPECIAL_TOKEN :
{
    <"}"> : IN_STRING
}

<SKIPSTRING> SKIP :
{
    <~[]>
}

<DOLLAR_IN_STRING_EXPR> TOKEN :
{
  <RBRACE1 : "}"> : IN_STRING
}

<DOLLAR_IN_STRING_EXPR> TOKEN :
{
  <ID : (~["}"])*>
}

<IN_STRING> SKIP :
{
  <~[]>
}

<DOLLAR_IN_STRING_EXPR,IN_STRING> SKIP :
{
  <~[]>
}


<PHPPARSING> TOKEN :
{
  <HEREDOCSTARTTOKEN : "<<<">
}


<PHPPARSING,IN_VARIABLE> TOKEN : {<DOLLAR : "$"> : IN_VARIABLE}

<PHPPARSING, IN_VARIABLE,DOLLAR_IN_STRING> TOKEN :
{
  <IDENTIFIER: ((<LETTER>|<SPECIAL>) (<LETTER>|<DIGIT>|<SPECIAL>)*)>
|
  < #LETTER:
      ["a"-"z"] | ["A"-"Z"]
  >
|
  < #DIGIT:
      ["0"-"9"]
  >
|
  < #SPECIAL:
    "_" | ["\u007f"-"\u00ff"]
  >
}

/*
<HEREDOC> SKIP :
{
  <NEWLINE2 : "\n"> : HEREDOCLINESTART
| <~[]>
}
  */

/* IDENTIFIERS */




//<PHPPARSING, IN_VARIABLE, DOLLAR_IN_STRING> TOKEN :

  
<DOLLAR_IN_STRING> SPECIAL_TOKEN :
{
 < ~[] > : IN_STRING
}  
/* SEPARATORS */

<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <LPAREN    : "("> : PHPPARSING
| <RPAREN    : ")"> : PHPPARSING
| <LBRACE    : "{"> : PHPPARSING
| <RBRACE    : "}"> : PHPPARSING
| <LBRACKET  : "["> : PHPPARSING
| <RBRACKET  : "]"> : PHPPARSING
| <SEMICOLON : ";"> : PHPPARSING
| <COMMA     : ","> : PHPPARSING
| <DOT       : "."> : PHPPARSING
}


/* COMPARATOR */
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <GT                 : ">"  > : PHPPARSING
| <LT                 : "<"  > : PHPPARSING
| <EQUAL_EQUAL        : "==" > : PHPPARSING
| <LE                 : "<=" > : PHPPARSING
| <GE                 : ">=" > : PHPPARSING
| <NOT_EQUAL          : "!=" > : PHPPARSING
| <DIF                : "<>" > : PHPPARSING
| <BANGDOUBLEEQUAL    : "!=="> : PHPPARSING
| <TRIPLEEQUAL        : "==="> : PHPPARSING
}

/* ASSIGNATION */
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <ASSIGN             : "="  > : PHPPARSING
| <PLUSASSIGN         : "+=" > : PHPPARSING
| <MINUSASSIGN        : "-=" > : PHPPARSING
| <STARASSIGN         : "*=" > : PHPPARSING
| <SLASHASSIGN        : "/=" > : PHPPARSING
| <ANDASSIGN          : "&=" > : PHPPARSING
| <ORASSIGN           : "|=" > : PHPPARSING
| <XORASSIGN          : "^=" > : PHPPARSING
| <DOTASSIGN          : ".=" > : PHPPARSING
| <REMASSIGN          : "%=" > : PHPPARSING
| <TILDEEQUAL         : "~=" > : PHPPARSING
| <LSHIFTASSIGN       : "<<="> : PHPPARSING
| <RSIGNEDSHIFTASSIGN : ">>="> : PHPPARSING
}

//}}}



//{{{ PHP Structures

//{{{ phpTest()

void phpTest() :
{}
{
  Php()
  <EOF>
}

//}}}
//{{{ phpFile()

void phpFile() :
{}
{
  try {
    (PhpBlock())*
    {
      createNewHTMLCode();
    }
  } catch (TokenMgrError e) {
    //{{{ Parse Error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          e.getMessage(),
                                          e.getMessage(),
                                          null,
                                          jj_input_stream.getBeginOffset(),
                                          jj_input_stream.getEndOffset(),
                                          jj_input_stream.getBeginLine(),
                                          jj_input_stream.getEndLine(),
                                          jj_input_stream.getBeginColumn(),
                                          jj_input_stream.getEndColumn())); //}}}
  }
}

//}}}
//{{{ PhpBlock()

/**
 * A php block is a <?= expression [;]?>
 * or <?php somephpcode ?>
 * or <? somephpcode ?>
 */
void PhpBlock() :
{
  final PHPEchoBlock phpEchoBlock;
  final Token token,phpEnd;
}
{
  phpEchoBlock = phpEchoBlock()
  {pushOnAstNodes(phpEchoBlock);}
|
  [   <PHPSTARTLONG>
    | token = <PHPSTARTSHORT>
    {
      fireParseMessage(new PHPParseMessageEvent(INFO,
                                                PHPParseMessageEvent.MESSAGE_SHORT_OPEN_TAG,
                                                path,
                                                "You should use '<?php' instead of '<?' it will avoid some problems with XML",
                                                token));
    }
  ]
  {
    createNewHTMLCode();
  }
  Php()
  try {
    phpEnd = <PHPEND>
   {
    htmlStart = phpEnd.sourceEnd;
    htmlLineStart = phpEnd.endLine;
    htmlColumnStart = phpEnd.endColumn;
   }
  } catch (ParseException e) {
      fireParseMessage(new PHPParseMessageEvent(INFO,
                                                PHPParseMessageEvent.MESSAGE_PHP_CLOSING_MISSING,
                                                path,
                                                "'?>' is missing",
                                                e.currentToken));
  }
}

//}}}
//{{{ phpEchoBlock()

PHPEchoBlock phpEchoBlock() :
{
  final Expression expr;
  PHPEchoBlock echoBlock;
  final Token token, token2;
}
{
  token = <PHPECHOSTART> {createNewHTMLCode();}
  expr = Expression() [ <SEMICOLON> ]
  try {
    token2 = <PHPEND>
    {
      htmlStart = token2.sourceEnd;
      htmlLineStart = token2.endLine;
      htmlColumnStart = token2.endColumn;

      echoBlock = new PHPEchoBlock(expr,token.sourceStart,token2.sourceEnd, token.beginLine,token2.endLine,token.beginColumn,token2.endColumn);
    }
  } catch (ParseException e) {
    fireParseMessage(new PHPParseMessageEvent(INFO,
                                              PHPParseMessageEvent.MESSAGE_PHP_CLOSING_MISSING,
                                              path,
                                              "'?>' is missing",
                                              e.currentToken));
    echoBlock = new PHPEchoBlock(expr,
                                 token.sourceStart,
                                 e.currentToken.sourceEnd,
                                 token.beginLine,
                                 e.currentToken.endLine,
                                 token.beginColumn,
                                 e.currentToken.endColumn);
  }
  {
    pushOnAstNodes(echoBlock);
    return echoBlock;
  }
}

//}}}
//{{{ Php()

void Php() :
{}
{
  (BlockStatement())*
}

//}}}


//}}}

//{{{ interfaceDeclaration()
InterfaceDeclaration interfaceDeclaration() :
{
  Token visibilityToken = null;
  Token interfaceToken, rBraceToken;
  Token nameToken = null;
  InterfaceDeclaration interfaceDeclaration;
  String interfaceNameImage = SYNTAX_ERROR_CHAR;
  MethodDeclaration methodDeclaration;
  List superInterfaces = null;
}
{
  interfaceToken = <INTERFACE>
  try {
    nameToken = <IDENTIFIER>
    {
      interfaceNameImage = nameToken.image;
    }
  } catch (ParseException e) {
    fireParseError("identifier expected","identifier",e.currentToken);
  }
  [
    {
        superInterfaces = new ArrayList();
    }
    <EXTENDS> nameToken = <IDENTIFIER>
    {
        superInterfaces.add(nameToken.image);
    }
  (
    <COMMA> nameToken = <IDENTIFIER>
    {
        superInterfaces.add(nameToken.image);
    }
  )*
  ]
  
  {
    interfaceDeclaration = new InterfaceDeclaration(path,
                                                    currentSegment,
                                                    interfaceNameImage,
                                                    superInterfaces,
                                                    interfaceToken.sourceStart,
                                                    interfaceToken.beginLine,
                                                    interfaceToken.beginColumn);
    currentSegment.add(interfaceDeclaration);
    currentSegment = interfaceDeclaration;
    scope = new Scope();
    scopeStack.push(scope);
  }
  <LBRACE>
  (
    [visibilityToken = visibility()]
    methodDeclaration = interfaceMethodDeclaration()
    {
      //todo use visibilityToken
      interfaceDeclaration.add(methodDeclaration);
    }
  )*
  rBraceToken = <RBRACE>
  {
    currentSegment = interfaceDeclaration.getParent();
    scope = (Scope) scopeStack.pop();
    interfaceDeclaration.setSourceEnd(rBraceToken.sourceEnd);
    interfaceDeclaration.setEndLine(rBraceToken.endLine);
    interfaceDeclaration.setEndColumn(rBraceToken.endColumn);
    return interfaceDeclaration;
  }
} //}}}

//{{{ interfaceMethodDeclaration()
/**
 * A Method Declaration.
 * <b>function</b> MetodDeclarator() Block()
 *
 * @return a MethodDeclaration
 */
MethodDeclaration interfaceMethodDeclaration() :
{
  final MethodDeclaration functionDeclaration;
  final MethodHeader methodHeader;
  final Block block;
  final OutlineableWithChildren seg = currentSegment;
  final Token functionToken;
}
{
  functionToken = <FUNCTION>

  methodHeader = methodHeader(functionToken,CONST_METHOD)
  {
    functionDeclaration = new MethodDeclaration(currentSegment,methodHeader);
  }
  try {
    <SEMICOLON>
  } catch (ParseException e) {
    fireParseError("unexpected token : "+e.currentToken.image, ";", e.currentToken);
  }
  {
    return functionDeclaration;
  }
} //}}}


//{{{ Class methods

//{{{ ClassDeclaration()

/**
 * A Class declaration.
 * class <IDENTIFIER> [extends <IDENTIFIER>] Class body
 *
 * @return a ClassDeclaration
 */
ClassDeclaration ClassDeclaration() :
{
  final ClassHeader classHeader;
  final ClassDeclaration classDeclaration;
  Token abstractToken = null;
}
{
  abstractToken = <ABSTRACT>
  {
    if (!php5Enabled) {
      fireParseError("unexpected token : abstract", "", abstractToken);
    }
  }
  classHeader = classHeader(abstractToken)
  {
    classDeclaration = new ClassDeclaration(currentSegment,
                                            classHeader,
                                            classHeader.getSourceStart(),
                                            classHeader.getSourceEnd(),
                                            classHeader.getBeginLine(),
                                            classHeader.getEndLine(),
                                            classHeader.getBeginColumn(),
                                            classHeader.getEndColumn());
      currentSegment.add(classDeclaration);
      currentSegment = classDeclaration;
      scope = new Scope();
      scopeStack.push(scope);
  }
  //todo change this
  abstractClassBody(classDeclaration)
  {
    currentSegment = currentSegment.getParent();
    scope = (Scope) scopeStack.pop();
    pushOnAstNodes(classDeclaration);
    return classDeclaration;
  }
|
  classHeader = classHeader(null)
  {
    classDeclaration = new ClassDeclaration(currentSegment,
                                            classHeader,
                                            classHeader.getSourceStart(),
                                            classHeader.getSourceEnd(),
                                            classHeader.getBeginLine(),
                                            classHeader.getEndLine(),
                                            classHeader.getBeginColumn(),
                                            classHeader.getEndColumn());
      currentSegment.add(classDeclaration);
      currentSegment = classDeclaration;
      scope = new Scope();
      scopeStack.push(scope);
  }
  //todo change this
  ClassBody(classDeclaration)
  {
    currentSegment = currentSegment.getParent();
    scope = (Scope) scopeStack.pop();
    pushOnAstNodes(classDeclaration);
    return classDeclaration;
  }
}
//}}}

//{{{ classHeader(Token abstractToken)
ClassHeader classHeader(Token abstractToken) :
{
  Token classToken;
  Token className = null;
  Token superclassName;
  Token firstToken = abstractToken;
  String classNameImage = SYNTAX_ERROR_CHAR;
  String superclassNameImage = null;
  Token interfaceToken;
  List interfaceNames = null;
}
{
  classToken = <CLASS>
  {
    if (firstToken == null) firstToken = classToken;
  }
  try {
    className = <IDENTIFIER>
    {
      classNameImage = className.image;
    }
  } catch (ParseException e) {
    //{{{ Parse error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "identifier expected",
                                          "identifier",
                                          e.currentToken.image,
                                          classToken.sourceEnd,
                                          classToken.sourceEnd+1,
                                          classToken.endLine,
                                          classToken.endLine,
                                          classToken.endColumn,
                                          classToken.endColumn+1)); //}}}
  }
  [
  <EXTENDS>
  try {
    superclassName = <IDENTIFIER>
    {
      superclassNameImage = superclassName.image;
    }
  } catch (ParseException e) {
    //{{{ Parse error
    fireParseError("identifier expected", "identifier", e.currentToken.next);
    superclassNameImage = SYNTAX_ERROR_CHAR;
    error_skipto(LBRACE);//}}}
  }
  ]
  [
      {
          interfaceNames = new ArrayList();
      }
    <IMPLEMENTS>
    interfaceToken = <IDENTIFIER>
    {
        interfaceNames.add(interfaceToken.image);
    }
    ( 
      <COMMA> 
      interfaceToken = <IDENTIFIER> 
      {
        interfaceNames.add(interfaceToken.image);
      }
    )*
  ]
  {
    final int end,endLine,endColumn;
    if (className == null) {
      end         = firstToken.sourceEnd;
      endLine     = firstToken.endLine;
      endColumn   = firstToken.endColumn;
    } else {
      end         = className.sourceEnd;
      endLine     = className.endLine;
      endColumn   = className.endColumn;
    }
    return new ClassHeader(path,
                           classNameImage,
                           superclassNameImage,
                           interfaceNames,
                           firstToken.sourceStart,
                           end,
                           firstToken.beginLine,
                           endLine,
                           firstToken.beginColumn,
                           endColumn);
  }
}//}}}

//{{{ ClassBody(ClassDeclaration classDeclaration)

void ClassBody(ClassDeclaration classDeclaration) :
{
  final Token lBraceToken;
  Token rBraceToken;
}
{
  try {
    lBraceToken = <LBRACE>
    {
      classDeclaration.setBodyLineStart(lBraceToken.beginLine);
      classDeclaration.setBodyColumnStart(lBraceToken.beginColumn);
    }
  } catch (ParseException e) {
    fireParseError("'{' expected", "{", e.currentToken);
  }
  ( ClassBodyDeclaration(classDeclaration) )*
  try {
    rBraceToken = <RBRACE>
    {
      classDeclaration.setBodyLineEnd(rBraceToken.endLine);
      classDeclaration.setBodyColumnEnd(rBraceToken.endColumn);
    }
  } catch (ParseException e) {
    //{{{ Parse error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'}' expected",
                                          "}",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
    rBraceToken = error_skipto(RBRACE);
    classDeclaration.setBodyLineEnd(rBraceToken.endLine);
    classDeclaration.setBodyColumnEnd(rBraceToken.endColumn);
  }
}

//}}}
//{{{ abstractClassBody(ClassDeclaration classDeclaration)
void abstractClassBody(ClassDeclaration classDeclaration) :
{
  final Token lBraceToken;
  Token rBraceToken;
}
{
  try {
    lBraceToken = <LBRACE>
    {
      classDeclaration.setBodyLineStart(lBraceToken.beginLine);
      classDeclaration.setBodyColumnStart(lBraceToken.beginColumn);
    }
  } catch (ParseException e) {
    //{{{ Parse error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'{' expected",
                                          "{",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
  }
  ( abstractClassBodyDeclaration(classDeclaration) )*
  try {
    rBraceToken = <RBRACE>
    {
      classDeclaration.setBodyLineEnd(rBraceToken.endLine);
      classDeclaration.setBodyColumnEnd(rBraceToken.endColumn);
    }
  } catch (ParseException e) {
    //{{{ Parse error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'}' expected",
                                          "}",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
    rBraceToken = error_skipto(RBRACE);
    classDeclaration.setBodyLineEnd(rBraceToken.endLine);
    classDeclaration.setBodyColumnEnd(rBraceToken.endColumn);
  }
} //}}}

//{{{ ClassBodyDeclaration(final ClassDeclaration classDeclaration)

/**
 * A class can contain only methods and fields.
 */
void ClassBodyDeclaration(final ClassDeclaration classDeclaration) :
{
  final MethodDeclaration method;
  final FieldDeclaration field;
  Token visibilityToken = null;
  Token visibilityToken2 = null;
  Token finalToken = null;
  List fieldList;
}
{

  [
   visibilityToken = visibility()
   {
     if (!php5Enabled) {
       fireParseError("unexpected token " + visibilityToken.image, "", visibilityToken);
     }
   }
  ]
  try {
    (
       field  = FieldDeclarationPHP5(visibilityToken)
       {
         if (field != null) classDeclaration.addField(field);
       }
     |
       [
         finalToken = <FINAL>
         [
           visibilityToken2 = visibility()
           {
             if (!php5Enabled) {
               fireParseError("unexpected token " + visibilityToken.image, "", visibilityToken);
             }
             if (visibilityToken != null) {
               fireParseError("unexpected token " + visibilityToken2.image, "", visibilityToken2);
             }
           }
         ]
       ]
       method = MethodDeclaration(CONST_METHOD,visibilityToken)
       {
       //  method.analyzeCode(this);
         classDeclaration.addMethod(method);
       }
     )
  } catch (ParseException e) {
    fireParseError("unexpected token " + e.currentToken.image, "", e.currentToken);
  }
|
  fieldList  = FieldDeclaration()
  {
    if (fieldList != null) {
      for (int i = 0;i<fieldList.size();i++) {
        classDeclaration.addField((FieldDeclaration) fieldList.get(i));
      }
    }
  }
}

//}}}
//{{{ abstractClassBodyDeclaration(ClassDeclaration classDeclaration)

/**
 * A class can contain only methods and fields.
 */
void abstractClassBodyDeclaration(ClassDeclaration classDeclaration) :
{
  final MethodDeclaration method;
  final FieldDeclaration field;
  Token visibilityToken = null;
  Token visibilityToken2;
  Token finalToken = null;
  List fieldList;
}
{

  [
   visibilityToken = visibility()
   {
     //{{{ Parse error if not in php5
     if (!php5Enabled) {
       fireParseError("unexpected token " + visibilityToken.image, "", visibilityToken);
     } //}}}
   }
  ]
  try {
    (
       field  = FieldDeclarationPHP5(visibilityToken)
       {
         if (field != null) classDeclaration.addField(field);
       }
     |
       [
         finalToken = <FINAL>
         [
           visibilityToken2 = visibility()
           {
             if (!php5Enabled) {
               fireParseError("unexpected token " + visibilityToken.image, "", visibilityToken);
             }
             if (visibilityToken != null) {
               fireParseError("unexpected token " + visibilityToken2.image, "", visibilityToken2);
             }
           }
         ]
       ]
       method = MethodDeclaration(CONST_METHOD,visibilityToken)
       {
         //method.analyzeCode(this);
         classDeclaration.addMethod(method);
       }
     |
       method = abstractMethodDeclaration(CONST_METHOD,visibilityToken)
       {
         classDeclaration.addMethod(method);
       }
     )
  } catch (ParseException e) {
    fireParseError("unexpected token " + e.currentToken.image, "", e.currentToken);
  }
|
  fieldList  = FieldDeclaration()
  {
    if (fieldList != null) {
      for (int i = 0;i<fieldList.size();i++) {
        classDeclaration.addField((FieldDeclaration) fieldList.get(i));
      }
    }
  }
}

//}}}

//{{{ FieldDeclaration()

/**
 * A class field declaration : it's var VariableDeclarator() (, VariableDeclarator())*;.
 * it is only used by ClassBodyDeclaration()
 */
List FieldDeclaration() :
{
  VariableDeclaration variableDeclaration;
  final ArrayList arrayList = new ArrayList();
  final Token varToken;
  Token semicolonToken = null;
}
{
  varToken = <VAR>
  {
    if (php5Enabled) {
      fireParseMessage(new PHPParseMessageEvent(INFO,
                       PHPParseMessageEvent.MESSAGE_DEPRECATED_VAR_TOKEN,
                       path,
                       "The var token is deprecated in php 5",
                       token));
    }
  }
  try {
    variableDeclaration = VariableDeclaratorNoSuffix()
      {
        arrayList.add(new FieldDeclaration(path,
                                           variableDeclaration,
                                           currentSegment,
                                           variableDeclaration.getSourceStart(),
                                           variableDeclaration.getSourceEnd(),
                                           variableDeclaration.getBeginLine(),
                                           variableDeclaration.getEndLine(),
                                           variableDeclaration.getBeginColumn(),
                                           variableDeclaration.getEndColumn()));
      }
    } catch (ParseException e) {
      final Token semicolon = error_skipto(SEMICOLON);
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "variable expected",
                                            "variable",
                                            e.currentToken.next.image,
                                            varToken.sourceEnd,
                                            semicolon.sourceEnd,
                                            varToken.beginLine,
                                            semicolon.endLine,
                                            varToken.endColumn,
                                            semicolon.endColumn));
      return null;
  }

  (
    <COMMA> variableDeclaration = VariableDeclaratorNoSuffix()
      {
        arrayList.add(new FieldDeclaration(path,
                                           variableDeclaration,
                                           currentSegment,
                                           variableDeclaration.getSourceStart(),
                                           variableDeclaration.getSourceEnd(),
                                           variableDeclaration.getBeginLine(),
                                           variableDeclaration.getEndLine(),
                                           variableDeclaration.getBeginColumn(),
                                           variableDeclaration.getEndColumn()));
      }
  )*
  try {
    semicolonToken = <SEMICOLON>
  } catch (ParseException e) {
    fireParseError("';' expected", ";", e.currentToken);
  }

  {
    return arrayList;
  }
}

//}}}
//{{{ FieldDeclarationPHP5()
/**
 * A class field declaration : it's var VariableDeclarator() (, VariableDeclarator())*;.
 * it is only used by ClassBodyDeclaration()
 */
FieldDeclaration FieldDeclarationPHP5(Token visibilityToken) :
{
  VariableDeclaration variableDeclaration;
  Token semicolonToken = null;
  Token varToken = null;
  Token modifierToken = null;
  Token visibility2 = null;
  int start = -1;
  int beginLine = -1;
  int beginColumn = -1;
  int end,endLine,endColumn;
}
{
  {
    //{{{ if not php5 skipping to semicolon and fire parse error
    if (!php5Enabled) {
      final Token semicolon = error_skipto(SEMICOLON);
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "unexpected token "+varToken.image,
                                            "",
                                            semicolon.image,
                                            semicolon.sourceStart-1,
                                            semicolon.sourceStart,
                                            semicolon.beginLine,
                                            semicolon.beginLine,
                                            semicolon.beginColumn-1,
                                            semicolon.beginColumn));
      return null;
    } //}}}
  }
  [
    modifierToken = modifier()
    [
      visibility2 = visibility()
      {
        if (visibilityToken != null) {
          fireParseError(new PHPParseErrorEvent(ERROR,
                                                path,
                                                "unexpected token "+visibility2.image,
                                                "",
                                                visibility2.image,
                                                visibility2.sourceStart,
                                                visibility2.sourceEnd,
                                                visibility2.beginLine,
                                                visibility2.endLine,
                                                visibility2.endColumn,
                                                visibility2.endColumn));
        }
      }
    ]
    {
      //{{{
      if (visibilityToken != null) {
        modifierToken = visibilityToken;
      } else {
      }
      start       = modifierToken.sourceStart;
      beginLine   = modifierToken.beginLine;
      beginColumn = modifierToken.beginColumn;
      //}}}
    }
  ]
  try {
    variableDeclaration = VariableDeclaratorNoSuffix()
      {
        if (start == -1) {
          start       = variableDeclaration.getSourceStart();
          beginLine   = variableDeclaration.getBeginLine();
          beginColumn = variableDeclaration.getBeginColumn();
        }
        if (!php5Enabled && varToken == null) {
          fireParseError(new PHPParseErrorEvent(ERROR,
                                                path,
                                                "var token expected",
                                                "var",
                                                variableDeclaration.toStringExpression(),
                                                variableDeclaration.getSourceStart()-1,
                                                variableDeclaration.getSourceStart(),
                                                variableDeclaration.getBeginLine(),
                                                variableDeclaration.getBeginLine(),
                                                variableDeclaration.getBeginColumn()-1,
                                                variableDeclaration.getBeginColumn()));
        }
      }
    } catch (ParseException e) {
      start       = e.currentToken.sourceStart;
      beginLine   = e.currentToken.beginLine;
      beginColumn = e.currentToken.beginColumn;
      final Token semicolon = error_skipto(SEMICOLON);
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "variable expected",
                                            "variable",
                                            e.currentToken.next.image,
                                            varToken.sourceEnd,
                                            semicolon.sourceEnd,
                                            varToken.beginLine,
                                            semicolon.endLine,
                                            varToken.endColumn,
                                            semicolon.endColumn));
      return null;
  }
  try {
    semicolonToken = <SEMICOLON>
    {
      end       = semicolonToken.sourceEnd;
      endLine   = semicolonToken.endLine;
      endColumn = semicolonToken.endColumn;
    }
  } catch (ParseException e) {
    end       = e.currentToken.sourceEnd;
    endLine   = e.currentToken.endLine;
    endColumn = e.currentToken.endColumn;
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    int visibility = (visibilityToken == null) ? PUBLIC : visibilityToken.kind;
    return new FieldDeclaration(visibility,
                                path,
                                variableDeclaration,
                                currentSegment,
                                start,
                                end,
                                beginLine,
                                endLine,
                                beginColumn,
                                endColumn);
  }
}//}}}

//{{{ abstractMethodDeclaration(int type, Token visibility)
/**
 * A Method Declaration.
 * <b>function</b> MetodDeclarator() Block()
 *
 * @return a MethodDeclaration
 */
MethodDeclaration abstractMethodDeclaration(int type, Token visibility) :
{
  final MethodDeclaration functionDeclaration;
  final MethodHeader methodHeader;
  final Block block;
  final OutlineableWithChildren seg = currentSegment;
  final Token functionToken;
  Token abstractToken = null;
  Token visibility2 = null;
}
{
  abstractToken = <ABSTRACT>
  {
    //{{{ if not php5 fire parse error
    if (!php5Enabled) {
      final Token semicolon = error_skipto(SEMICOLON);
      fireParseError("unexpected token abstract", "", abstractToken);
      return null;
    } //}}}
  }
  [
    visibility2 = visibility()
    {
      if (visibility != null) {
        fireParseError("unexpected token : "+visibility2.image, "", visibility2);
      }
    }
  ]
  functionToken = <FUNCTION>
  methodHeader = methodHeader(functionToken,type)
  {
    functionDeclaration = new MethodDeclaration(currentSegment,methodHeader);
  }
  try {
    <SEMICOLON>
  } catch (ParseException e) {
      fireParseError("unexpected token : "+e.currentToken.image, ";", e.currentToken);
  }
  {
    return functionDeclaration;
  }
} //}}}



//{{{ modifier()
Token modifier() :
{
  Token modifierToken;
}
{
  modifierToken = <STATIC>    { return modifierToken; }
| modifierToken = <CONST>     { return modifierToken; }
} //}}}
//{{{ visibility()
Token visibility() :
{
  Token visibilityToken;
}
{
  visibilityToken = <PUBLIC>    { return visibilityToken; }
| visibilityToken = <PROTECTED> { return visibilityToken; }
| visibilityToken = <PRIVATE>   { return visibilityToken; }
} //}}}

//}}}

//{{{ Variables

//{{{ VariableDeclaratorNoSuffix()

/**
 * a strict variable declarator : there cannot be a suffix here.
 * It will be used by fields and formal parameters
 */
VariableDeclaration VariableDeclaratorNoSuffix() :
{
  final Token identifierToken, lbrace,rbrace;
  final Expression expr;
  Expression initializer = null;
  Token assignToken = null;
  final Token dollarToken;
  Variable variable = null;
}
{
  dollarToken = <DOLLAR>
  try {
    (
       identifierToken = <IDENTIFIER>
       {
         variable = new Variable(identifierToken.image,
                                 dollarToken.sourceStart,
                                 identifierToken.sourceEnd,
                                 dollarToken.beginLine,
                                 identifierToken.endLine,
                                 dollarToken.beginColumn,
                                 identifierToken.endColumn);
       }
       |
       lbrace = <LBRACE> expr = Expression() rbrace = <RBRACE>
       {
         variable = new Variable(expr,
                                 lbrace.sourceStart,
                                 rbrace.sourceEnd,
                                 lbrace.beginLine,
                                 rbrace.endLine,
                                 lbrace.beginColumn,
                                 rbrace.endColumn);
       }
    )
  } catch (ParseException e) {
    fireParseError("identifier expected", "", e.currentToken);
    variable = new Variable("",
                            e.currentToken.sourceStart,
                            e.currentToken.sourceEnd,
                            e.currentToken.beginLine,
                            e.currentToken.endLine,
                            e.currentToken.beginColumn,
                            e.currentToken.endColumn);
  }
  [
    assignToken = <ASSIGN>
    try {
      initializer = VariableInitializer()
    } catch (ParseException e) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "Literal expression expected in variable initializer",
                                            "literal",
                                            e.currentToken.image,
                                            assignToken.sourceEnd,
                                            assignToken.sourceEnd +1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
    }
  ]
  {
    setTypeFromScope(variable);
    if (assignToken == null) {
      return new VariableDeclaration(currentSegment,
                                     variable,
                                     variable.getSourceStart(),
                                     variable.getSourceEnd(),
                                     variable.getBeginLine(),
                                     variable.getEndLine(),
                                     variable.getBeginColumn(),
                                     variable.getEndColumn());
    }
    if (initializer == null) {
      return new VariableDeclaration(currentSegment,
                                     variable,
                                     null,
                                     "=",
                                     variable.getSourceStart(),
                                     assignToken.sourceEnd,
                                     variable.getBeginLine(),
                                     assignToken.endLine,
                                     variable.getBeginColumn(),
                                     assignToken.endColumn);
    }
    return new VariableDeclaration(currentSegment,
                                   variable,
                                   initializer,
                                   "=",
                                   variable.getSourceStart(),
                                   initializer.getSourceEnd(),
                                   variable.getBeginLine(),
                                   initializer.getEndLine(),
                                   variable.getBeginColumn(),
                                   initializer.getEndColumn());
    }
}

//}}}
//{{{ VariableDeclarator()

/**
 * this will be used by static statement
 */
VariableDeclaration VariableDeclarator() :
{
  final AbstractVariable variable;
  Expression initializer = null;
  Token assignToken = null;
}
{
  variable = VariableDeclaratorId()
  [
    assignToken = <ASSIGN>
    try {
      initializer = VariableInitializer()
    } catch (ParseException e) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "Literal expression expected in variable initializer",
                                            "literal",
                                            e.currentToken.image,
                                            token.sourceEnd,
                                            token.sourceEnd+1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
  }
  ]
  {
  if (assignToken == null) {
    return new VariableDeclaration(currentSegment,
                                   variable,
                                   variable.getSourceStart(),
                                   variable.getSourceEnd(),
                                   variable.getBeginLine(),
                                   variable.getEndLine(),
                                   variable.getBeginColumn(),
                                   variable.getEndColumn());
  }
  if (initializer == null) {
    return new VariableDeclaration(currentSegment,
                                   variable,
                                   null,
                                   "=",
                                   variable.getSourceStart(),
                                   assignToken.sourceEnd,
                                   variable.getBeginLine(),
                                   assignToken.endLine,
                                   variable.getBeginColumn(),
                                   assignToken.endColumn);
  }
  return new VariableDeclaration(currentSegment,
                                 variable,
                                 initializer,
                                 "=",
                                 variable.getSourceStart(),
                                 initializer.getSourceEnd(),
                                 variable.getBeginLine(),
                                 initializer.getEndLine(),
                                 variable.getBeginColumn(),
                                 initializer.getEndColumn());
  }
}

//}}}
//{{{ VariableDeclaratorId()

/**
 * A Variable name.
 * @return the variable name (with suffix)
 */
AbstractVariable VariableDeclaratorId() :
{
  AbstractVariable var;
}
{
  var = Variable()
  (
   var = VariableSuffix(var)
   )*
  {
    return var;
  }
}

//}}}
//{{{ Variable()

Variable Variable() :
{
  Variable variable;
  final Token dollarToken;
}
{
  dollarToken = <DOLLAR>
  try {
    variable = Var()
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "identifier expected",
                                          "identifier",
                                          e.currentToken.image,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.next.sourceStart,
                                          e.currentToken.endLine,
                                          e.currentToken.next.beginLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.next.beginColumn));
    variable = new  Variable("",
                             dollarToken.sourceStart,
                             e.currentToken.next.sourceStart,
                             dollarToken.beginLine,
                             e.currentToken.next.beginLine,
                             dollarToken.beginColumn,
                             e.currentToken.next.beginColumn);
  }
  {
    return variable;
  }
}

//}}}
//{{{ Var()

Variable Var() :
{
  Variable variable = null;
  final Token token, token2;
  final Expression expression;
}
{
  (
    token = <DOLLAR> variable = Var()
    {
      variable = new Variable(variable,
                              variable.getSourceStart(),
                              variable.getSourceEnd(),
                              variable.getBeginLine(),
                              variable.getEndLine(),
                              variable.getBeginColumn(),
                              variable.getBeginColumn());
    }
  |
    token = <LBRACE> expression = Expression() token2 = <RBRACE>
    {
      variable = new Variable(expression,
                              token.sourceStart,
                              token2.sourceEnd,
                              token.beginLine,
                              token2.endLine,
                              token.beginColumn,
                              token2.endColumn);
    }
  |
    token = <IDENTIFIER>
    {
      variable = new Variable(token.image,
                              token.sourceStart,
                              token.sourceEnd,
                              token.beginLine,
                              token.endLine,
                              token.beginColumn,
                              token.endColumn);
    }
  )
  {
    setTypeFromScope(variable);
    return variable;
  }
}

//}}}
//{{{ VariableInitializer()

Expression VariableInitializer() :
{
  final Expression expr;
  final Token token, token2;
}
{
  expr = Literal()
  {
    return expr;
  }
|
  token2 = <MINUS> (token = <INTEGER_LITERAL> | token = <FLOATING_POINT_LITERAL>)
  {
    return new PrefixedUnaryExpression(new NumberLiteral(Type.INTEGER,token),
                                       token2.kind,
                                       token2.sourceStart,
                                       token2.beginLine,
                                       token2.beginColumn);
  }
|
  token2 = <PLUS> (token = <INTEGER_LITERAL> | token = <FLOATING_POINT_LITERAL>)
  {
    return new PrefixedUnaryExpression(new NumberLiteral(Type.INTEGER,token),
                                       token2.kind,
                                       token2.sourceStart,
                                       token2.beginLine,
                                       token2.beginColumn);
  }
|
  expr = ArrayDeclarator()
  {
    return expr;
  }
|
  token = <IDENTIFIER>
  {
    return new ConstantIdentifier(token);
  }
}

//}}}


//}}}

//{{{ Arrays

//{{{ ArrayVariable()

ArrayVariableDeclaration ArrayVariable() :
{
final Expression expr,expr2;
final Token arrayAssignToken;
}
{
  expr = Expression()
  [
    arrayAssignToken = <ARRAYASSIGN> expr2 = Expression()
    {
      int sourceEnd,endLine,endColumn;
      if (expr2 == null) {
        sourceEnd = arrayAssignToken.sourceEnd;
        endLine   = arrayAssignToken.endLine;
        endColumn = arrayAssignToken.endColumn;
      } else {
        sourceEnd = expr2.getSourceEnd();
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }

      return new ArrayVariableDeclaration(expr,expr2,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);}
  ]
  {
    return new ArrayVariableDeclaration(expr,expr.getSourceEnd(),expr.getBeginLine(),expr.getEndLine(),expr.getBeginColumn(),expr.getEndColumn());
  }
}

//}}}
//{{{ ArrayInitializer()

ArrayVariableDeclaration[] ArrayInitializer() :
{
  ArrayVariableDeclaration expr;
  final ArrayList list = new ArrayList();
}
{
  <LPAREN>
    [
      expr = ArrayVariable()
      {list.add(expr);}
      ( LOOKAHEAD(2) <COMMA> expr = ArrayVariable()
        {
          list.add(expr);
        }
      )*
    ]
    [
      <COMMA> {list.add(null);}
    ]
  <RPAREN>
  {
    ArrayVariableDeclaration[] vars = new ArrayVariableDeclaration[list.size()];
    list.toArray(vars);
    return vars;
  }
}

//}}}


//}}}

//{{{ METHODS

//{{{ MethodDeclaration(int type, Token visibility)

/**
 * A Method Declaration.
 * <b>function</b> MetodDeclarator() Block()
 *
 * @return a MethodDeclaration
 */
MethodDeclaration MethodDeclaration(int type, Token visibility) :
{
  final MethodDeclaration functionDeclaration;
  final MethodHeader methodHeader;
  final Block block;
  final OutlineableWithChildren seg = currentSegment;
  final Token functionToken;
  Token visibility2 = null;
}
{
  functionToken = <FUNCTION>
  methodHeader = methodHeader(functionToken,type)
  {
    functionDeclaration = new MethodDeclaration(currentSegment,methodHeader);
    currentSegment = functionDeclaration;
    scope = new Scope();
    scopeStack.push(scope);
  }
  block = Block()
  {
    functionDeclaration.setStatements(block.getStatements());
    functionDeclaration.setBodyLineStart(block.getBeginLine());
    functionDeclaration.setBodyColumnStart(block.getBeginColumn());
    functionDeclaration.setBodyLineEnd(block.getEndLine());
    functionDeclaration.setBodyColumnEnd(block.getEndColumn());
    currentSegment = seg;
    scope = new Scope();
    scopeStack.push(scope);
    return functionDeclaration;
  }
}

//}}}
//{{{ methodHeader(int functionToken,int type)

/**
 * A MethodDeclarator.
 * [&] IDENTIFIER(parameters ...).
 *
 * @return a function description for the outline
 */
MethodHeader methodHeader(Token functionToken,int type) :
{
  Token reference = null;
  final ArrayList formalParameters = new ArrayList();
  final Token methodNameToken;
  Token visibilityToken = null;
  String identifierChar = SYNTAX_ERROR_CHAR;
}
{
  [reference = <BIT_AND>]
  {
    try {
      if (type == CONST_FUNCTION) {
        methodNameToken = functionIdentifier();
      } else {
        methodNameToken = methodIdentifier();
      }
      identifierChar = methodNameToken.image;
    } catch (ParseException e) {
      if (e.currentToken.next.kind == PHPParserConstants.LPAREN) {
        //{{{ Parse error
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "identifier expected",
                                              "identifier",
                                              e.currentToken.image,
                                              functionToken.sourceStart,
                                              e.currentToken.sourceStart,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.beginColumn-1,
                                              e.currentToken.endColumn)); //}}}
      } else {
        fireParseError("unexpected token","identifier",e.currentToken.next);
      }
    }
  }
  FormalParameters(formalParameters)
  {
    return new MethodHeader(path,
                            identifierChar,
                            reference != null,
                            formalParameters,
                            functionToken.sourceStart,
                            token.sourceEnd,
                            functionToken.beginLine,
                            token.endLine,
                            functionToken.beginColumn,
                            token.endColumn);
  }
}//}}}
//{{{ functionIdentifier()
/**
 * This is a function identifier.
 * It's not exactly the same as methodIdentifier since methods can use a lot of keywords for their names.
 *
 * @return an identifier for a function
 */
Token functionIdentifier() :
{
  Token methodIdentifier;
}
{
  methodIdentifier = <IDENTIFIER> { return methodIdentifier; }
} //}}}

//{{{ methodIdentifier()
/**
 * This is a method identifier.
 * It can returns a lot of keywords since those are allowed (but discouraged for method names).
 *
 * @return an identifier for a function
 */
 Token methodIdentifier() :
{
  Token methodIdentifier;
}
{
  (
      methodIdentifier = <IDENTIFIER>
    | methodIdentifier = <DEFINE>
    | methodIdentifier = <GOTO>
    | methodIdentifier = <NEW>
    | methodIdentifier = <SUPER>
    | methodIdentifier = <THIS>
    | methodIdentifier = <TRUE>
    | methodIdentifier = <FALSE>
    | methodIdentifier = <STRING>
    | methodIdentifier = <OBJECT>
    | methodIdentifier = <BOOL>
    | methodIdentifier = <BOOLEAN>
    | methodIdentifier = <REAL>
    | methodIdentifier = <DOUBLE>
    | methodIdentifier = <FLOAT>
    | methodIdentifier = <INT>
    | methodIdentifier = <INTEGER>
  )
  {
    return methodIdentifier;
  }
} //}}}

//{{{ constantIdentifier()
/**
 * This is a constant identifier.
 * It can returns a lot of keywords
 *
 * @return an identifier for a function
 */
 Token constantIdentifier() :
{
  Token constantIdentifier;
}
{
  (
      constantIdentifier = <IDENTIFIER>
    | constantIdentifier = <DEFINE>
    | constantIdentifier = <GOTO>
    | constantIdentifier = <SUPER>
    | constantIdentifier = <THIS>
    | constantIdentifier = <STRING>
    | constantIdentifier = <OBJECT>
    | constantIdentifier = <BOOL>
    | constantIdentifier = <BOOLEAN>
    | constantIdentifier = <REAL>
    | constantIdentifier = <DOUBLE>
    | constantIdentifier = <FLOAT>
    | constantIdentifier = <INT>
    | constantIdentifier = <INTEGER>
  )
  {
    return constantIdentifier;
  }
} //}}}

//{{{ FormalParameters(ArrayList parameters)

/**
 * FormalParameters follows method identifier.
 * (FormalParameter())
 */
void FormalParameters(ArrayList parameters) :
{
  FormalParameter var;
}
{
  try {
  <LPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  [
    var = FormalParameter()
    {parameters.add(var);}
      (
        <COMMA>
        try {
          var = FormalParameter()
          {parameters.add(var);}
        } catch (ParseException e) {
          fireParseError(new PHPParseErrorEvent(ERROR,
                                                path,
                                                "parameter expected",
                                                "parameter",
                                                e.currentToken.image,
                                                e.currentToken.sourceStart,
                                                e.currentToken.sourceEnd,
                                                e.currentToken.beginLine,
                                                e.currentToken.endLine,
                                                e.currentToken.endColumn,
                                                e.currentToken.endColumn+1));
        }
      )*
  ]
  try {
    <RPAREN>
  } catch (ParseException e) { //recup rparen si avant lbrace
      Token nextToken = getNextToken();
      while (nextToken.kind != EOF && nextToken.kind != RPAREN && nextToken.kind != LBRACE) {
        nextToken = getNextToken();
      }
      if (nextToken.kind == EOF) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected end of file",
                                              ")",
                                              e.currentToken.next.image,
                                              e.currentToken.sourceEnd,
                                              nextToken.sourceStart,
                                              e.currentToken.beginLine,
                                              nextToken.endLine,
                                              e.currentToken.endColumn,
                                              nextToken.endColumn));
      } else if (nextToken.kind == RPAREN) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected tokens",
                                              "",
                                              e.currentToken.next.image,
                                              e.currentToken.next.sourceEnd,
                                              nextToken.sourceStart,
                                              e.currentToken.next.beginLine,
                                              nextToken.beginLine,
                                              e.currentToken.next.endColumn+1,
                                              nextToken.beginColumn-1));
      } else {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                        path,
                                        "')' expected",
                                        ")",
                                        e.currentToken.next.image,
                                        e.currentToken.sourceEnd,
                                        nextToken.sourceStart,
                                        e.currentToken.beginLine,
                                        nextToken.endLine,
                                        e.currentToken.endColumn+1,
                                        nextToken.endColumn-1));
      }
  }
}

//}}}
//{{{ FormalParameter()

/**
 * A formal parameter.
 * $varname[=value] (,$varname[=value])
 */
FormalParameter FormalParameter() :
{
  final VariableDeclaration variableDeclaration;
  final FormalParameter parameter;
  Token bitAndToken = null;
}
{
  [<IDENTIFIER>]
  [bitAndToken = <BIT_AND>] variableDeclaration = VariableDeclaratorNoSuffix()
  {
    if (bitAndToken != null) {
      variableDeclaration.setReference(true,bitAndToken.sourceStart,bitAndToken.beginLine,bitAndToken.beginColumn);
    }
    Expression initialization = variableDeclaration.getInitialization();
    if (initialization == null) {
      parameter = new FormalParameter(variableDeclaration.getName(),
                                      bitAndToken != null,
                                      variableDeclaration.getSourceStart(),
                                      variableDeclaration.getSourceEnd(),
                                      variableDeclaration.getBeginLine(),
                                      variableDeclaration.getEndLine(),
                                      variableDeclaration.getBeginColumn(),
                                      variableDeclaration.getEndColumn());
    } else {
      parameter = new FormalParameter(variableDeclaration.getName(),
                                      bitAndToken != null,
                                      variableDeclaration.getInitialization().toStringExpression(),
                                      variableDeclaration.getSourceStart(),
                                      variableDeclaration.getSourceEnd(),
                                      variableDeclaration.getBeginLine(),
                                      variableDeclaration.getEndLine(),
                                      variableDeclaration.getBeginColumn(),
                                      variableDeclaration.getEndColumn());
    }
    return parameter;
  }
}

//}}}

//}}}

//{{{ Type()

ConstantIdentifier Type() :
{
  final Token token;
}
{
  (
    token = <STRING>
  | token = <BOOL>
  | token = <BOOLEAN>
  | token = <REAL>
  | token = <DOUBLE>
  | token = <FLOAT>
  | token = <INT>
  | token = <INTEGER>
  | token = <OBJECT>
  )
  {
    return new ConstantIdentifier(token);
  }
}

//}}}

//{{{ EXPRESSIONS

//{{{ Expression()
Expression Expression() :
{
  final Expression expr;
}
{
  expr = PrintExpression()   { return expr; }
| LOOKAHEAD(prefixedPrimaryExpression() AssignmentOperator())
  expr = assignment()
  {
    return expr;
  }
| try {
    expr = ConditionalExpression()
    { 
        return expr;
    }
  } catch (ParseException e) {
      //{{{ Parse Exception
      fireParseError(new PHPParseErrorEvent(ERROR,
                     path,
                     "expression expected",
                     "expression",
                     e.currentToken.image,
                     token.sourceEnd,
                     token.sourceEnd,
                     e.currentToken.beginLine,
                     e.currentToken.endLine,
                     e.currentToken.endColumn,
                     e.currentToken.endColumn)); //}}}
      return new DummyExpression(e.currentToken.sourceStart,
                                 e.currentToken.sourceEnd,
                                 e.currentToken.beginLine,
                                 e.currentToken.endLine,
                                 e.currentToken.beginColumn,
                                 e.currentToken.endColumn);
  }
} //}}}
//{{{ assignment()

Expression assignment() :
{
  final Expression expr,initializer;
  final Token assignOperator;
}
{
  expr           = prefixedPrimaryExpression()
  assignOperator = AssignmentOperator()
  initializer    = Expression()
  {
    return new Assignment(expr,
                          initializer,
                          assignOperator.kind,
                          expr.getSourceStart(),
                          initializer.getSourceEnd(),
                          expr.getBeginLine(),
                          initializer.getEndLine(),
                          expr.getBeginColumn(),
                          initializer.getEndColumn());
  }
} //}}}

//{{{ prefixedPrimaryExpression()

Expression prefixedPrimaryExpression() :
{
  Expression expr;
  Token prefixToken;
}
{
  prefixToken = <BANG> expr = prefixedPrimaryExpression()
  {
    return new PrefixedUnaryExpression(expr,PHPParserConstants.BANG,prefixToken.sourceStart,prefixToken.beginLine,prefixToken.beginColumn);
  }
|
  prefixToken = <AT> expr = prefixedPrimaryExpression()
  {
    return new PrefixedUnaryExpression(expr,PHPParserConstants.AT,prefixToken.sourceStart,prefixToken.beginLine,prefixToken.beginColumn);
  }
|
  prefixToken = <TILDE> expr = prefixedPrimaryExpression()
  {
    return new PrefixedUnaryExpression(expr,PHPParserConstants.TILDE,prefixToken.sourceStart,prefixToken.beginLine,prefixToken.beginColumn);
  }
|
  expr = PrimaryExpression()
  {return expr;}
} //}}}

//}}}
//{{{ AssignmentOperator()

/**
 * Any assignement operator.
 *
 * @return the assignement operator token
 */
Token AssignmentOperator() :
{
  final Token assignOperator;
}
{
  (
      assignOperator = <ASSIGN>
    | assignOperator = <STARASSIGN>
    | assignOperator = <SLASHASSIGN>
    | assignOperator = <REMASSIGN>
    | assignOperator = <PLUSASSIGN> 
    | assignOperator = <MINUSASSIGN>
    | assignOperator = <LSHIFTASSIGN>
    | assignOperator = <RSIGNEDSHIFTASSIGN>
    | assignOperator = <ANDASSIGN>
    | assignOperator = <XORASSIGN>
    | assignOperator = <ORASSIGN>
    | assignOperator = <DOTASSIGN>
    | assignOperator = <TILDEEQUAL>
  )
  {
    return assignOperator;
  }
}

//}}}
//{{{ ConditionalExpression()

Expression ConditionalExpression() :
{
  final Expression expr;
  Expression expr2 = null;
  Expression expr3 = null;
}
{
  expr = ConditionalOrExpression() [ <HOOK> expr2 = Expression() <COLON> expr3 = Expression() ]
{
  if (expr3 == null) {
    return expr;
  }
  ConditionalExpression conditionalExpression = new ConditionalExpression(expr,expr2,expr3);
  //conditionalExpression.analyzeCode(this);
  return conditionalExpression;
}
}

//}}}
//{{{ ConditionalOrExpression()

Expression ConditionalOrExpression() :
{
  Expression expr,expr2;
  int sourceEnd,endLine,endColumn;
  Token orToken;
}
{
  expr = ConditionalAndExpression()
  (
    (
        orToken = <OR_OR>
      | orToken = <_ORL>
      | orToken = <XOR>
    )
    expr2 = ConditionalAndExpression()
    {
      if (expr2 == null) {
        sourceEnd = orToken.sourceEnd;
        endLine   = orToken.endLine;
        endColumn = orToken.endColumn;
      } else {
        sourceEnd = expr2.getSourceEnd();
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,orToken.kind,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ ConditionalAndExpression()

Expression ConditionalAndExpression() :
{
  Expression expr,expr2;
  int sourceEnd,endLine,endColumn;
  Token andToken;
}
{
  expr = ConcatExpression()
  (
  (  andToken = <AND_AND>
   | andToken = <_ANDL>)
   expr2 = ConcatExpression()
   {
     if (expr2 == null) {
       sourceEnd = andToken.sourceEnd;
       endLine   = andToken.endLine;
       endColumn = andToken.endColumn;
     } else {
       sourceEnd = expr2.getSourceEnd();
       endLine   = expr2.getEndLine();
       endColumn = expr2.getEndColumn();
     }
     expr = new BinaryExpression(expr,expr2,andToken.kind,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
   }
  )*
  {return expr;}
}

//}}}
//{{{ ConcatExpression()

Expression ConcatExpression() :
{
  Expression expr,expr2;
  Token dotToken;
  int sourceEnd,endLine,endColumn;
}
{
  expr = InclusiveOrExpression()
  (
    dotToken = <DOT> expr2 = InclusiveOrExpression()
    {
      if (expr2 == null) {
        sourceEnd = dotToken.sourceEnd;
        endLine   = dotToken.endLine;
        endColumn = dotToken.endColumn;
      } else {
        sourceEnd = expr2.getSourceEnd();
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,PHPParserConstants.DOT,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ InclusiveOrExpression()

Expression InclusiveOrExpression() :
{
  Expression expr,expr2;
  Token bitOrToken;
  int sourceEnd,endLine,endColumn;
}
{
  expr = ExclusiveOrExpression()
  (
   bitOrToken = <BIT_OR> expr2 = ExclusiveOrExpression()
   {
     if (expr2 == null) {
       sourceEnd = bitOrToken.sourceEnd;
       endLine   = bitOrToken.endLine;
       endColumn = bitOrToken.endColumn;
     } else {
       sourceEnd = expr2.getSourceEnd();
       endLine   = expr2.getEndLine();
       endColumn = expr2.getEndColumn();
     }
     expr = new BinaryExpression(expr,expr2,PHPParserConstants.BIT_OR,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
   }
  )*
  {return expr;}
}

//}}}
//{{{ ExclusiveOrExpression()

Expression ExclusiveOrExpression() :
{
  Expression expr,expr2;
  Token bitXorToken;
  int sourceEnd,endLine,endColumn;
}
{
  expr = AndExpression()
  (
    bitXorToken = <BIT_XOR> expr2 = AndExpression()
    {
      if (expr2 == null) {
        sourceEnd = bitXorToken.sourceEnd;
        endLine   = bitXorToken.endLine;
        endColumn = bitXorToken.endColumn;
      } else {
        sourceEnd = expr2.getSourceEnd();
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,PHPParserConstants.BIT_XOR,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ AndExpression()

Expression AndExpression() :
{
  Expression expr,expr2;
  Token bitAndToken;
  int sourceEnd,endLine,endColumn;
}
{
  expr = EqualityExpression()
  (
    LOOKAHEAD(1)
    bitAndToken = <BIT_AND> expr2 = EqualityExpression()
    {
      if (expr2 == null) {
        sourceEnd = bitAndToken.sourceEnd;
        endLine   = bitAndToken.endLine;
        endColumn = bitAndToken.endColumn;
      } else {
        sourceEnd = expr2.getSourceEnd();
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,PHPParserConstants.BIT_AND,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ EqualityExpression()

Expression EqualityExpression() :
{
  Expression expr,expr2;
  Token token;
  int sourceEnd,endLine,endColumn;
}
{
  expr = instanceofExpression()
  (
  (   token = <EQUAL_EQUAL>
    | token = <DIF>
    | token = <NOT_EQUAL>
    | token = <BANGDOUBLEEQUAL>
    | token = <TRIPLEEQUAL>
  )
  try {
    expr2 = instanceofExpression()
  } catch (ParseException e) {
    if (errorMessage != null) {
      throw e;
    }
    expr2 = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
                                   token.sourceEnd +1,
                                   token.sourceEnd +1,
                                   token.beginLine,
                                   token.endLine,
                                   token.beginColumn,
                                   token.endColumn);
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          token.sourceEnd,
                                          token.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    if (expr2 == null) {
      sourceEnd = token.sourceEnd;
      endLine   = token.endLine;
      endColumn = token.endColumn;
    } else {
      sourceEnd = expr2.getSourceEnd();
      endLine   = expr2.getEndLine();
      endColumn = expr2.getEndColumn();
    }
    expr = new BinaryExpression(expr,expr2,token.kind,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
  }
  )*
  {return expr;}
} //}}}

//{{{ instanceofExpression()
Expression instanceofExpression() :
{
  Expression expr;
  Expression expr2 = null;
  int sourceEnd,endLine,endColumn;
}
{
  expr = RelationalExpression()
  [
    <INSTANCEOF>
    try {
      expr2 = ClassIdentifier()
    } catch (ParseException e) {
      fireParseError("string or object expected","string or object",e.currentToken.next);
    }
    {
      if (expr2 == null) {
        sourceEnd = token.sourceEnd;
        endLine   = token.endLine;
        endColumn = token.endColumn;
      } else {
        sourceEnd = expr2.getSourceEnd();
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,PHPParserConstants.INSTANCEOF,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  ]
  {
    return expr;
  }
} //}}}
//{{{ RelationalExpression()

Expression RelationalExpression() :
{
  Expression expr,expr2;
  int sourceEnd,endLine,endColumn;
  Token token;
}
{
  expr = ShiftExpression()
  (
  ( token = <LT>
  | token = <GT>
  | token = <LE>
  | token = <GE>)
   expr2 = ShiftExpression()
  {
    if (expr2 == null) {
      sourceEnd = token.sourceEnd;
      endLine   = token.endLine;
      endColumn = token.endColumn;
    } else {
      sourceEnd = expr2.getSourceEnd();
      endLine   = expr2.getEndLine();
      endColumn = expr2.getEndColumn();
    }
    expr = new BinaryExpression(expr,expr2,token.kind,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
  }
  )*
  {return expr;}
}

//}}}
//{{{ ShiftExpression()

Expression ShiftExpression() :
{
  Expression expr,expr2;
  int sourceEnd,endLine,endColumn;
  Token token;
}
{
  expr = AdditiveExpression()
  (
  ( token = <LSHIFT>
  | token = <RSIGNEDSHIFT>
  | token = <RUNSIGNEDSHIFT>)
  expr2 = AdditiveExpression()
  {
    if (expr2 == null) {
      sourceEnd = token.sourceEnd;
      endLine   = token.endLine;
      endColumn = token.endColumn;
    } else {
      sourceEnd = expr2.getSourceEnd();
      endLine   = expr2.getEndLine();
      endColumn = expr2.getEndColumn();
    }
    expr = new BinaryExpression(expr,expr2,token.kind,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
  }
  )*
  {return expr;}
}

//}}}
//{{{ AdditiveExpression()

Expression AdditiveExpression() :
{
  Expression expr,expr2;
  int sourceEnd,endLine,endColumn;
  Token token;
}
{
  expr = MultiplicativeExpression()
  (
    LOOKAHEAD(1)
     ( token = <PLUS>
     | token = <MINUS>
     )
   expr2 = MultiplicativeExpression()
  {
    if (expr2 == null) {
      sourceEnd = token.sourceEnd;
      endLine   = token.endLine;
      endColumn = token.endColumn;
    } else {
      sourceEnd = expr2.getSourceEnd();
      endLine   = expr2.getEndLine();
      endColumn = expr2.getEndColumn();
    }
    expr = new BinaryExpression(expr,expr2,token.kind,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
  }
   )*
  {return expr;}
}

//}}}
//{{{ MultiplicativeExpression()

Expression MultiplicativeExpression() :
{
  Expression expr,expr2;
  int sourceEnd,endLine,endColumn;
  Token token;
}
{
  try {
    expr = UnaryExpression()
  } catch (ParseException e) {
    if (errorMessage != null) throw e;
    errorMessage = "unexpected token '"+e.currentToken.next.image+'\'';
    errorStart = this.token.sourceStart;
    errorEnd   = this.token.sourceEnd;
    throw e;
  }
  (
   (  token = <STAR>
    | token = <SLASH>
    | token = <REMAINDER>)
    expr2 = UnaryExpression()
    {
      if (expr2 == null) {
        sourceEnd = token.sourceEnd;
        endLine   = token.endLine;
        endColumn = token.endColumn;
      } else {
        sourceEnd = expr2.getSourceEnd();
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,token.kind,expr.getSourceStart(),sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ UnaryExpression()

/**
 * An unary expression starting with @, & or nothing.
 *
 * @return the unary expression
 */
Expression UnaryExpression() :
{
  final Expression expr;
}
{
  try {
    expr = AtNotTildeUnaryExpression() {return expr;}
  } catch (ParseException e) {
    fireParseError("unexpected token : '"+e.currentToken.image+'\'', "", e.currentToken);
      Token nextToken = getNextToken();
      while (nextToken.kind != EOF && nextToken.kind != SEMICOLON) {
        nextToken = getNextToken();
      }
      if (nextToken.kind == EOF) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected end of file",
                                              ")",
                                              e.currentToken.next.image,
                                              e.currentToken.sourceEnd,
                                              nextToken.sourceStart,
                                              e.currentToken.beginLine,
                                              nextToken.endLine,
                                              e.currentToken.endColumn,
                                              nextToken.endColumn));
      } else {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "expression expected",
                                              ")",
                                              e.currentToken.next.image,
                                              e.currentToken.sourceEnd,
                                              nextToken.sourceStart,
                                              e.currentToken.beginLine,
                                              nextToken.endLine,
                                              e.currentToken.endColumn+1,
                                              nextToken.endColumn-1));
      }
      return null;
    /*



    getNextToken();
    return UnaryExpression();
    */
  }

}

//}}}
//{{{ AtNotTildeUnaryExpression()

Expression AtNotTildeUnaryExpression() :
{
  if (shouldStop) throw new ParsingAbortedError();
  final Expression expr;
  final Token token;
}
{
  token = <AT>
  expr = AtNotTildeUnaryExpression()
  {return new PrefixedUnaryExpression(expr,PHPParserConstants.AT,token.sourceStart,token.beginLine,token.beginColumn);}
|
  token = <TILDE>
  expr = AtNotTildeUnaryExpression()
  {return new PrefixedUnaryExpression(expr,PHPParserConstants.TILDE,token.sourceStart,token.beginLine,token.beginColumn);}
|
  token = <BANG>
  expr = AtNotUnaryExpression()
  {return new PrefixedUnaryExpression(expr,PHPParserConstants.BANG,token.sourceStart,token.beginLine,token.beginColumn);}
|
  expr = UnaryExpressionNoPrefix()
  {return expr;}
}

//}}}
//{{{ AtNotUnaryExpression()

/**
 * An expression prefixed (or not) by one or more @ and !.
 * @return the expression
 */
Expression AtNotUnaryExpression() :
{
  final Expression expr;
  final Token token;
}
{
  token = <AT>
  expr = AtNotUnaryExpression()
  {return new PrefixedUnaryExpression(expr,PHPParserConstants.AT,token.sourceStart,token.beginLine,token.beginColumn);}
|
  token = <BANG>
  expr = AtNotUnaryExpression()
  {return new PrefixedUnaryExpression(expr,PHPParserConstants.BANG,token.sourceStart,token.beginLine,token.beginColumn);}
|
  expr = UnaryExpressionNoPrefix()
  {return expr;}
}

//}}}
//{{{ UnaryExpressionNoPrefix()

Expression UnaryExpressionNoPrefix() :
{
  final Expression expr;
  final Token token;
}
{
  token = <PLUS> expr = AtNotTildeUnaryExpression()
  {
    return new PrefixedUnaryExpression(expr,
                                       PHPParserConstants.PLUS,
                                       token.sourceStart,
                                       token.beginLine,
                                       token.beginColumn);
  }
|
  token = <MINUS> expr = AtNotTildeUnaryExpression()
  {
    return new PrefixedUnaryExpression(expr,
                                       PHPParserConstants.MINUS,
                                       token.sourceStart,
                                       token.beginLine,
                                       token.beginColumn);
  }
|
  expr = PreIncDecExpression()
  {return expr;}
|
  expr = UnaryExpressionNotPlusMinus()
  {return expr;}
}

//}}}
//{{{ PreIncDecExpression()

Expression PreIncDecExpression() :
{
final Expression expr;
final Token token;
}
{
  (
      token = <PLUS_PLUS>
    |
      token = <MINUS_MINUS>
  )
  expr = PrimaryExpression()
  {
    return new PrefixedUnaryExpression(expr,
                                       token.kind,
                                       token.sourceStart,
                                       token.beginLine,
                                       token.beginColumn);
  }
}

//}}}
//{{{ UnaryExpressionNotPlusMinus()

Expression UnaryExpressionNotPlusMinus() :
{
  final Expression expr;
}
{
  LOOKAHEAD( <LPAREN> (Type() | <ARRAY>) <RPAREN> )
  expr = CastExpression()         {return expr;}
| expr = PostfixExpression()      {return expr;}
| expr = Literal()                {return expr;}
| <LPAREN> expr = Expression()
  try {
    <RPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')'n expected",
                                          ")",
                                          e.currentToken.image,
                                          expr.getSourceEnd(),
                                          expr.getSourceEnd()+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return expr;}
}

//}}}
//{{{ CastExpression()

CastExpression CastExpression() :
{
final ConstantIdentifier type;
final Expression expr;
final Token token,token1;
}
{
  token1 = <LPAREN>
  (
      type = Type()
    |
      token = <ARRAY> {type = new ConstantIdentifier(token);}
  )
  <RPAREN> expr = UnaryExpression()
  {return new CastExpression(type,
                             expr,
                             token1.sourceStart,
                             expr.getSourceEnd(),
                             token1.beginLine,
                             expr.getEndLine(),
                             token1.beginColumn,
                             expr.getEndColumn());}
}

//}}}
//{{{ PostfixExpression()

Expression PostfixExpression() :
{
  final Expression expr;
  Token token = null;
}
{
  expr = PrimaryExpression()
  [
      token = <PLUS_PLUS>
    |
      token = <MINUS_MINUS>
  ]
  {
    if (token == null) {
      return expr;
    }
    return new PostfixedUnaryExpression(expr,
                                        token.kind,
                                        token.sourceEnd,
                                        token.endLine,
                                        token.endColumn);
  }
}

//}}}
//{{{ PrimaryExpression()

Expression PrimaryExpression() :
{
  final Expression expr;
  Token token = null;
}
{
  [token = <BIT_AND>] expr = refPrimaryExpression(token)
  {return expr;}
|
  expr = ArrayDeclarator()   {return expr;}
| expr = ListExpression()    {return expr;}
| expr = IncludeExpression() {return expr;}
}

//}}}
//{{{ refPrimaryExpression(final Token reference)

Expression refPrimaryExpression(Token reference) :
{
  Expression expr;
  Expression expr2 = null;
  final Token identifier, newToken;
  Token staticClassAccess;
}
{
  (  
      identifier = constantIdentifier()
      {
          expr = new ConstantIdentifier(identifier);
      }
      (
          staticClassAccess = <STATICCLASSACCESS>
          try {
              expr2 = ClassIdentifier()
              {
                  expr2.setType(new Type(Type.OBJECT_INT,expr2.toString()));
                  expr = new ClassAccess(expr,expr2,PHPParserConstants.STATICCLASSACCESS,expr2.getSourceEnd(),expr2.getEndLine(),expr2.getEndColumn());
              }
          } catch (ParseException e) {
              expr = new ClassAccess(expr,null,PHPParserConstants.STATICCLASSACCESS,staticClassAccess.sourceEnd,staticClassAccess.endLine,staticClassAccess.endColumn);
              fireParseError(new PHPParseErrorEvent(ERROR,
                  path,
                  "identifier expected",
                  "identifier",
                  e.currentToken.image,
                  e.currentToken.sourceStart,
                  e.currentToken.sourceEnd,
                  e.currentToken.beginLine,
                  e.currentToken.endLine,
                  e.currentToken.endColumn,
                  e.currentToken.endColumn+1));
          }
      )*
      [ expr2 = Arguments(expr) ]
      {
          if (expr2 == null) {
              if (reference != null) {
                  fireParseError(new PHPParseErrorEvent(ERROR,
                      path,
                      "you cannot use a constant by reference",
                      "",
                      "&",
                      reference.sourceStart,
                      reference.sourceEnd,
                      reference.beginLine,
                      reference.endLine,
                      reference.endColumn,
                      reference.endColumn+1));
              }
          }
          else
          {
              expr = expr2;
          }
      }
      |
      expr = VariableDeclaratorId()  //todo use the reference parameter ...
      [ 
        expr = methodCall(expr) 
      ]
      |
      expr = instantiation(reference)
  )
  {
      return expr;
  }
}

//}}}

Expression methodCall(Expression expr):
{
}
{
    expr = Arguments(expr)
    [
        expr = classAccess(expr)
        //{{{ Parse error if not in PHP5
        {
            if (!php5Enabled) {
                Expression prefix = ((ClassAccess) expr).getPrefix();
                fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected token '->'",
                                              "",
                                              "->",
                                              prefix.getSourceEnd(),
                                              prefix.getSourceEnd()+2,
                                              prefix.getEndLine(),
                                              prefix.getEndLine(),
                                              prefix.getEndColumn(),
                                              prefix.getEndColumn()+2)); 
            }
        } //}}}
        
        [
            expr = VariableSuffix(expr)
        |
            expr = methodCall(expr)
        ]
        
    ]
    {
        return expr;
    }
}

//{{{ instantiation(Token reference)
Expression instantiation(Token reference) :
{
    Token newToken;
    Expression expr;
}
{
    newToken = <NEW>
  try {
      expr = ClassIdentifier()
      {
        expr.setType(new Type(Type.OBJECT_INT,expr.toString()));
      }
  } catch (ParseException e) {
      Token token = error_skipto(SEMICOLON);
      expr = new DummyExpression(newToken.sourceEnd,
                                 token.sourceStart,
                                 newToken.endLine,
                                 token.beginLine,
                                 newToken.endColumn,
                                 token.beginColumn);
      expr.setType(Type.OBJECT);
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "class identifier expected",
                                            "class identifier",
                                            newToken.next.image,
                                            newToken.sourceEnd,
                                            newToken.next.sourceStart,
                                            newToken.endLine,
                                            newToken.next.beginLine,
                                            newToken.endColumn,
                                            newToken.next.beginColumn));
  }
  {
    final int start, beginLine, beginColumn;
    if (reference == null) {
      start       = newToken.sourceStart;
      beginLine   = newToken.beginLine;
      beginColumn = newToken.beginColumn;
    } else {
      start       = reference.sourceStart;
      beginLine   = reference.beginLine;
      beginColumn = reference.beginColumn;
    }
    expr = new ClassInstantiation(expr,
                                  reference != null,
                                  start,
                                  beginLine,
                                  beginColumn);
  }
  [ expr = Arguments(expr) ]
  {
      return expr;
  }
} //}}}
//{{{ ArrayDeclarator()

/**
 * An array declarator.
 * array(vars)
 * @return an array
 */
ArrayInitializer ArrayDeclarator() :
{
  final ArrayVariableDeclaration[] vars;
  final Token token;
}
{
  token = <ARRAY> vars = ArrayInitializer()
  {return new ArrayInitializer(vars,
                               token.sourceStart,
                               this.token.sourceEnd,
                               token.beginLine,
                               this.token.endLine,
                               token.beginColumn,
                               this.token.endColumn);}
}

//}}}
//{{{ ClassIdentifier()

Expression ClassIdentifier():
{
  final Expression expr;
  final Token identifierToken;
}
{
  identifierToken = methodIdentifier() {return new ConstantIdentifier(identifierToken);}
| expr = VariableDeclaratorId()        {return expr;}
}

//}}}

//{{{ SUFFIXES
//{{{ VariableSuffix(Expression prefix)

/**
 * Used by VariableDeclaratorId
 */
AbstractVariable VariableSuffix(Expression prefix) :
{
  AbstractVariable abstractVariable;
}
{
  (
      abstractVariable = classAccess(prefix)
    |
      abstractVariable = arrayDeclarator(prefix)
  )
  {
    return abstractVariable;
  }
}

//}}}
//{{{ classAccess(Expression prefix)
ClassAccess classAccess(Expression prefix) :
{
  Token lbrace, rbrace, methodIdentifier, listToken;
  Expression expression;
}
{
  <CLASSACCESS>
  try {
    (
        lbrace = <LBRACE> expression = Expression() rbrace = <RBRACE>
        {
          expression = new Variable(expression,
                                    lbrace.sourceStart,
                                    rbrace.sourceEnd,
                                    lbrace.beginLine,
                                    rbrace.endLine,
                                    lbrace.beginColumn,
                                    rbrace.endColumn);
          setTypeFromScope((Variable) expression);
        }
      |
        methodIdentifier = methodIdentifier()
        {
          expression = new ConstantIdentifier(methodIdentifier);
        }
      |
        listToken = <LIST>
        {
            expression = new ConstantIdentifier(listToken);
        }
      |
        expression = Variable()
    )
  } catch (ParseException e) {
    fireParseError("expression expected", "expression", e.currentToken);
    expression = new DummyExpression(e.currentToken.sourceStart,
                                     e.currentToken.sourceEnd,
                                     e.currentToken.beginLine,
                                     e.currentToken.endLine,
                                     e.currentToken.endColumn,
                                     e.currentToken.beginColumn);
  }
  {
    return new ClassAccess(prefix,
                           expression,
                           PHPParserConstants.CLASSACCESS,
                           expression.getSourceEnd(),
                           expression.getEndLine(),
                           expression.getEndColumn());
  }
} //}}}
//{{{ arrayDeclarator(Expression prefix)
ArrayDeclarator arrayDeclarator(Expression prefix) :
{
  Token open;
  Token close = null;
  Expression expression = null;
  int sourceEnd,endLine,endColumn;
}
{
  (
    open = <LBRACKET>
    [ expression = arrayKey() ]
    try {
      close = <RBRACKET>
    } catch (ParseException e) {
      //{{{ fireParseError
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "']' expected",
                                            "]",
                                            e.currentToken.image,
                                            e.currentToken.sourceStart,
                                            e.currentToken.sourceEnd,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1)); //}}}
    }
  |
    open = <LBRACE>
    [ expression = arrayKey() ]
    try {
      close = <RBRACE>
    } catch (ParseException e) {
      //{{{ fireParseError
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "'}' expected",
                                            "}",
                                            e.currentToken.image,
                                            e.currentToken.sourceStart,
                                            e.currentToken.sourceEnd,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1)); //}}}
    }
  )
  {
    if (close == null) {
      if (expression == null) {
        sourceEnd = open.sourceEnd;
        endLine   = open.endLine;
        endColumn = open.endColumn;
      } else {
        sourceEnd = expression.getSourceEnd();
        endLine   = expression.getEndLine();
        endColumn = expression.getEndColumn();
      }
    } else {
      sourceEnd = open.sourceEnd;
      endLine   = open.endLine;
      endColumn = open.endColumn;
    }
    return new ArrayDeclarator(prefix,
                               expression,
                               sourceEnd,
                               endLine,
                               endColumn);
  }
} //}}}
//{{{ arrayKey()
/**
 * defines the key of an array.
 * @return the key of the array
 */
Expression arrayKey() :
{
  Expression expression;
}
{
  expression = Expression()       { return expression; }
} //}}}


//}}}

//{{{ LITERAL

//{{{ Literal()

Literal Literal() :
{
  final Token token;
  final StringLiteral stringLiteral;
}
{
  token = <INTEGER_LITERAL>         {return new NumberLiteral(Type.INTEGER,token);}
| token = <FLOATING_POINT_LITERAL>  {return new NumberLiteral(Type.INTEGER,token);}
| token = <STRING_LITERAL>          {return new StringLiteral(token);}
| token = <TRUE>                    {return new TrueLiteral(token);}
| token = <FALSE>                   {return new FalseLiteral(token);}
| token = <NULL>                    {return new NullLiteral(token);}
| stringLiteral = heredoc()         {return stringLiteral;}
| stringLiteral = evaluableString() {return stringLiteral;}
}

//}}}
//{{{ heredoc()

StringLiteral heredoc() :
{
  final Token heredocStart;
  Token startToken = null;
  Token endToken;
  String endImage;
}
{
  heredocStart = <HEREDOCSTARTTOKEN>
  try {
    startToken = <IDENTIFIER>
    {
      if(heredocStart.sourceEnd != startToken.sourceStart) {
        //{{{ Parse error
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected spaces",
                                              "",
                                              "",
                                              heredocStart.sourceEnd+1,
                                              startToken.sourceStart-1,
                                              startToken.beginLine,
                                              startToken.endLine,
                                              heredocStart.endColumn+1,
                                              startToken.beginColumn-1)); //}}}
      }
    }
  } catch (ParseException e) {
    //{{{ Parse error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "identifier expected",
                                          "identifier",
                                          e.currentToken.image,
                                          errorStart,
                                          errorEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
    return new StringLiteral("",
                             jj_input_stream.getBeginOffset(),
                             jj_input_stream.getBeginOffset()+1,
                             jj_input_stream.getBeginLine(),
                             jj_input_stream.getEndLine(),
                             jj_input_stream.getBeginColumn(),
                             jj_input_stream.getEndColumn());
  }
  {
  while (true) {
    endToken = getNextToken();
    // Ensure that the parser will stay in php mode even if there is a ?> in the string
    // todo : find another trick it's seems ugly
    token_source.SwitchTo(PHPParserTokenManager.PHPPARSING);
    if (endToken.kind == PHPParserConstants.EOF) {
      fireParseError("unexpected EOF","",endToken);
      break;
    }

    if (endToken.beginLine == startToken.beginLine) {
      fireParseError("unexpected token","identifier",endToken);
      continue;
    }
    if (endToken.beginColumn != 1) continue;
    endImage = (endToken.image.charAt(endToken.image.length()-1) == ';') ? endToken.image.substring(0,endToken.image.length()-2) : endToken.image;
    if (endImage.equals(startToken.image)) {
      break;
    }
  }

//  return new StringLiteral(jj_input_stream.getCurrentBuffer().substring(startToken.sourceEnd+1,endToken.sourceStart-1),
  return new StringLiteral("",
                           startToken.sourceEnd+1,
                           endToken.sourceStart-1,
                           startToken.beginLine,
                           endToken.endLine,
                           startToken.beginColumn,
                           endToken.endColumn);
  }
}

//}}}
//{{{ evaluableString()

              
StringLiteral evaluableString() :
{
  ArrayList list = new ArrayList();
  Token start,end;
}
{
  start = <DOUBLEQUOTE>
  (
   <DOLLARS>
        [token = <IDENTIFIER>
        {
          list.add(new Variable(token.image,
                                token.sourceStart,
                                token.sourceEnd,
                                token.beginLine,
                                token.endLine,
                                token.beginColumn,
                                token.endColumn));
        }
        |
         <LBRACE1>
         token = <ID>
         {
           list.add(new Variable(token.image,
                                token.sourceStart,
                                token.sourceEnd,
                                token.beginLine,
                                token.endLine,
                                token.beginColumn,
                                token.endColumn));
         }
         <RBRACE1>
         ]
   )*
  end = <DOUBLEQUOTE2>
  {
  AbstractVariable[] vars = new AbstractVariable[list.size()];
  list.toArray(vars);
  //return new StringLiteral(jj_input_stream.getCurrentBuffer().substring(start.sourceEnd,end.sourceStart),
  return new StringLiteral("",
                           start.sourceStart,
                           end.sourceEnd,
                           start.beginLine,
                           end.endLine,
                           start.beginColumn,
                           end.endColumn,
                           vars);
  }
}
  

  //}}}
//}}}
  
//{{{ Arguments(final Expression func)

FunctionCall Arguments(final Expression func) :
{
Expression[] args = null;
final Token rparen,lparen;
}
{
  lparen = <LPAREN> [ args = ArgumentList() ]
  try {
    rparen = <RPAREN>
    {
      return new FunctionCall(func,
                             args,
                             rparen.sourceEnd,
                             rparen.endLine,
                             rparen.endColumn);
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          errorStart,
                                          errorEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    final int sourceEnd, line, column;
    if (args == null || args.length == 0) {
      sourceEnd = lparen.sourceEnd+1;
      line = lparen.beginLine;
      column = lparen.beginColumn;
    } else {
      sourceEnd = args[args.length-1].getSourceEnd();
      line = args[args.length-1].getBeginLine();
      column = args[args.length-1].getBeginColumn();
    }

    return new FunctionCall(func,
                            args,
                            sourceEnd,
                            line,
                            column);  
  }
}

//}}}
//{{{ ArgumentList()

/**
 * An argument list is a list of arguments separated by comma :
 * argumentDeclaration() (, argumentDeclaration)*
 * @return an array of arguments
 */
Expression[] ArgumentList() :
{
Expression arg;
final ArrayList list = new ArrayList();
int pos;
Token token;
}
{
  arg = Expression()
  {
    list.add(arg);
    pos = arg.getSourceEnd();
  }
  ( token = <COMMA> {pos = token.sourceEnd;}
      try {
        arg = Expression()
        {
          list.add(arg);
          pos = arg.getSourceEnd();
        }
      } catch (ParseException e) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "expression expected",
                                              "expression",
                                              e.currentToken.image,
                                              pos,
                                              pos+1,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.endColumn,
                                              e.currentToken.endColumn+1));
      }
   )*
   {
   final Expression[] arguments = new Expression[list.size()];
   list.toArray(arguments);
   return arguments;}
}

//}}}
//{{{ StatementNoBreak()

/**
 * A Statement without break.
 * @return a statement
 */
Statement StatementNoBreak() :
{
  final Statement statement;
}
{
  (
      LOOKAHEAD(2)
      statement = expressionStatement()
    | LOOKAHEAD(2)
      statement = LabeledStatement()
    | statement = Block()
    | statement = EmptyStatement()
    | statement = SwitchStatement()
    | statement = IfStatement()
    | statement = WhileStatement()
    | statement = DoStatement()
    | statement = ForStatement()
    | statement = ForeachStatement()
    | statement = ContinueStatement()
    | statement = ReturnStatement()
    | statement = EchoStatement()
    | statement = StaticStatement()
    | statement = GlobalStatement()
    | statement = tryStatement()
    | statement = throwStatement()
    | statement = defineStatement() {currentSegment.add((Outlineable)statement);}
  )
  {
    return statement;
  }
}

//}}}

//{{{ TRY

//{{{ throwStatement()
ThrowStatement throwStatement() :
{
  Token throwToken;
  Expression expr;
  Token semicolonToken = null;
  int sourceEnd,endLine,endColumn;
}
{
  throwToken = <THROW>
  expr = Expression()
  try {
    semicolonToken = <SEMICOLON>
    {
      sourceEnd = semicolonToken.sourceEnd;
      endLine   = semicolonToken.endLine;
      endColumn = semicolonToken.endColumn;
    }
  } catch (ParseException e) {
      sourceEnd = e.currentToken.sourceEnd;
      endLine   = e.currentToken.endLine;
      endColumn = e.currentToken.endColumn;
      fireParseError("catch expected", "catch", e.currentToken);
  }
  {
    return new ThrowStatement(expr,
                              throwToken.sourceStart,
                              sourceEnd,
                              throwToken.beginLine,
                              endLine,
                              throwToken.beginColumn,
                              endColumn);
  }
} //}}}

//{{{ tryStatement()
TryStatement tryStatement() :
{
  Token tryToken;
  Block block;
  Catch catchClause;
  List catches = new ArrayList(5);
}
{
  tryToken = <TRY>
  block = Block()
  catchClause = catchClause()
  {
    catches.add(catchClause);
  }
  (
     catchClause = catchClause()
     {
       catches.add(catchClause);
     }
   )*
  {
    return new TryStatement(block,
                            catches,
                            tryToken.sourceStart,
                            catchClause.getSourceEnd(),
                            tryToken.beginLine,
                            catchClause.getEndLine(),
                            tryToken.beginColumn,
                            catchClause.getEndColumn());
  }
}//}}}
//{{{ catchClause()
Catch catchClause() :
{
  Token catchToken = null;
  Token catchedException;
  Token dollarToken;
  Token identifierToken;
  Block block;
  int start,beginLine,beginColumn;
  int startVar,beginLineVar,beginColumnVar;
  int endVar,endLineVar,endColumnVar;
  String identifierString = null;
  String catchedString = null;
}
{
  try {
    catchToken = <CATCH>
    {
      start       = catchToken.sourceStart;
      beginLine   = catchToken.beginLine;
      beginColumn = catchToken.beginColumn;
    }
  } catch (ParseException e) {
      start       = e.currentToken.sourceStart;
      beginLine   = e.currentToken.beginLine;
      beginColumn = e.currentToken.beginColumn;
      fireParseError("catch expected", "catch", e.currentToken);
  }
  try {
    <LPAREN>
  } catch (ParseException e) {
      fireParseError("'(' expected", "(", e.currentToken);
  }
  try {
    catchedException = <IDENTIFIER>
    {
      catchedString = catchedException.image;
    }
  } catch (ParseException e) {
    fireParseError("identifier expected", "identifier", e.currentToken);
  }
  try {
    dollarToken = <DOLLAR>
    {
      startVar       = dollarToken.sourceStart;
      beginLineVar   = dollarToken.beginLine;
      beginColumnVar = dollarToken.beginColumn;
    }
  } catch (ParseException e) {
    startVar       = e.currentToken.sourceStart;
    beginLineVar   = e.currentToken.beginLine;
    beginColumnVar = e.currentToken.beginColumn;
    fireParseError("$ expected", "$", e.currentToken);
  }
  try {
    identifierToken = <IDENTIFIER>
    {
      identifierString = identifierToken.image;
      endVar       = identifierToken.sourceStart;
      endLineVar   = identifierToken.beginLine;
      endColumnVar = identifierToken.beginColumn;
    }
  } catch (ParseException e) {
    endVar       = e.currentToken.sourceEnd;
    endLineVar   = e.currentToken.endLine;
    endColumnVar = e.currentToken.endColumn;
    fireParseError("identifier expected", "identifier", e.currentToken);
  }
  try {
    <RPAREN>
  } catch (ParseException e) {
      fireParseError("')' expected", ")", e.currentToken);
  }
  block = Block()
  {
    return new Catch(catchedString,
                     new Variable(identifierString,
                                  startVar,
                                  endVar,
                                  beginLineVar,
                                  endLineVar,
                                  beginColumnVar,
                                  endColumnVar),
                     block,
                     start,
                     block.getSourceEnd(),
                     beginLine,
                     block.getEndLine(),
                     beginColumn,
                     block.getEndColumn());
  }
} //}}}

//}}}


//{{{ expressionStatement()

/**
 * A statement expression.
 * expression ;
 * @return an expression
 */
Statement expressionStatement() :
{
  final Statement statement;
  Token token;
}
{
  try {
    statement = Expression()
  } catch (ParseException e) {
    token = error_skipto(SEMICOLON);
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          e.currentToken.sourceEnd,
                                          token.sourceEnd,
                                          e.currentToken.beginLine,
                                          token.endLine,
                                          e.currentToken.endColumn,
                                          token.beginColumn));
    return new EmptyStatement(e.currentToken.sourceStart,
                              token.sourceEnd,
                              e.currentToken.beginLine,
                              token.endLine,
                              e.currentToken.beginColumn,
                              token.endColumn);
  }
  try {
    token = <SEMICOLON>
    {
      statement.setSourceEnd(token.sourceEnd);
    }
  } catch (ParseException e) {
    if (e.currentToken.next.kind != PHPParserConstants.PHPEND) {
      //{{{ Parse Error
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "';' expected",
                                            ";",
                                            e.currentToken.image,
                                            statement.getSourceEnd(),
                                            statement.getSourceEnd()+1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1)); //}}}
    }
  }
  {return statement;}
}

//}}}
//{{{ defineStatement()

Define defineStatement() :
{
  Expression defineName,defineValue;
  final Token defineToken;
  Token token;
  int pos;
}
{
  defineToken = <DEFINE> {pos = defineToken.sourceEnd+1;}
  try {
    token = <LPAREN>
    {pos = token.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    defineName = Expression()
    {
      pos = defineName.getSourceEnd()+1;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    defineName = new StringLiteral(SYNTAX_ERROR_CHAR,pos,pos,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1);
  }
  try {
    token = <COMMA>
    {
      pos = defineName.getSourceEnd()+1;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "',' expected",
                                          ",",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    defineValue = Expression()
    {
      pos = defineValue.getSourceEnd()+1;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    defineValue = new StringLiteral(SYNTAX_ERROR_CHAR,pos,pos,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1);
  }
  try {
    token = <RPAREN>
    {pos = token.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    return new Define(currentSegment,
                      defineName,
                      defineValue,
                      defineToken.sourceStart,
                      pos,
                      defineToken.beginLine,
                      defineToken.endLine,
                      defineToken.beginColumn,
                      defineToken.endColumn);
  }
}

/**
 * A Normal statement.
 */
Statement Statement() :
{
  final Statement statement;
}
{
  (
    statement = StatementNoBreak()
  | 
    statement = BreakStatement()
  )
  {
    statement.getModifiedVariable(tempList);
    scope.addVariablesList(tempList);
    tempList.clear();
    return statement;
  }
}

//}}}
//{{{ htmlBlock()

/**
 * An html block inside a php syntax.
 */
HTMLBlock htmlBlock() :
{
  int startIndex = nodePtr;
  AstNode[] blockNodes;
  int nbNodes;
  Token phpEnd;
}
{
  phpEnd = <PHPEND>
  {
    htmlStart       = phpEnd.sourceEnd;
    htmlLineStart   = phpEnd.endLine;
    htmlColumnStart = phpEnd.endColumn;
  }
  (phpEchoBlock())*
  try {
    (<PHPSTARTLONG> | <PHPSTARTSHORT>)
    {createNewHTMLCode();}
  } catch (ParseException e) {
    fireParseError("'<?php' expected","<?php",e.currentToken);
  }
  {
    nbNodes = nodePtr - startIndex;
    if (nbNodes == 0) {
      return null;
    }
    blockNodes = new AstNode[nbNodes];
    System.arraycopy(nodes,startIndex+1,blockNodes,0,nbNodes);
    nodePtr         = startIndex;
    HTMLBlock block = new HTMLBlock(blockNodes);
    return block;
  }
}

//}}}
//{{{ IncludeExpression()

/**
 * An include statement. It's "include" an expression;
 */
InclusionExpression IncludeExpression() :
{
  Expression expr;
  InclusionExpression inclusionExpression;
  Token token;
  int end,line,column;
}
{
  (
     token = <REQUIRE>
   | token = <REQUIRE_ONCE>
   | token = <INCLUDE>
   | token = <INCLUDE_ONCE>
  )
  {
    end=token.sourceEnd;
    line=token.beginLine;
    column=token.beginColumn;
  }
  try {
    (
       expr = PrimaryExpression()
     | expr = Literal()
     | <LPAREN> expr = Expression()
       try {
         <RPAREN>
       } catch (ParseException e) {
         //{{{ Parse Error
         fireParseError(new PHPParseErrorEvent(ERROR,
                                               path,
                                               "')'n expected",
                                               ")",
                                               e.currentToken.image,
                                               expr.getSourceEnd(),
                                               expr.getSourceEnd()+1,
                                               e.currentToken.beginLine,
                                               e.currentToken.endLine,
                                               e.currentToken.endColumn,
                                               e.currentToken.endColumn+1)); //}}}
       }
    )

    {
      end    = expr.getSourceEnd();
      line   = expr.getBeginLine();
      column = expr.getBeginColumn();
    }
  } catch (ParseException e) {
    if (errorMessage != null) {
      throw e;
    }
    expr = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
                                  token.sourceEnd,
                                  token.sourceEnd+1,
                                  token.endLine,
                                  token.endLine,
                                  token.endColumn,
                                  token.endColumn+1);
    //{{{ Parse Error
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          e.currentToken.next.sourceStart,
                                          e.currentToken.next.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
  }
  {
   inclusionExpression = new InclusionExpression(currentSegment,
                                                 token.kind,
                                                 expr,
                                                 token.sourceStart,
                                                 end,
                                                 token.beginLine,
                                                 line,
                                                 token.beginColumn,
                                                 column);
   currentSegment.add(inclusionExpression);
   return inclusionExpression;
  }
}
//}}}
//{{{ PrintExpression()

PrintExpression PrintExpression() :
{
  final Expression expr;
  final Token printToken;
}
{
  printToken = <PRINT> expr = Expression()
  {
    return new PrintExpression(expr,printToken.sourceStart,expr.getSourceEnd(),printToken.beginLine,expr.getEndLine(),printToken.beginColumn,expr.getEndColumn());
  }
}

//}}}
//{{{ ListExpression()

ListExpression ListExpression() :
{
  Expression expr = null;
  final ArrayList list = new ArrayList();
  int pos,line,column;
  final Token listToken, rParen;
  Token token;
}
{
  listToken = <LIST> {pos = listToken.sourceEnd;line=listToken.beginLine;column=listToken.beginColumn;}
  try {
    token = <LPAREN> {pos = token.sourceEnd;line=token.beginLine;column=token.beginColumn;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          listToken.sourceEnd,
                                          listToken.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  [
    expr = VariableDeclaratorId()
    {list.add(expr);pos = expr.getSourceEnd();line=expr.getBeginLine();column=expr.getBeginColumn();}
  ]
  {if (expr == null) list.add(null);}
  (
    try {
      token = <COMMA>
      {pos = token.sourceEnd;line=token.beginLine;column=token.beginColumn;}
    } catch (ParseException e) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "',' expected",
                                            ",",
                                            e.currentToken.image,
                                            pos,
                                            pos+1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
    }
    [expr = VariableDeclaratorId() {list.add(expr);pos = expr.getSourceEnd();line=expr.getBeginLine();column=expr.getBeginColumn();}]
  )*
  try {
    rParen = <RPAREN>
    {pos = rParen.sourceEnd;line=rParen.beginLine;column=rParen.beginColumn;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    final AbstractVariable[] vars = new AbstractVariable[list.size()];
    list.toArray(vars);
    return new ListExpression(vars,
                              listToken.sourceStart,
                              pos,
                              listToken.beginLine,
                              line,
                              listToken.beginColumn,
                              column);}
}

//}}}

//}}}

//{{{ STATEMENTS

//{{{ EchoStatement()

/**
 * An echo statement.
 * echo anyexpression (, otherexpression)*
 */
EchoStatement EchoStatement() :
{
  final ArrayList expressions = new ArrayList();
  Expression expr;
  final Token echoToken;
  Token semicolonToken = null;
}
{
  echoToken = <ECHO> expr = Expression()
  {expressions.add(expr);}
  (
    <COMMA> expr = Expression()
    {expressions.add(expr);}
  )*
  try {
    semicolonToken = <SEMICOLON>
  } catch (ParseException e) {
    if (e.currentToken.next.kind != 4) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "';' expected",
                                            ";",
                                            e.currentToken.image,
                                            e.currentToken.sourceEnd,
                                            e.currentToken.sourceEnd+1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
    }
  }
  {
   final Expression[] exprs = new Expression[expressions.size()];
   expressions.toArray(exprs);
   if (semicolonToken == null) {
     return new EchoStatement(exprs,
                              echoToken.sourceStart,
                              exprs[exprs.length-1].getSourceEnd(),
                              echoToken.beginLine,
                              exprs[exprs.length-1].getEndLine(),
                              echoToken.beginColumn,
                              exprs[exprs.length-1].getEndColumn());
   }
   return new EchoStatement(exprs,
                            echoToken.sourceStart,
                            semicolonToken.sourceEnd,
                            echoToken.beginLine,
                            semicolonToken.endLine,
                            echoToken.beginColumn,
                            semicolonToken.endColumn);
   }
}

//}}}
//{{{ GlobalStatement()

GlobalStatement GlobalStatement() :
{
   Variable expr;
   final ArrayList vars = new ArrayList();
   final GlobalStatement global;
   final Token token, token2;
   int pos,line,column;
}
{
  token = <GLOBAL>
    expr = Variable()
    {vars.add(expr);pos = expr.getSourceEnd()+1;line=expr.getEndLine();column=expr.getEndColumn();}
  (<COMMA>
    expr = Variable()
    {vars.add(expr);pos = expr.getSourceEnd()+1;line=expr.getEndLine();column=expr.getEndColumn();}
  )*
  try {
    token2 = <SEMICOLON>
    {pos = token2.sourceEnd+1;line=token2.endLine;column=token2.endColumn;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
    {
      final Variable[] variables = new Variable[vars.size()];
      vars.toArray(variables);
      global = new GlobalStatement(currentSegment,
                                   variables,
                                   token.sourceStart,
                                   pos,
                                   token.beginLine,
                                   line,
                                   token.beginColumn,
                                   column);
      currentSegment.add(global);
      //global.analyzeCode(this);
      return global;
    }
}

//}}}
//{{{ StaticStatement()

StaticStatement StaticStatement() :
{
  final ArrayList vars = new ArrayList();
  VariableDeclaration expr;
  final Token token, token2;
  int pos,line,column;
}
{
  token = <STATIC> expr = VariableDeclarator() {vars.add(expr);pos = expr.getSourceEnd()+1;line=expr.getEndLine();column=expr.getEndColumn();}
  (
    <COMMA> expr = VariableDeclarator() {vars.add(expr);pos = expr.getSourceEnd()+1;line=expr.getEndLine();column=expr.getEndColumn();}
  )*
  try {
    token2 = <SEMICOLON>
    {pos = token2.sourceEnd+1;line=token2.endLine;column=token2.endColumn;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
    {
    final VariableDeclaration[] variables = new VariableDeclaration[vars.size()];
    vars.toArray(variables);
    return new StaticStatement(variables,
                               token.sourceStart,
                               pos,
                               token.beginLine,
                               line,
                               token.beginColumn,
                               column);}
}

//}}}
//{{{ LabeledStatement()

LabeledStatement LabeledStatement() :
{
  final Token label;
  Statement statement = null;
}
{
  label = <IDENTIFIER>
  try {
    <COLON>
  } catch (ParseException e) {
    //{{{ fireParseError
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "':' expected",
                                          ":",
                                          e.currentToken.image,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
  }
  try {
    statement = Statement()
  } catch (ParseException e) {
    //{{{ fireParseError
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "statement expected",
                                          "statement",
                                          e.currentToken.image,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
    return new LabeledStatement(label.image,
                                statement,
                                label.sourceStart,
                                e.currentToken.sourceEnd,
                                e.currentToken.beginLine,
                                statement.getEndLine(),
                                e.currentToken.beginColumn,
                                statement.getEndColumn());
  }
  {
    return new LabeledStatement(label.image,
                                statement,
                                label.sourceStart,
                                statement.getSourceEnd(),
                                label.beginLine,
                                statement.getEndLine(),
                                label.beginColumn,
                                statement.getEndColumn());
  }
}

//}}}
//{{{ Block()

/**
 * A Block is
 * {
 * statements
 * }.
 * @return a block
 */
Block Block() :
{
  final ArrayList list = new ArrayList();
  Statement statement;
  final Token lbrace, rbrace;
  int pos,endLine,endColumn;
  int start, beginLine, beginColumn;
}
{
  try {
    lbrace = <LBRACE>
    {
      pos         = lbrace.sourceEnd+1;
      start       = lbrace.sourceStart;
      beginLine   = lbrace.beginLine;
      beginColumn = lbrace.beginColumn;
      endLine     = lbrace.endLine;
      endColumn   = lbrace.endColumn;
    }
  } catch (ParseException e) {
    pos         = this.token.sourceEnd+1;
    start       = pos;
    beginLine   = this.token.endLine;
    beginColumn = this.token.endColumn;
    endLine     = this.token.endLine;
    endColumn   = this.token.endColumn;
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'{' expected",
                                          "{",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  ( statement = BlockStatement()
    {
      if (statement != null) {
        list.add(statement);
        pos         = statement.getSourceEnd()+1;
        endLine     = statement.getEndLine();
        endColumn   = statement.getEndColumn();
      }
    }
  | statement = htmlBlock()      
    {
      if (statement != null) {
        list.add(statement);
        pos       = statement.getSourceEnd()+1;
        endLine   = statement.getEndLine();
        endColumn = statement.getEndColumn();
      } else {
        pos       = this.token.sourceEnd+1;
        endLine   = this.token.endLine;
        endColumn = this.token.endColumn;
      }
    }
  )*
  try {
    rbrace = <RBRACE>
    {
      pos       = rbrace.sourceEnd+1;
      endLine   = rbrace.endLine;
      endColumn = rbrace.endColumn;
    }
  } catch (ParseException e) {
    fireParseError("'}' expected", "}", e.currentToken);
  }
  {
  final Statement[] statements = new Statement[list.size()];
  list.toArray(statements);
  return new Block(statements,
                   start,
                   pos,
                   beginLine,
                   endLine,
                   beginColumn,
                   endColumn);}
}

//}}}
//{{{ BlockStatement()

Statement BlockStatement() :
{
  Statement statement = null;
}
{
  (
  try {
    statement = Statement()
    {
      if (phpDocument == currentSegment) pushOnAstNodes(statement);
    }
  } catch (ParseException e) {
    final Token semicolumn = error_skipto(SEMICOLON);
    final Token nextToken = e.currentToken.next;
    if (nextToken == semicolumn) {
      //{{{ Parse Error
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "statement expected",
                                            "statement",
                                            nextToken.image,
                                            nextToken.sourceEnd,
                                            semicolumn.sourceStart,
                                            nextToken.endLine,
                                            semicolumn.beginLine,
                                            nextToken.endColumn,
                                            semicolumn.beginColumn)); //}}}
    } else {
      fireParseError("statement expected","statement",nextToken);
    }
  }
| 
    statement = ClassDeclaration()
| 
    statement = interfaceDeclaration()
| 
    statement = MethodDeclaration(CONST_FUNCTION,null)
    {
        if (phpDocument == currentSegment) pushOnAstNodes(statement);
        currentSegment.add((MethodDeclaration) statement);
        //((MethodDeclaration) statement).analyzeCode(this);
    }
  )
  {
      return statement;
  }
}

//}}}
//{{{ BlockStatementNoBreak()

/**
 * A Block statement that will not contain any 'break'
 */
Statement BlockStatementNoBreak() :
{
  Statement statement = null;
}
{
  (
      statement = StatementNoBreak()
      | 
      LOOKAHEAD(1)
      statement = ClassDeclaration()
      | 
      statement = MethodDeclaration(CONST_FUNCTION,null)
      {
          currentSegment.add((MethodDeclaration) statement);
          //((MethodDeclaration) statement).analyzeCode(this);
      }
  )
  {
      return statement;
  }
}

//}}}
//{{{ LocalVariableDeclaration()

/**
 * used only by ForInit()
 */
Expression[] LocalVariableDeclaration() :
{
  final ArrayList list = new ArrayList();
  Expression var;
}
{
  var = Expression()
  {list.add(var);}
  ( <COMMA> var = Expression() {list.add(var);})*
  {
    final Expression[] vars = new Expression[list.size()];
    list.toArray(vars);
    return vars;
  }
}

//}}}
//{{{ LocalVariableDeclarator()

/**
 * used only by LocalVariableDeclaration().
 */
VariableDeclaration LocalVariableDeclarator() :
{
  final Variable varName;
  Expression initializer = null;
}
{
  varName = Variable() [ <ASSIGN> initializer = Expression() ]
  {
   if (initializer == null) {
    return new VariableDeclaration(currentSegment,
                                   varName,
                                   varName.getSourceStart(),
                                   varName.getSourceEnd(),
                                   varName.getBeginLine(),
                                   varName.getEndLine(),
                                   varName.getBeginColumn(),
                                   varName.getEndColumn());
   }
    return new VariableDeclaration(currentSegment,
                                   varName,
                                   initializer,
                                   "=",
                                   varName.getSourceStart(),
                                   initializer.getSourceEnd(),
                                   varName.getBeginLine(),
                                   initializer.getEndLine(),
                                   varName.getBeginColumn(),
                                   initializer.getEndColumn());
  }
}

//}}}
//{{{ EmptyStatement()

/**
 * An empty statement.
 * It will generate an INFO marker
 *
 * @return an empty statement
 */
EmptyStatement EmptyStatement() :
{
  final Token token;
}
{
  token = <SEMICOLON>
  {
/*    fireParseMessage(new PHPParseMessageEvent(INFO,
                                              path,
                                              "unneeded ';'",
                                              token.sourceStart,
                                              token.sourceEnd,
                                              token.beginLine,
                                              token.endLine,
                                              token.endColumn,
                                              token.endColumn+1));   */
    return new EmptyStatement(token.sourceStart,
                              token.sourceEnd,
                              token.beginLine,
                              token.endLine,
                              token.beginColumn,
                              token.endColumn);
  }
}

//}}}
//{{{ StatementExpression()

/**
 * used only by StatementExpressionList() which is used only by ForInit() and ForStatement()
 */
Expression StatementExpression() :
{
  final Expression expr;
  final Token operator;
}
{
  expr = PreIncDecExpression() {return expr;}
|
  expr = PrimaryExpression()
  [ operator = <PLUS_PLUS> {return new PostfixedUnaryExpression(expr,
                                                                PHPParserConstants.PLUS_PLUS,
                                                                operator.sourceEnd,
                                                                operator.endLine,
                                                                operator.endColumn);}
  | operator = <MINUS_MINUS> {return new PostfixedUnaryExpression(expr,
                                                                  PHPParserConstants.MINUS_MINUS,
                                                                  operator.sourceEnd,
                                                                  operator.endLine,
                                                                  operator.endColumn);}
  ]
  {return expr;}
}

//}}}

//{{{ SWITCH
//{{{ SwitchStatement()

SwitchStatement SwitchStatement() :
{
  Expression variable;
  final AbstractCase[] cases;
  final Token switchToken,lparenToken,rparenToken;
  int pos;
}
{
  switchToken = <SWITCH> {pos = switchToken.sourceEnd+1;}
  try {
    lparenToken = <LPAREN>
    {pos = lparenToken.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    variable = Expression() 
    {
      pos = variable.getSourceEnd()+1;
    }
  } catch (ParseException e) {
    if (errorMessage != null) {
      throw e;
    }
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    variable = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
                                      pos,
                                      pos,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1);
  }
  try {
    rparenToken = <RPAREN> {pos = rparenToken.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  (  cases = switchStatementBrace()
   | cases = switchStatementColon(switchToken.sourceStart, switchToken.sourceEnd))
  {return new SwitchStatement(variable,
                              cases,
                              switchToken.sourceStart,
                              token.sourceEnd,
                              switchToken.beginLine,
                              token.endLine,
                              switchToken.beginColumn,
                              token.endColumn);}
}

//}}}
//{{{ switchStatementBrace()

AbstractCase[] switchStatementBrace() :
{
  AbstractCase cas;
  final ArrayList cases = new ArrayList();
  Token token;
  int pos;
}
{
  token = <LBRACE> 
  {
    pos = token.sourceEnd;
  }
 ( cas = switchLabel0() 
   {
     cases.add(cas);
     pos = cas.getSourceEnd();
   }
   )*
  try {
    token = <RBRACE>
    {pos = token.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'}' expected",
                                          "}",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    final AbstractCase[] abcase = new AbstractCase[cases.size()];
    cases.toArray(abcase);
    return abcase;
  }
}

//}}}
//{{{ switchStatementColon(final int start, final int end)

/**
 * A Switch statement with : ... endswitch;
 * @param start the begin offset of the switch
 * @param end the end offset of the switch
 */
AbstractCase[] switchStatementColon(final int start, final int end) :
{
  AbstractCase cas;
  final ArrayList cases = new ArrayList();
  Token token;
  int pos;
}
{
  token = <COLON> {pos = token.sourceEnd;}
  {
    fireParseMessage(new PHPParseMessageEvent(INFO,
                                              PHPParseMessageEvent.MESSAGE_SWITCH_ENDSWITCH_TAG,
                                              path,
                                              "Ugly syntax detected, you should switch () {...} instead of switch (): ... enswitch;",
                                              start,
                                              end,
                                              token.beginLine,
                                              token.endLine,
                                              token.beginColumn,
                                              token.endColumn));
  }
  ( cas = switchLabel0() 
    {
      cases.add(cas);
      pos = cas.getSourceEnd();
    }
      )*
  try {
    token = <ENDSWITCH> {pos = token.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'endswitch' expected",
                                          "endswitch",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    token = <SEMICOLON> {pos = token.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    final AbstractCase[] abcase = new AbstractCase[cases.size()];
    cases.toArray(abcase);
    return abcase;
  }
}

//}}}
//{{{ switchLabel0()

AbstractCase switchLabel0() :
{
  final Expression expr;
  Statement statement;
  final ArrayList stmts = new ArrayList();
  final int start = this.token.next.sourceStart;
}
{
  expr = SwitchLabel()
  ( statement = BlockStatementNoBreak() {stmts.add(statement);}
  | statement = htmlBlock()             {if (statement != null) {stmts.add(statement);}}
  | statement = BreakStatement()        {stmts.add(statement);})*
  //[ statement = BreakStatement()        {stmts.add(statement);}]
  {
    final int listSize = stmts.size();
    final Statement[] stmtsArray = new Statement[listSize];
    stmts.toArray(stmtsArray);
    if (expr == null) {//it's a default
      final int end = this.token.next.sourceStart;
      return new DefaultCase(stmtsArray,
                             start,
                             end,
                             this.token.next.beginLine,
                             this.token.next.endLine,
                             this.token.next.beginColumn,
                             this.token.next.endColumn);
    }
    if (listSize == 0) {
      return new Case(expr,
                      stmtsArray,
                      expr.getSourceStart(),
                      expr.getSourceEnd(),
                      expr.getBeginLine(),
                      expr.getEndLine(),
                      expr.getBeginColumn(),
                      expr.getEndColumn());
    } else {
      return new Case(expr,
                      stmtsArray,
                      expr.getSourceStart(),
                      stmtsArray[listSize-1].getSourceEnd(),
                      expr.getBeginLine(),
                      stmtsArray[listSize-1].getEndLine(),
                      expr.getBeginColumn(),
                      stmtsArray[listSize-1].getEndColumn());
    }
  }
}

//}}}
//{{{ SwitchLabel()

/**
 * A SwitchLabel.
 * case Expression() :
 * default :
 * @return the if it was a case and null if not
 */
Expression SwitchLabel() :
{
  final Expression expr;
  Token token;
}
{
  token = <CASE>
  try {
    expr = Expression()
  } catch (ParseException e) {
  //todo ameliorer ca
    if (errorMessage != null) throw e;
    errorMessage = "expression expected after 'case' keyword";
    errorStart = token.sourceEnd;
    errorEnd   = token.sourceEnd +1;
    throw e;
  }
  try {
    (
      token = <COLON>
    | token = <SEMICOLON>
      {
        fireParseMessage(new PHPParseMessageEvent(INFO,
                                                  PHPParseMessageEvent.MESSAGE_CASE_SEMICOLON,
                                                  path,
                                                  "a ; was found in a case statement. You should use :",
                                                  token));
      }
    )
  } catch (ParseException e) {
    //{{{ fireParseError
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "':' expected",
                                          ":",
                                          e.currentToken.image,
                                          expr.getSourceEnd(),
                                          expr.getSourceEnd()+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1)); //}}}
  }
  {return expr;}
|
  token = <_DEFAULT>
  try {
    <COLON>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "':' expected",
                                          ":",
                                          e.currentToken.image,
                                          token.sourceEnd,
                                          token.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return null;}
}

//}}}
//}}}

//{{{ BreakStatement()

Break BreakStatement() :
{
  Expression expression = null;
  final Token token, token2;
  int pos;
}
{
  token = <BREAK> {pos = token.sourceEnd+1;}
  [ expression = Expression() 
    {
      pos = expression.getSourceEnd()+1;
    }
  ]
  try {
    token2 = <SEMICOLON>
    {pos = token2.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return new Break(expression, token.sourceStart, pos,token.beginLine,token.endLine,token.beginColumn,token.endColumn);}
}

//}}}
//{{{ Condition(final String keyword)

Expression Condition(final String keyword) :
{
  final Expression condition;
}
{
  try {
    <LPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          token.sourceEnd,
                                          token.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  condition = Expression()
  try {
     <RPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          condition.getSourceEnd(),
                                          condition.getSourceEnd()+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return condition;}
}

//}}}

//{{{ IF
//{{{ IfStatement()

IfStatement IfStatement() :
{
  final Expression condition;
  final IfStatement ifStatement;
  final Token ifToken;
}
{
  ifToken = <IF> condition = Condition("if")
  ifStatement = IfStatement0(condition,ifToken)
  {return ifStatement;}
}

//}}}
//{{{ IfStatement0(Expression condition, Token ifToken)

  IfStatement IfStatement0(Expression condition, Token ifToken) :
{
  Statement statement = null;
  final Statement stmt;
  final Statement[] statementsArray;
  ElseIf elseifStatement;
  Else elseStatement = null;
  final ArrayList stmts;
  final ArrayList elseIfList = new ArrayList();
  final ElseIf[] elseIfs;
  final Token colonToken, elseToken;
  int sourceEnd = 0;
  int endColumn = 0;
  int endLine   = 0;
  Token semiColonToken;
}
{
  colonToken = <COLON>
  {
    stmts = new ArrayList();
  }
  (  statement = Statement()
     {
       stmts.add(statement);
     }
   | 
     statement = htmlBlock()
     {
       if (statement != null) stmts.add(statement);
     }
  )*
   (elseifStatement = ElseIfStatementColon() {elseIfList.add(elseifStatement);})*
   [elseStatement = ElseStatementColon()]

  {
      fireParseMessage(new PHPParseMessageEvent(INFO,
                                                PHPParseMessageEvent.MESSAGE_IF_ENDIF_TAG,
                                                path,
                                                "Ugly syntax detected, you should if () {...} instead of if (): ... endif;",
                                                colonToken));
  }
  try {
    <ENDIF>
  } catch (ParseException e) {
    errorMessage = "'endif' expected";
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
  try {
    semiColonToken = <SEMICOLON>
    {
      sourceEnd = semiColonToken.sourceStart;
      endLine   = semiColonToken.beginLine;
      endColumn = semiColonToken.beginColumn;
    }
  } catch (ParseException e) {
    sourceEnd = e.currentToken.sourceStart;
    endLine   = e.currentToken.beginLine;
    endColumn = e.currentToken.beginColumn;
    errorMessage = "';' expected after 'endif' keyword";
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
    {
    elseIfs = new ElseIf[elseIfList.size()];
    elseIfList.toArray(elseIfs);
    if (stmts.size() == 1) {
      return new IfStatement(condition,
                             (Statement) stmts.get(0),
                             elseIfs,
                             elseStatement,
                             ifToken.sourceStart,
                             sourceEnd,
                             ifToken.beginLine,
                             endLine,
                             ifToken.beginColumn,
                             endColumn);
    } else {
      statementsArray = new Statement[stmts.size()];
      stmts.toArray(statementsArray);
      return new IfStatement(condition,
                             new Block(statementsArray,
                                       colonToken.sourceEnd,
                                       sourceEnd,
                                       colonToken.endLine,
                                       endLine,
                                       colonToken.endColumn,
                                       endColumn),
                             elseIfs,
                             elseStatement,
                             ifToken.sourceStart,
                             sourceEnd,
                             ifToken.beginLine,
                             endLine,
                             ifToken.beginColumn,
                             endColumn);
    }
    }

|
  (stmt = Statement() | stmt = htmlBlock())
  ( LOOKAHEAD(1) elseifStatement = ElseIfStatement() {elseIfList.add(elseifStatement);})*
  [ LOOKAHEAD(1)
    elseToken = <ELSE>
    try {
      statement = Statement()
      {elseStatement = new Else(statement,
                                elseToken.sourceStart,
                                statement.getSourceEnd(),
                                elseToken.beginLine,
                                statement.getEndLine(),
                                elseToken.beginColumn,
                                statement.getEndColumn());}
    } catch (ParseException e) {
      if (errorMessage != null) {
        throw e;
      }
      errorMessage = "unexpected token '"+e.currentToken.next.image+"', a statement was expected";
      errorStart = e.currentToken.sourceStart;
      errorEnd   = e.currentToken.sourceEnd;
      throw e;
    }
  ]
  {
    elseIfs = new ElseIf[elseIfList.size()];
    elseIfList.toArray(elseIfs);
    return new IfStatement(condition,
                           stmt,
                           elseIfs,
                           elseStatement,
                             ifToken.sourceStart,
                             sourceEnd,
                             ifToken.beginLine,
                             endLine,
                             ifToken.beginColumn,
                             endColumn);
  }
}

//}}}
//{{{ ElseIfStatementColon()

ElseIf ElseIfStatementColon() :
{
  final Expression condition;
  Statement statement;
  final ArrayList list = new ArrayList();
  final Token elseifToken;
}
{
  elseifToken = <ELSEIF> condition = Condition("elseif")
  <COLON> (  statement = Statement() {list.add(statement);}
           | statement = htmlBlock() {if (statement != null) {list.add(statement);}})*
  {
  final int sizeList = list.size();
  final Statement[] stmtsArray = new Statement[sizeList];
  list.toArray(stmtsArray);
  return new ElseIf(condition,stmtsArray ,
                    elseifToken.sourceStart,
                    stmtsArray[sizeList-1].getSourceEnd(),
                    elseifToken.beginLine,
                    stmtsArray[sizeList-1].getEndLine(),
                    elseifToken.beginColumn,
                    stmtsArray[sizeList-1].getEndColumn());}
}

//}}}
//{{{ ElseStatementColon()

Else ElseStatementColon() :
{
  Statement statement;
  final ArrayList list = new ArrayList();
  final Token elseToken;
}
{
  elseToken = <ELSE> <COLON> (  statement = Statement() {list.add(statement);}
                  | statement = htmlBlock() {if (statement != null) {list.add(statement);}})*
  {
  final int sizeList = list.size();
  final Statement[] stmtsArray = new Statement[sizeList];
  list.toArray(stmtsArray);
  return new Else(stmtsArray,
                  elseToken.sourceStart,
                  stmtsArray[sizeList-1].getSourceEnd(),
                  elseToken.beginLine,
                  stmtsArray[sizeList-1].getEndLine(),
                  elseToken.beginColumn,
                  stmtsArray[sizeList-1].getEndColumn());}
}

//}}}
//{{{ ElseIfStatement()

ElseIf ElseIfStatement() :
{
  final Expression condition;
  //final Statement statement;
  final Token elseifToken;
  final Statement[] statement = new Statement[1];
}
{
  elseifToken = <ELSEIF> condition = Condition("elseif") statement[0] = Statement()
  {
  return new ElseIf(condition,
                    statement,
                    elseifToken.sourceStart,
                    statement[0].getSourceEnd(),
                    elseifToken.beginLine,
                    statement[0].getEndLine(),
                    elseifToken.beginColumn,
                    statement[0].getEndColumn());}
}

//}}}
//}}}

//{{{ WHILE
//{{{ WhileStatement()

WhileStatement WhileStatement() :
{
  final Expression condition;
  final Statement action;
  final Token whileToken;
}
{
  whileToken = <WHILE>
    condition = Condition("while")
    action    = WhileStatementAction(whileToken)
    {
      return new WhileStatement(condition,
                               action,
                               whileToken.sourceStart,
                               action.getSourceEnd(),
                               whileToken.beginLine,
                               action.getEndLine(),
                               whileToken.beginColumn,
                               action.getEndColumn());
    }
}

//}}}
//{{{ WhileStatementAction(Token whileToken)

Statement WhileStatementAction(Token whileToken) :
{
  Statement statement;
  final ArrayList stmts = new ArrayList();
  final Token colonToken;
  int end       = 0;
  int endLine   = 0;
  int endColumn = 0;
  Token semicolonToken;
}
{
  colonToken = <COLON> 
  (
    statement = Statement() 
    {
      stmts.add(statement);
    }
  )*
  {
    fireParseMessage(new PHPParseMessageEvent(INFO,
                                              PHPParseMessageEvent.MESSAGE_WHILE_ENDWHILE_TAG,
                                              path,
                                              "Ugly syntax detected, you should while () {...} instead of while (): ... endwhile;",
                                              colonToken));
  }
  try {
    <ENDWHILE>
  } catch (ParseException e) {
    errorMessage = "'endwhile' expected";
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
  try {
    semicolonToken = <SEMICOLON>
    {
      end       = semicolonToken.sourceEnd;
      endLine   = semicolonToken.beginLine;
      endColumn = semicolonToken.beginColumn;
      final Statement[] stmtsArray = new Statement[stmts.size()];
      stmts.toArray(stmtsArray);
      return new Block(stmtsArray,
                       whileToken.sourceStart,
                       end,
                       whileToken.beginLine,
                       endLine,
                       whileToken.beginColumn,
                       endColumn);
    }
  } catch (ParseException e) {
    errorMessage = "';' expected after 'endwhile' keyword";
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
|
  statement = Statement()
  {
    return statement;
  }
}

//}}}
//}}}

//{{{ DoStatement()

DoStatement DoStatement() :
{
  final Statement action;
  final Expression condition;
  final Token token;
  Token token2 = null;
}
{
  token = <DO> action = Statement() <WHILE> condition = Condition("while")
  try {
    token2 = <SEMICOLON>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          condition.getSourceEnd(),
                                          condition.getSourceEnd()+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    if (token2 == null) {
      return new DoStatement(condition,
                             action,
                             token.sourceStart,
                             condition.getSourceEnd(),
                             token.beginLine,
                             condition.getEndLine(),
                             token.beginColumn,
                             condition.getEndColumn());
    }
    return new DoStatement(condition,
                           action,
                           token.sourceStart,
                           token2.sourceEnd,
                             token.beginLine,
                             token2.endLine,
                             token.beginColumn,
                             token2.endColumn);
  }
}

//}}}

//{{{ ForeachStatement()

ForeachStatement ForeachStatement() :
{
  Statement statement = null;
  Expression expression = null;
  ArrayVariableDeclaration variable = null;
  final Token foreachToken;
  Token lparenToken = null;
  Token asToken = null;
  Token rparenToken = null;
  int pos,endLine,endColumn;
  final Token tokenEndForeach, tokenColon, tokenSemicolon;
  Statement action;
  final ArrayList list = new ArrayList();
}
{
  foreachToken = <FOREACH>
  try {
    lparenToken = <LPAREN>
    {
      pos       = lparenToken.sourceEnd+1;
      endLine   = lparenToken.endLine;
      endColumn = lparenToken.endColumn;
    }
  } catch (ParseException e) {
    fireParseError("'(' expected", "(", e.currentToken);
    {
      pos       = foreachToken.sourceEnd+1;
      endLine   = foreachToken.endLine;
      endColumn = foreachToken.endColumn;
    }
  }
  try {
    expression = Expression()
    {
      pos       = expression.getSourceEnd()+1;
      endLine   = expression.getEndLine();
      endColumn = expression.getEndColumn();
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "variable expected",
                                          "variable",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    asToken = <AS>
    {
      pos       = asToken.sourceEnd+1;
      endLine   = asToken.endLine;
      endColumn = asToken.endColumn;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'as' expected",
                                          "as",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    variable = ArrayVariable()
    {
      pos       = variable.getSourceEnd()+1;
      endLine   = variable.getEndLine();
      endColumn = variable.getEndColumn();
    }
  } catch (ParseException e) {
    if (errorMessage != null) throw e;
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "variable expected",
                                          "variable",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    rparenToken = <RPAREN>
    {
      pos       = rparenToken.sourceEnd+1;
      endLine   = rparenToken.endLine;
      endColumn = rparenToken.endColumn;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  (
  try {
    statement = Statement()
    {
      pos       = statement.getSourceEnd()+1;
      endLine   = statement.getEndLine();
      endColumn = statement.getEndColumn();
    }
  } catch (ParseException e) {
    if (errorMessage != null) throw e;
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "statement expected",
                                          "statement",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
   return new ForeachStatement(expression,
                               variable,
                               statement,
                               foreachToken.sourceStart,
                               pos,
                               foreachToken.beginLine,
                               endLine,
                               foreachToken.beginColumn,
                               endColumn);
 }
 |
 tokenColon = <COLON> 
 {
   pos = tokenColon.sourceEnd+1;
 }
 (
   action = Statement() 
   {
     list.add(action);
     pos = action.getSourceEnd()+1;
   }
   | 
   statement = htmlBlock()
   {
     if (statement != null) list.add(statement);
   }
   )*
   {
     fireParseMessage(new PHPParseMessageEvent(INFO,
                                               PHPParseMessageEvent.MESSAGE_FOREACH_ENDFOREACH_TAG,
                                               path,
                                               "Ugly syntax detected, you should foreach () {...} instead of foreach (): ... endforeach;",
                                               tokenColon));
   }
   try {
     tokenEndForeach = <ENDFOREACH>
     {pos = tokenEndForeach.sourceEnd+1;}
   } catch (ParseException e) {
     fireParseError(new PHPParseErrorEvent(ERROR,
                                           path,
                                           "'endforeach' expected",
                                           "endforeach",
                                           e.currentToken.image,
                                           pos,
                                           pos+1,
                                           e.currentToken.beginLine,
                                           e.currentToken.endLine,
                                           e.currentToken.endColumn,
                                           e.currentToken.endColumn+1));
   }
   try {
     tokenSemicolon = <SEMICOLON>
     {pos = tokenSemicolon.sourceEnd+1;}
   } catch (ParseException e) {
     fireParseError(new PHPParseErrorEvent(ERROR,
                                           path,
                                           "';' expected",
                                           ";",
                                           e.currentToken.image,
                                           pos,
                                           pos+1,
                                           e.currentToken.beginLine,
                                           e.currentToken.endLine,
                                           e.currentToken.endColumn,
                                           e.currentToken.endColumn+1));
   }
   {
     if (list.size() == 0) {
       return new ForeachStatement(expression,
                                    variable,
                                    null,
                                    foreachToken.sourceStart,
                                    pos,
                                    foreachToken.beginLine,
                                    endLine,
                                    foreachToken.beginColumn,
                                    endColumn);
     } else {
       final Statement[] stmtsArray = new Statement[list.size()];
       list.toArray(stmtsArray);
       return new ForeachStatement(expression,
                                    variable,
                                    new Block(stmtsArray,
                                             stmtsArray[0].getSourceStart(),
                                             stmtsArray[stmtsArray.length-1].getSourceEnd(),
                                             stmtsArray[0].getBeginLine(),
                                             stmtsArray[stmtsArray.length-1].getEndLine(),
                                             stmtsArray[0].getBeginColumn(),
                                             stmtsArray[stmtsArray.length-1].getEndColumn()),
                                    foreachToken.sourceStart,
                                    pos,
                                    foreachToken.beginLine,
                                    endLine,
                                    foreachToken.beginColumn,
                                    endColumn);
     }
   }
   )
}

//}}}

//{{{ FOR
//{{{ ForStatement()

/**
 * a for declaration.
 * @return a node representing the for statement
 */
ForStatement ForStatement() :
{
  final Token forToken,tokenEndFor,token2,tokenColon;
  int pos;
  Expression[] initializations = null;
  Expression condition = null;
  Expression[] increments = null;
  Statement action;
  final ArrayList list = new ArrayList();
  int end       = 0;
  int endLine   = 0;
  int endColumn = 0;
}
{
  forToken = <FOR>
  try {
    <LPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          forToken.sourceEnd,
                                          forToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn));
  }
     [ initializations = ForInit() ] <SEMICOLON>
     [ condition = Expression() ] <SEMICOLON>
     [ increments = StatementExpressionList() ] <RPAREN>
    (
      action = Statement()
      {
        return new ForStatement(initializations,
                                condition,
                                increments,
                                action,
                                forToken.sourceStart,
                                action.getSourceEnd(),
                                forToken.beginLine,
                                action.getEndLine(),
                                forToken.beginColumn,
                                action.getEndColumn());
      }
    |
      tokenColon = <COLON> 
      {
        pos = tokenColon.sourceEnd+1;
      }
      (
        action = Statement() 
        {
          list.add(action);
          pos = action.getSourceEnd()+1;
        }
      )*
      {
        fireParseMessage(new PHPParseMessageEvent(INFO,
                                                  PHPParseMessageEvent.MESSAGE_FOR_ENDFOR_TAG,
                                                  path,
                                                  "Ugly syntax detected, you should for () {...} instead of for (): ... endfor;",
                                                  tokenColon));
      }
      try {
        tokenEndFor = <ENDFOR>
        {
          pos = tokenEndFor.sourceEnd+1;
        }
      } catch (ParseException e) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "'endfor' expected",
                                              "endfor",
                                              e.currentToken.image,
                                              pos,
                                              pos,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.endColumn,
                                              e.currentToken.endColumn));
      }
      try {
        token2 = <SEMICOLON>
        {
          pos = token2.sourceEnd+1;
          end       = token2.sourceEnd;
          endLine   = token2.endLine;
          endColumn = token2.endColumn;
        }
      } catch (ParseException e) {
        end       = e.currentToken.sourceEnd;
        endLine   = e.currentToken.endLine;
        endColumn = e.currentToken.endColumn;
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "';' expected",
                                              ";",
                                              e.currentToken.image,
                                              pos,
                                              pos+1,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.endColumn,
                                              e.currentToken.endColumn+1));
      }
      {
        final Statement[] stmtsArray = new Statement[list.size()];
        list.toArray(stmtsArray);
        return new ForStatement(initializations,
                                condition,
                                increments,
                                new Block(stmtsArray,
                                          stmtsArray[0].getSourceStart(),
                                          stmtsArray[stmtsArray.length-1].getSourceEnd(),
                                          stmtsArray[0].getBeginLine(),
                                          stmtsArray[stmtsArray.length-1].getEndLine(),
                                          stmtsArray[0].getBeginColumn(),
                                          stmtsArray[stmtsArray.length-1].getEndColumn()),
                                forToken.sourceStart,
                                end,
                                forToken.beginLine,
                                endLine,
                                forToken.beginColumn,
                                endColumn);
      }
    )
}

//}}}
//{{{ ForInit()

Expression[] ForInit() :
{
  final Expression[] exprs;
}
{
  LOOKAHEAD(LocalVariableDeclaration())
  exprs = LocalVariableDeclaration()
  {return exprs;}
|
  exprs = StatementExpressionList()
  {return exprs;}
}

//}}}
//}}}

//{{{ StatementExpressionList()

Expression[] StatementExpressionList() :
{
  final ArrayList list = new ArrayList();
  final Expression expr;
}
{
  expr = Expression()   {list.add(expr);} (<COMMA> Expression() {list.add(expr);})*
  {
    final Expression[] exprsArray = new Expression[list.size()];
    list.toArray(exprsArray);
    return exprsArray;
  }
}

//}}}
//{{{ ContinueStatement()

Continue ContinueStatement() :
{
  Expression expr = null;
  final Token continueToken;
  Token semicolonToken = null;
}
{
  continueToken = <CONTINUE> [ expr = Expression() ]
  try {
    semicolonToken = <SEMICOLON>
  } catch (ParseException e) {
    final int errorStart, errorEnd;
    if (expr == null) {
      errorStart = continueToken.sourceEnd;
      errorEnd   = errorStart+1;
    } else {
      errorStart = expr.getSourceEnd();
      errorEnd   = errorStart+1;
    }
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          errorStart,
                                          errorEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    if (semicolonToken == null) {
      if (expr == null) {
        return new Continue(expr,continueToken.sourceStart,continueToken.sourceEnd,continueToken.beginLine,continueToken.endLine,continueToken.beginColumn,continueToken.endColumn);
      }
      return new Continue(expr,continueToken.sourceStart,expr.getSourceEnd(),continueToken.beginLine,expr.getEndLine(),continueToken.beginColumn,expr.getEndColumn());
    }
    return new Continue(expr,continueToken.sourceStart,semicolonToken.sourceEnd,continueToken.beginLine,semicolonToken.endLine,continueToken.beginColumn,semicolonToken.endColumn);
  }
}

//}}}
//{{{ ReturnStatement()

/**
 * A return statement.
 * It's return [expression];
 * @return a ReturnStatement
 */
ReturnStatement ReturnStatement() :
{
  Statement expr = null;
  final Token returnToken;
  Token semicolonToken = null;
  int end       = 0;
  int endLine   = 0;
  int endColumn = 0;
}
{
  returnToken = <RETURN>
  [ 
    expr = Expression()
    {
      end       = expr.getSourceEnd();
      endLine   = expr.getEndLine();
      endColumn = expr.getEndColumn();
    }
  ]
  try {
    semicolonToken = <SEMICOLON>
    {
      end       = semicolonToken.sourceEnd;
      endLine   = semicolonToken.endLine;
      endColumn = semicolonToken.endColumn;
    }
  } catch (ParseException e) {
    if (end == 0) {
      end       = e.currentToken.sourceEnd;
      endLine   = e.currentToken.endLine;
      endColumn = e.currentToken.endColumn;
    }
    //{{{ fireParseError
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          end,
                                          e.currentToken.sourceEnd,
                                          endLine,
                                          e.currentToken.endLine,
                                          endColumn,
                                          e.currentToken.endColumn)); //}}}
  }
  {
    return new ReturnStatement(expr,
                               returnToken.sourceStart,
                               end,
                               returnToken.beginLine,
                               endLine,
                               returnToken.beginColumn,
                               endColumn);
  }
}

//}}}

//}}}
