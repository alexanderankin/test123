options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  OPTIMIZE_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = true;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  COMMON_TOKEN_ACTION = true;
}

PARSER_BEGIN(PHPParser)
package gatchan.phpparser.parser;

import java.util.ArrayList;
import java.io.StringReader;
import java.io.*;
import java.util.List;

import net.sourceforge.phpdt.internal.compiler.ast.*;
import net.sourceforge.phpdt.internal.compiler.parser.OutlineableWithChildren;
import net.sourceforge.phpdt.internal.compiler.parser.Outlineable;
import net.sourceforge.phpdt.internal.compiler.parser.PHPOutlineInfo;

/**
 * A PHP Parser originaly written for phpeclipse (http://www.phpeclipse.de).
 *
 * @author Matthieu Casanova <chocolat.mou@gmail.com>
 */
public final class PHPParser {

  //{{{ Fields
  
  
  //todo : fix the variables names bug
  //todo : handle tilde operator
  
  //todo: put this in an interface
  public static final int ERROR = 2;
  public static final int WARNING = 1;
  public static final int INFO = 0;
  public static final int TASK = 3;
  
  /** The current segment. */
  private OutlineableWithChildren currentSegment;
  
  /** The error level of the current ParseException. */
  private int errorLevel = ERROR;
  /** The message of the current ParseException. If it's null it's because the parse exception wasn't handled */
  private String errorMessage;
  
  private int errorStart = -1;
  private int errorEnd = -1;
  private PHPDocument phpDocument;
  
  private static final String SYNTAX_ERROR_CHAR = "syntax error";
  /**
  * The point where html starts.
  * It will be used by the token manager to create HTMLCode objects
  */
  private int htmlStart;
  private int htmlLineStart;
  private int htmlColumnStart;
  
  //ast stack
  private static final int AstStackIncrement = 100;
  /** The stack of node. */
  private AstNode[] nodes;
  /** The cursor in expression stack. */
  private int nodePtr;
  
  public static final boolean PARSER_DEBUG = false;
  
  private final List parserListeners = new ArrayList();
  
  private String path;
  
  /** Tell if the parsing should be stopped. */
  private boolean shouldStop;
  
  //}}}

  //{{{ PHPParser()
  
  public PHPParser() {
  }
  
  //}}}
  //{{{ getPath()
  
  /**
   * Set the path of the file that is currently parsed.
   * This path will be sent in parse errors and messages
   *
   * @param path the path of the parsed file
   */
  public void setPath(final String path) {
    this.path = path;
  }
  
  //}}}
  //{{{ getPath()
  
  public String getPath() {
    return path;
  }
  
  //}}}
  //{{{ stop()
  
  /**
   * Ask the parser to stop his work.
   */
  public void stop() {
    shouldStop = true;
  }
  
  //}}}
  //{{{ isStopped()
  
  public boolean isStopped() {
    return shouldStop;
  }
  
  //}}}
  //{{{ addParserListener(final PHPParserListener listener)
  
  public void addParserListener(final PHPParserListener listener) {
    if (!parserListeners.contains(listener)) {
      parserListeners.add(listener);
    }
  }
  
  //}}}
  //{{{ removeParserListener(final PHPParserListener listener)
  
  public void removeParserListener(final PHPParserListener listener) {
    parserListeners.remove(listener);
  }
  
  //}}}
  //{{{ fireParseError(final PHPParseErrorEvent e)
  
  public void fireParseError(final PHPParseErrorEvent e) {
    for (int i = 0;i < parserListeners.size();i++) {
        final PHPParserListener listener = (PHPParserListener) parserListeners.get(i);
        listener.parseError(e);
    }
  }
  
  //}}}
  //{{{ fireParseMessage(final PHPParseMessageEvent e)
  
  public void fireParseMessage(final PHPParseMessageEvent e) {
    for (int i = 0;i < parserListeners.size();i++) {
        final PHPParserListener listener = (PHPParserListener) parserListeners.get(i);
        listener.parseMessage(e);
    }
  }
  
  //}}}
  //{{{ phpParserTester(final String strEval)
  
  public final void phpParserTester(final String strEval) throws ParseException {
    final StringReader stream = new StringReader(strEval);
    if (jj_input_stream == null) {
      jj_input_stream = new SimpleCharStream(stream, 1, 1);
      token_source = new PHPParserTokenManager(jj_input_stream);
    }
    ReInit(new StringReader(strEval));
    init();
    phpDocument = new PHPDocument("_root");
    currentSegment = phpDocument;
    new PHPOutlineInfo(null, currentSegment);
    token_source.SwitchTo(PHPParserTokenManager.PHPPARSING);
    phpTest();
  }
  
  //}}}
  //{{{ htmlParserTester(final File fileName)
  
  public final void htmlParserTester(final File fileName) throws FileNotFoundException, ParseException {
    final Reader stream = new FileReader(fileName);
    if (jj_input_stream == null) {
      jj_input_stream = new SimpleCharStream(stream, 1, 1);
      token_source = new PHPParserTokenManager(jj_input_stream);
    }
    ReInit(stream);
    init();
    phpDocument = new PHPDocument("_root");
    currentSegment = phpDocument;
    new PHPOutlineInfo(null, currentSegment);
    phpFile();
  }
  
  //}}}
  //{{{ htmlParserTester(final String strEval)
  
  public final void htmlParserTester(final String strEval) throws ParseException {
    final StringReader stream = new StringReader(strEval);
    if (jj_input_stream == null) {
      jj_input_stream = new SimpleCharStream(stream, 1, 1);
      token_source = new PHPParserTokenManager(jj_input_stream);
    }
    ReInit(stream);
    init();
    phpDocument = new PHPDocument("_root");
    currentSegment = phpDocument;
    new PHPOutlineInfo(null, currentSegment);
    phpFile();
  }
  
  //}}}
  //{{{ init()
  
  /**
   * Reinitialize the parser.
   */
  private void init() {
    nodes = new AstNode[AstStackIncrement];
    nodePtr = -1;
    htmlStart = 0;
    htmlColumnStart = 0;
    htmlLineStart = 0;
  }
  
  //}}}
  //{{{ pushOnAstNodes(final AstNode node)
  
  /**
   * Add an php node on the stack.
   * @param node the node that will be added to the stack
   */
  private void pushOnAstNodes(final AstNode node) {
    try {
      nodes[++nodePtr] = node;
    } catch (IndexOutOfBoundsException e) {
      final int oldStackLength = nodes.length;
      final AstNode[] oldStack = nodes;
      nodes = new AstNode[oldStackLength + AstStackIncrement];
      System.arraycopy(oldStack, 0, nodes, 0, oldStackLength);
      nodePtr = oldStackLength;
      nodes[nodePtr] = node;
    }
  }
  
  //}}}
  //{{{ parse(String s)

  public final void parse(String s) throws ParseException {
    final Reader reader = new StringReader(s);
    parse(reader);
  } 
  
  //}}}
  //{{{ parse(Reader reader)

  public final void parse(Reader reader) throws ParseException {
    phpDocument = new PHPDocument("_root");
    currentSegment = phpDocument;
    if (jj_input_stream == null) {
      jj_input_stream = new SimpleCharStream(reader, 1, 1);
      token_source = new PHPParserTokenManager(jj_input_stream);
    }
    ReInit(reader);
    init();
    parse();
    phpDocument.nodes = new AstNode[nodes.length];
    System.arraycopy(nodes,0,phpDocument.nodes,0,nodes.length);
  } 
  
  //}}}
  //{{{ createNewHTMLCode()
  
  /**
   * Put a new html block in the stack.
   */
  public final void createNewHTMLCode() {
    final int currentPosition = token.sourceStart;
    if (currentPosition == htmlStart ||
          currentPosition < htmlStart ||
          currentPosition > jj_input_stream.getCurrentBuffer().length()) {
      return;
    }
    final String html = jj_input_stream.getCurrentBuffer().substring(htmlStart, currentPosition);
    pushOnAstNodes(new HTMLCode(html, htmlStart,currentPosition,htmlLineStart,token.endLine,htmlColumnStart,token.endColumn));
  }
  
  //}}}
  //{{{ error_skipto(final int kind)
  
  Token error_skipto(final int kind) {
    //  ParseException e = generateParseException();  // generate the exception object.
    //  System.out.println(e.toString());  // print the error message
    Token t;
    do {
      t = getNextToken();
    } while (t.kind != kind && t.kind != PHPParserConstants.EOF && t.kind != PHPParserConstants.RBRACE);
    return t;
  }
  
  //}}}
  //{{{ parse()
  
  public final void parse() throws ParseException {
	  phpFile();
  }
  
  //}}}
  //{{{ getPHPDocument()
  
  public PHPDocument getPHPDocument() {
    return phpDocument;
  }
  
  //}}}
}

PARSER_END(PHPParser)

TOKEN_MGR_DECLS:
{
  // CommonTokenAction: use the begins/ends fields added to the Jack
  // CharStream class to set corresponding fields in each Token (which was
  // also extended with new fields). By default Jack doesn't supply absolute
  // offsets, just line/column offsets
  void CommonTokenAction(Token t) {
    t.sourceStart = input_stream.getBeginOffset();
    t.sourceEnd = input_stream.getEndOffset();
    
  } // CommonTokenAction
} // TOKEN_MGR_DECLS

//{{{ TOKEN declarations 

<DEFAULT> TOKEN :
{
  <PHPSTARTSHORT : "<?">    : PHPPARSING
| <PHPSTARTLONG  : "<?php"> : PHPPARSING
| <PHPECHOSTART  : "<?=">   : PHPPARSING
}

<PHPPARSING, IN_SINGLE_LINE_COMMENT,IN_VARIABLE> TOKEN :
{
  <PHPEND :"?>"> : DEFAULT
}

/* Skip any character if we are not in php mode */
<DEFAULT> SKIP :
{
 < ~[] >
}


/* WHITE SPACE */
<PHPPARSING> SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

<IN_VARIABLE> SPECIAL_TOKEN :
{
  " "  : PHPPARSING
| "\t" : PHPPARSING
| "\n" : PHPPARSING
| "\r" : PHPPARSING
| "\f" : PHPPARSING
}
/* COMMENTS */
<PHPPARSING> SPECIAL_TOKEN :
{
  "//" : IN_SINGLE_LINE_COMMENT
| "#"  : IN_SINGLE_LINE_COMMENT
| <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
| "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT> SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n"> : PHPPARSING
| < ~[] >
}

<IN_FORMAL_COMMENT> SPECIAL_TOKEN :
{
  "*/" : PHPPARSING
}

<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN :
{
  "*/" : PHPPARSING
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* KEYWORDS */
<PHPPARSING> TOKEN :
{
  <CLASS    : "class">
| <FUNCTION : "function">
| <VAR      : "var">
| <IF       : "if">
| <ELSEIF   : "elseif">
| <ELSE     : "else">
| <ARRAY    : "array">
| <BREAK    : "break">
| <LIST     : "list">
}

/* LANGUAGE CONSTRUCT */
<PHPPARSING> TOKEN :
{
  <PRINT              : "print">
| <ECHO               : "echo">
| <INCLUDE            : "include">
| <REQUIRE            : "require">
| <INCLUDE_ONCE       : "include_once">
| <REQUIRE_ONCE       : "require_once">
| <GLOBAL             : "global">
| <DEFINE             : "define">
| <STATIC             : "static">
}

<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <CLASSACCESS        : "->"> : PHPPARSING
| <STATICCLASSACCESS  : "::"> : PHPPARSING
| <ARRAYASSIGN        : "=>"> : PHPPARSING
}

/* RESERVED WORDS AND LITERALS */

<PHPPARSING> TOKEN :
{
  <CASE     : "case">
| <CONST    : "const">
| <CONTINUE : "continue">
| <_DEFAULT : "default">
| <DO       : "do">
| <EXTENDS  : "extends">
| <FOR      : "for">
| <GOTO     : "goto">
| <NEW      : "new">
| <NULL     : "null">
| <RETURN   : "return">
| <SUPER    : "super">
| <SWITCH   : "switch">
| <THIS     : "this">
| <TRUE     : "true">
| <FALSE    : "false">
| <WHILE    : "while">
| <ENDWHILE : "endwhile">
| <ENDSWITCH: "endswitch">
| <ENDIF    : "endif">
| <ENDFOR   : "endfor">
| <ENDFOREACH : "endforeach">
| <FOREACH  : "foreach">
| <AS       : "as" >
}

/* TYPES */
<PHPPARSING> TOKEN :
{
  <STRING  : "string">
| <OBJECT  : "object">
| <BOOL    : "bool">
| <BOOLEAN : "boolean">
| <REAL    : "real">
| <DOUBLE  : "double">
| <FLOAT   : "float">
| <INT     : "int">
| <INTEGER : "integer">
}

//Misc token
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <AT                 : "@"> : PHPPARSING
| <BANG               : "!"> : PHPPARSING
| <TILDE              : "~"> : PHPPARSING
| <HOOK               : "?"> : PHPPARSING
| <COLON              : ":"> : PHPPARSING
}

/* OPERATORS */
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <OR_OR              : "||">  : PHPPARSING
| <AND_AND            : "&&">  : PHPPARSING
| <PLUS_PLUS          : "++">  : PHPPARSING
| <MINUS_MINUS        : "--">  : PHPPARSING
| <PLUS               : "+">   : PHPPARSING
| <MINUS              : "-">   : PHPPARSING
| <STAR               : "*">   : PHPPARSING
| <SLASH              : "/">   : PHPPARSING
| <BIT_AND            : "&">   : PHPPARSING
| <BIT_OR             : "|">   : PHPPARSING
| <BIT_XOR            : "^">   : PHPPARSING
| <REMAINDER          : "%">   : PHPPARSING
| <LSHIFT             : "<<">  : PHPPARSING
| <RSIGNEDSHIFT       : ">>">  : PHPPARSING
| <RUNSIGNEDSHIFT     : ">>>"> : PHPPARSING
| <_ORL               : "OR">  : PHPPARSING
| <XOR                : "XOR"> : PHPPARSING
| <_ANDL              : "AND"> : PHPPARSING
}

/* LITERALS */
<PHPPARSING> TOKEN :
{
  <INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  <#HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  <#OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  <FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]
  >
|
  <#EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  <STRING_LITERAL: (<STRING_1> | <STRING_2> | <STRING_3>)>
|   <STRING_1: "\"" ( ~["\"","\\"] | "\\" ~[] )* "\"">
|   <STRING_2: "'"  ( ~["'","\\"]  | "\\" ~[] )* "'">
|   <STRING_3: "`"  ( ~["`","\\"]  | "\\" ~[] )* "`">
}
 /*
<IN_STRING,DOLLAR_IN_STRING> SKIP :
{
  <ESCAPED : ("\\" ~[])> : IN_STRING
}
   Deactivate the String parsing
<PHPPARSING> TOKEN :
{
  <DOUBLEQUOTE : "\""> : IN_STRING
}

<IN_STRING> TOKEN :
{
  <DOLLARS : "$"> : DOLLAR_IN_STRING
}

<IN_STRING,DOLLAR_IN_STRING> TOKEN :
{
  <DOUBLEQUOTE2 : "\""> : PHPPARSING
}

<DOLLAR_IN_STRING> TOKEN :
{
  <LBRACE1 : "{"> : DOLLAR_IN_STRING_EXPR
}

<IN_STRING> SPECIAL_TOKEN :
{
    <"{"> : SKIPSTRING
}

<SKIPSTRING> SPECIAL_TOKEN :
{
    <"}"> : IN_STRING
}

<SKIPSTRING> SKIP :
{
    <~[]>
}

<DOLLAR_IN_STRING_EXPR> TOKEN :
{
  <RBRACE1 : "}"> : DOLLAR_IN_STRING
}

<DOLLAR_IN_STRING_EXPR> TOKEN :
{
  <ID : (~["}"])*>
}

<IN_STRING> SKIP :
{
  <~[]>
}

<DOLLAR_IN_STRING_EXPR,IN_STRING> SKIP :
{
  <~[]>
}
*/

<PHPPARSING> TOKEN :
{
  <HEREDOCSTARTTOKEN : "<<<">
}


<PHPPARSING,IN_VARIABLE> TOKEN : {<DOLLAR : "$"> : IN_VARIABLE}

<PHPPARSING, IN_VARIABLE> TOKEN :
{
  <IDENTIFIER: ((<LETTER>|<SPECIAL>) (<LETTER>|<DIGIT>|<SPECIAL>)*) | <DEFINE> | <OBJECT> >
|
  < #LETTER:
      ["a"-"z"] | ["A"-"Z"]
  >
|
  < #DIGIT:
      ["0"-"9"]
  >
|
  < #SPECIAL:
    "_" | ["\u007f"-"\u00ff"]
  >
}

  /*
<HEREDOC> SKIP :
{
  <NEWLINE2 : "\n"> : HEREDOCLINESTART
| <~[]>
}
  */

/* IDENTIFIERS */




//<PHPPARSING, IN_VARIABLE, DOLLAR_IN_STRING> TOKEN :

  /*
<DOLLAR_IN_STRING> SPECIAL_TOKEN :
{
 < ~[] > : IN_STRING
}  */
/* SEPARATORS */

<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <LPAREN    : "("> : PHPPARSING
| <RPAREN    : ")"> : PHPPARSING
| <LBRACE    : "{"> : PHPPARSING
| <RBRACE    : "}"> : PHPPARSING
| <LBRACKET  : "["> : PHPPARSING
| <RBRACKET  : "]"> : PHPPARSING
| <SEMICOLON : ";"> : PHPPARSING
| <COMMA     : ","> : PHPPARSING
| <DOT       : "."> : PHPPARSING
}


/* COMPARATOR */
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <GT                 : ">"  > : PHPPARSING
| <LT                 : "<"  > : PHPPARSING
| <EQUAL_EQUAL        : "==" > : PHPPARSING
| <LE                 : "<=" > : PHPPARSING
| <GE                 : ">=" > : PHPPARSING
| <NOT_EQUAL          : "!=" > : PHPPARSING
| <DIF                : "<>" > : PHPPARSING
| <BANGDOUBLEEQUAL    : "!=="> : PHPPARSING
| <TRIPLEEQUAL        : "==="> : PHPPARSING
}

/* ASSIGNATION */
<PHPPARSING,IN_VARIABLE> TOKEN :
{
  <ASSIGN             : "="  > : PHPPARSING
| <PLUSASSIGN         : "+=" > : PHPPARSING
| <MINUSASSIGN        : "-=" > : PHPPARSING
| <STARASSIGN         : "*=" > : PHPPARSING
| <SLASHASSIGN        : "/=" > : PHPPARSING
| <ANDASSIGN          : "&=" > : PHPPARSING
| <ORASSIGN           : "|=" > : PHPPARSING
| <XORASSIGN          : "^=" > : PHPPARSING
| <DOTASSIGN          : ".=" > : PHPPARSING
| <REMASSIGN          : "%=" > : PHPPARSING
| <TILDEEQUAL         : "~=" > : PHPPARSING
| <LSHIFTASSIGN       : "<<="> : PHPPARSING
| <RSIGNEDSHIFTASSIGN : ">>="> : PHPPARSING
}

//}}}

//{{{ PARSER

//{{{ PHP Structures

//{{{ phpTest()

void phpTest() :
{}
{
  Php()
  <EOF>
}

//}}}
//{{{ phpFile()

void phpFile() :
{}
{
  try {
    (PhpBlock())*
    {createNewHTMLCode();}
  } catch (TokenMgrError e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          e.getMessage(),
                                          e.getMessage(),
                                          null,
                                          jj_input_stream.getBeginOffset(),
                                          jj_input_stream.getEndOffset(),
                                          jj_input_stream.getBeginLine(),
                                          jj_input_stream.getEndLine(),
                                          jj_input_stream.getBeginColumn(),
                                          jj_input_stream.getEndColumn()));
  }
}

//}}}
//{{{ PhpBlock()

/**
 * A php block is a <?= expression [;]?>
 * or <?php somephpcode ?>
 * or <? somephpcode ?>
 */
void PhpBlock() :
{
  final PHPEchoBlock phpEchoBlock;
  final Token token,phpEnd;
}
{
  phpEchoBlock = phpEchoBlock()
  {pushOnAstNodes(phpEchoBlock);}
|
  [   <PHPSTARTLONG>
    | token = <PHPSTARTSHORT>
    {
      fireParseMessage(new PHPParseMessageEvent(INFO,
                                                PHPParseMessageEvent.MESSAGE_SHORT_OPEN_TAG,
                                                path,
                                                "You should use '<?php' instead of '<?' it will avoid some problems with XML",
                                                token.sourceStart,
                                                token.sourceEnd,
                                                token.beginLine,
                                                token.endLine,
                                                token.beginColumn,
                                                token.endColumn));
    }
  ]
  {createNewHTMLCode();}
  Php()
  try {
    phpEnd = <PHPEND>
   {
    htmlStart = phpEnd.sourceEnd;
    htmlLineStart = phpEnd.endLine;
    htmlColumnStart = phpEnd.endColumn;
   }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'?>' expected",
                                          "?>",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.beginColumn,
                                          e.currentToken.endColumn));

  }
}

//}}}
//{{{ phpEchoBlock()

PHPEchoBlock phpEchoBlock() :
{
  final Expression expr;
  PHPEchoBlock echoBlock;
  final Token token, token2;
}
{
  token = <PHPECHOSTART> {createNewHTMLCode();}
  expr = Expression() [ <SEMICOLON> ] 
  try {
    token2 = <PHPEND>
    {
      htmlStart = token2.sourceEnd;
      htmlLineStart = token2.endLine;
      htmlColumnStart = token2.endColumn;

      echoBlock = new PHPEchoBlock(expr,token.sourceStart,token2.sourceEnd, token.beginLine,token2.endLine,token.beginColumn,token2.endColumn);
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'?>' expected",
                                          "?>",
                                          e.currentToken.image,
                                          e.currentToken.sourceEnd+1,
                                          e.currentToken.sourceEnd+2,
                                          e.currentToken.endLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn));
    echoBlock = new PHPEchoBlock(expr,
                                 token.sourceStart,
                                 e.currentToken.sourceEnd,
                                 token.beginLine,
                                 e.currentToken.endLine,
                                 token.beginColumn,
                                 e.currentToken.endColumn);
  }
  {
    pushOnAstNodes(echoBlock);
    return echoBlock;
  }
}

//}}}
//{{{ Php()

void Php() :
{}
{
  (BlockStatement())*
}

//}}}


//}}}

//{{{ Class methods

//{{{ ClassDeclaration()

/**
 * A Class declaration.
 * class <IDENTIFIER> [extends <IDENTIFIER>] Class body
 *
 * @return a ClassDeclaration
 */
ClassDeclaration ClassDeclaration() :
{
  final ClassHeader classHeader;
  final ClassDeclaration classDeclaration;
  Token className = null;
  final Token superclassName, classToken;
  String classNameImage = SYNTAX_ERROR_CHAR;
  String superclassNameImage = null;
}
{
  classToken = <CLASS>
  try {
    className = <IDENTIFIER>
    {classNameImage = className.image;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "identifier expected",
                                          "identifier",
                                          e.currentToken.image,
                                          classToken.sourceStart,
                                          classToken.sourceEnd,
                                          classToken.beginLine,
                                          classToken.endLine,
                                          classToken.endColumn,
                                          classToken.endColumn+1));
  }
  [
    <EXTENDS>
    try {
      superclassName = <IDENTIFIER>
      {superclassNameImage = superclassName.image;}
    } catch (ParseException e) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "identifier expected",
                                            "identifier",
                                            e.currentToken.next.image,
                                            e.currentToken.next.sourceStart,
                                            e.currentToken.next.sourceEnd,
                                            e.currentToken.next.beginLine,
                                            e.currentToken.next.endLine,
                                            e.currentToken.next.beginColumn,
                                            e.currentToken.next.endColumn));
      superclassNameImage = SYNTAX_ERROR_CHAR;
      error_skipto(LBRACE);
    }
  ]
  {
    final int end,endLine,endColumn;
    if (className == null) {
      end         = classToken.sourceEnd;
      endLine     = classToken.endLine;
      endColumn   = classToken.endColumn;
    } else {
      end         = className.sourceEnd;
      endLine     = className.endLine;
      endColumn   = className.endColumn;
    }
    if (superclassNameImage == null) {
      classHeader = new ClassHeader(path,
                                    classNameImage,
                                    classToken.sourceStart,
                                    end,
                                    classToken.beginLine,
                                    endLine,
                                    classToken.beginColumn,
                                    endColumn);
    } else {
      classHeader = new ClassHeader(path,
                                    classNameImage,
                                    superclassNameImage,
                                    classToken.sourceStart,
                                    end,
                                    classToken.beginLine,
                                    endLine,
                                    classToken.beginColumn,
                                    endColumn);
    }
    classDeclaration = new ClassDeclaration(currentSegment,
                                            classHeader,
                                            classToken.sourceStart,
                                            end,
                                            classToken.beginLine,
                                            endLine,
                                            classToken.beginColumn,
                                            endColumn);
      currentSegment.add(classDeclaration);
      currentSegment = classDeclaration;
  }
  //todo change this
  ClassBody(classDeclaration)
  {currentSegment = (OutlineableWithChildren) currentSegment.getParent();
   pushOnAstNodes(classDeclaration);
   return classDeclaration;}
}

//}}}
//{{{ ClassBody(final ClassDeclaration classDeclaration)

void ClassBody(final ClassDeclaration classDeclaration) :
{
  final Token lBraceToken;
  Token rBraceToken;
}
{
  try {
    lBraceToken = <LBRACE>
    {
      classDeclaration.setBodyStart(lBraceToken.sourceStart);
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'{' expected",
                                          "{",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  ( ClassBodyDeclaration(classDeclaration) )*
  try {
    rBraceToken = <RBRACE>
    {
      classDeclaration.setBodyEnd(rBraceToken.sourceEnd);
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'}' expected",
                                          "}",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    rBraceToken = error_skipto(RBRACE);
    classDeclaration.setBodyEnd(rBraceToken.sourceEnd);
  }
}

//}}}
//{{{ ClassBodyDeclaration(final ClassDeclaration classDeclaration)

/**
 * A class can contain only methods and fields.
 */
void ClassBodyDeclaration(final ClassDeclaration classDeclaration) :
{
  final MethodDeclaration method;
  final FieldDeclaration field;
}
{
  method = MethodDeclaration() {method.analyzeCode(this); classDeclaration.addMethod(method);}
| field  = FieldDeclaration()  {if (field != null) classDeclaration.addField(field);}
}

//}}}
//{{{ FieldDeclaration()

/**
 * A class field declaration : it's var VariableDeclarator() (, VariableDeclarator())*;.
 * it is only used by ClassBodyDeclaration()
 */
FieldDeclaration FieldDeclaration() :
{
  VariableDeclaration variableDeclaration;
  final VariableDeclaration[] list;
  final ArrayList arrayList = new ArrayList();
  final Token varToken;
  Token semicolonToken = null;
}
{
  varToken = <VAR>
  try {
    variableDeclaration = VariableDeclaratorNoSuffix()
      {
        arrayList.add(variableDeclaration);
      }
    } catch (ParseException e) {
      final Token semicolon = error_skipto(SEMICOLON);
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "variable expected",
                                            "variable",
                                            e.currentToken.next.image,
                                            varToken.sourceEnd,
                                            semicolon.sourceEnd,
                                            varToken.beginLine,
                                            semicolon.endLine,
                                            varToken.endColumn,
                                            semicolon.endColumn));
      return null;
  }

  (
    <COMMA> variableDeclaration = VariableDeclaratorNoSuffix()
      {
        arrayList.add(variableDeclaration);
      }
  )*
  try {
    semicolonToken = <SEMICOLON>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }

  {
   if (arrayList.size() == 0) {
    //todo : strange
     return null;
   } else {
     list = new VariableDeclaration[arrayList.size()];
     arrayList.toArray(list);
   }
   final int end, endLine, endColumn;
   if (semicolonToken == null) {
     end       = list[list.length-1].sourceEnd;
     endLine   = list[list.length-1].getEndLine();
     endColumn = list[list.length-1].getEndColumn();
   } else {
     end       = semicolonToken.sourceEnd;
     endLine   = semicolonToken.endLine;
     endColumn = semicolonToken.endColumn;
   }
   return new FieldDeclaration(path,
                               list,
                               currentSegment,
                               varToken.sourceStart,
                               end,
                               varToken.beginLine,
                               endLine,
                               varToken.beginColumn,
                               endColumn);}
}

//}}}

//}}}

//{{{ Variables

//{{{ VariableDeclaratorNoSuffix()

/**
 * a strict variable declarator : there cannot be a suffix here.
 * It will be used by fields and formal parameters
 */
VariableDeclaration VariableDeclaratorNoSuffix() :
{
  final Token identifierToken, lbrace,rbrace;
  final Expression expr;
  Expression initializer = null;
  Token assignToken = null;
  final Token dollarToken;
  final Variable variable;
}
{
  dollarToken = <DOLLAR>
  (
     identifierToken = <IDENTIFIER>
     {variable = new Variable(identifierToken.image,
                              dollarToken.sourceStart,
                              identifierToken.sourceEnd,
                              dollarToken.beginLine,
                              identifierToken.endLine,
                              dollarToken.beginColumn,
                              identifierToken.endColumn);}
   |
     lbrace = <LBRACE> expr = Expression() rbrace = <RBRACE>
     {variable = new Variable(expr,
                              lbrace.sourceStart,
                              rbrace.sourceEnd,
                              lbrace.beginLine,
                              rbrace.endLine,
                              lbrace.beginColumn,
                              rbrace.endColumn);}
  )
  [
    assignToken = <ASSIGN>
    try {
      initializer = VariableInitializer()
    } catch (ParseException e) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "Literal expression expected in variable initializer",
                                            "literal",
                                            e.currentToken.image,
                                            assignToken.sourceEnd,
                                            assignToken.sourceEnd +1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
    }
  ]
  {
  if (assignToken == null) {
    return new VariableDeclaration(currentSegment,
                                   variable,
                                   variable.sourceStart,
                                   variable.sourceEnd,
                                   variable.getBeginLine(),
                                   variable.getEndLine(),
                                   variable.getBeginColumn(),
                                   variable.getEndColumn());
  }
  if (initializer == null) {
    return new VariableDeclaration(currentSegment,
                                   variable,
                                   null,
                                   "=",
                                   variable.sourceStart,
                                   assignToken.sourceEnd,
                                   variable.getBeginLine(),
                                   assignToken.endLine,
                                   variable.getBeginColumn(),
                                   assignToken.endColumn);
  }
  return new VariableDeclaration(currentSegment,
                                 variable,
                                 initializer,
                                 "=",
                                 variable.sourceStart,
                                 initializer.sourceEnd,
                                 variable.getBeginLine(),
                                 initializer.getEndLine(),
                                 variable.getBeginColumn(),
                                 initializer.getEndColumn());
  }
}

//}}}
//{{{ VariableDeclarator()

/**
 * this will be used by static statement
 */
VariableDeclaration VariableDeclarator() :
{
  final AbstractVariable variable;
  Expression initializer = null;
  Token assignToken = null;
}
{
  variable = VariableDeclaratorId()
  [
    assignToken = <ASSIGN>
    try {
      initializer = VariableInitializer()
    } catch (ParseException e) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "Literal expression expected in variable initializer",
                                            "literal",
                                            e.currentToken.image,
                                            token.sourceEnd,
                                            token.sourceEnd+1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
  }
  ]
  {
  if (assignToken == null) {
    return new VariableDeclaration(currentSegment,
                                   variable,
                                   variable.sourceStart,
                                   variable.sourceEnd,
                                   variable.getBeginLine(),
                                   variable.getEndLine(),
                                   variable.getBeginColumn(),
                                   variable.getEndColumn());
  }
  if (initializer == null) {
    return new VariableDeclaration(currentSegment,
                                   variable,
                                   null,
                                   "=",
                                   variable.sourceStart,
                                   assignToken.sourceEnd,
                                   variable.getBeginLine(),
                                   assignToken.endLine,
                                   variable.getBeginColumn(),
                                   assignToken.endColumn);
  }
  return new VariableDeclaration(currentSegment,
                                 variable,
                                 initializer,
                                 "=",
                                 variable.sourceStart,
                                 initializer.sourceEnd,
                                 variable.getBeginLine(),
                                 initializer.getEndLine(),
                                 variable.getBeginColumn(),
                                 initializer.getEndColumn());
  }
}

//}}}
//{{{ VariableDeclaratorId()

/**
 * A Variable name.
 * @return the variable name (with suffix)
 */
AbstractVariable VariableDeclaratorId() :
{
  AbstractVariable var;
}
{
  try {
    var = Variable()
    (
     // LOOKAHEAD(2)
      var = VariableSuffix(var)
    )*
    {
     return var;
    }
  } catch (ParseException e) {
    errorMessage = "'$' expected for variable identifier";
    errorLevel   = ERROR;
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
}

//}}}
//{{{ Variable()

Variable Variable() :
{
  Variable variable = null;
  final Token dollarToken;
}
{
  dollarToken = <DOLLAR> variable = Var()
  {
    variable.setStart(dollarToken.sourceStart,dollarToken.beginLine,dollarToken.beginColumn);
    return variable;
  }
}

//}}}
//{{{ Var()

Variable Var() :
{
  Variable variable = null;
  final Token token,token2;
  ConstantIdentifier constant;
  final Expression expression;
}
{
  token = <DOLLAR> variable = Var()
  {
    return new Variable(variable,
                        variable.sourceStart,
                        variable.sourceEnd,
                        variable.getBeginLine(),
                        variable.getEndLine(),
                        variable.getBeginColumn(),
                        variable.getBeginColumn());
  }
|
  token = <LBRACE> expression = Expression() token2 = <RBRACE>
  {
    return new Variable(expression,
                        token.sourceStart,
                        token2.sourceEnd,
                        token.beginLine,
                        token2.endLine,
                        token.beginColumn,
                        token2.endColumn);
  }
|
  token = <IDENTIFIER>
  {
    return new Variable(token.image,
                        token.sourceStart,
                        token.sourceEnd,
                        token.beginLine,
                        token.endLine,
                        token.beginColumn,
                        token.endColumn);
  }
}

//}}}
//{{{ VariableInitializer()

Expression VariableInitializer() :
{
  final Expression expr;
  final Token token, token2;
}
{
  expr = Literal()
  {return expr;}
|
  token2 = <MINUS> (token = <INTEGER_LITERAL> | token = <FLOATING_POINT_LITERAL>)
  {return new PrefixedUnaryExpression(new NumberLiteral(token),
                                      OperatorIds.MINUS,
                                      token2.sourceStart,
                                      token2.beginLine,
                                      token2.beginColumn);}
|
  token2 = <PLUS> (token = <INTEGER_LITERAL> | token = <FLOATING_POINT_LITERAL>)
  {return new PrefixedUnaryExpression(new NumberLiteral(token),
                                      OperatorIds.PLUS,
                                      token2.sourceStart,
                                      token2.beginLine,
                                      token2.beginColumn);}
|
  expr = ArrayDeclarator()
  {return expr;}
|
  token = <IDENTIFIER>
  {return new ConstantIdentifier(token);}
}

//}}}


//}}}

//{{{ Arrays

//{{{ ArrayVariable()

ArrayVariableDeclaration ArrayVariable() :
{
final Expression expr,expr2;
final Token arrayAssignToken;
}
{
  expr = Expression()
  [
    arrayAssignToken = <ARRAYASSIGN> expr2 = Expression()
    {
      int sourceEnd,endLine,endColumn;
      if (expr2 == null) {
        sourceEnd = arrayAssignToken.sourceEnd;
        endLine   = arrayAssignToken.endLine;
        endColumn = arrayAssignToken.endColumn;
      } else {
        sourceEnd = expr2.sourceEnd;
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }

      return new ArrayVariableDeclaration(expr,expr2,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);}
  ]
  {return new ArrayVariableDeclaration(expr,expr.sourceEnd,expr.getBeginLine(),expr.getEndLine(),expr.getBeginColumn(),expr.getEndColumn());}
}

//}}}
//{{{ ArrayInitializer()

ArrayVariableDeclaration[] ArrayInitializer() :
{
  ArrayVariableDeclaration expr;
  final ArrayList list = new ArrayList();
}
{
  <LPAREN>
    [
      expr = ArrayVariable()
      {list.add(expr);}
      ( LOOKAHEAD(2) <COMMA> expr = ArrayVariable()
      {list.add(expr);}
      )*
    ]
    [
      <COMMA> {list.add(null);}
    ]
  <RPAREN>
  {
  final ArrayVariableDeclaration[] vars = new ArrayVariableDeclaration[list.size()];
  list.toArray(vars);
  return vars;}
}

//}}}


//}}}

//{{{ Methods functions

//{{{ MethodDeclaration()

/**
 * A Method Declaration.
 * <b>function</b> MetodDeclarator() Block()
 *
 * @return a MethodDeclaration
 */
MethodDeclaration MethodDeclaration() :
{
  final MethodDeclaration functionDeclaration;
  final MethodHeader methodHeader;
  final Block block;
  final OutlineableWithChildren seg = currentSegment;
  final Token functionToken;
}
{
  functionToken = <FUNCTION>
  methodHeader = methodHeader(functionToken)
  {
    functionDeclaration = new MethodDeclaration(currentSegment,methodHeader);
    currentSegment = functionDeclaration;
  }
  block = Block()
  {functionDeclaration.statements = block.statements;
   functionDeclaration.setBodyStart(block.getSourceStart());
   functionDeclaration.setBodyEnd(token.sourceEnd);
   currentSegment = seg;
   return functionDeclaration;}
}

//}}}
//{{{ methodHeader(final int functionToken)

/**
 * A MethodDeclarator.
 * [&] IDENTIFIER(parameters ...).
 *
 * @return a function description for the outline
 */
MethodHeader methodHeader(final Token functionToken) :
{
  Token identifier = null;
  Token reference = null;
  final ArrayList formalParameters = new ArrayList();
  String identifierChar = SYNTAX_ERROR_CHAR;
}
{
  [reference = <BIT_AND>]
  try {
    identifier = <IDENTIFIER>
    {
      identifierChar = identifier.image;
    }
  } catch (ParseException e) {
    if (e.currentToken.next.kind == PHPParserConstants.LPAREN) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "identifier expected",
                                            "identifier",
                                            e.currentToken.image,
                                            functionToken.sourceStart,
                                            e.currentToken.sourceStart,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.beginColumn-1,
                                            e.currentToken.endColumn));
    } else {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "unexpected token",
                                            "identifier",
                                            e.currentToken.next.image,
                                            e.currentToken.next.sourceStart,
                                            e.currentToken.next.sourceEnd,
                                            e.currentToken.next.beginLine,
                                            e.currentToken.next.endLine,
                                            e.currentToken.next.beginColumn,
                                            e.currentToken.next.endColumn));
      //error_skipto(PHPParserConstants.LPAREN);
    }
  }
  FormalParameters(formalParameters)
  {
    return new MethodHeader(path,
                            identifierChar,
                            reference != null,
                            formalParameters,
                            functionToken.sourceStart,
                            token.sourceEnd,
                            functionToken.beginLine,
                            token.endLine,
                            functionToken.beginColumn,
                            token.endColumn);
  }
}

//}}}
//{{{ FormalParameters(final ArrayList parameters)

/**
 * FormalParameters follows method identifier.
 * (FormalParameter())
 */
void FormalParameters(final ArrayList parameters) :
{
  FormalParameter var;
}
{
  try {
  <LPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  [
    var = FormalParameter()
    {parameters.add(var);}
      (
        <COMMA>
        try {
          var = FormalParameter()
          {parameters.add(var);}
        } catch (ParseException e) {
          fireParseError(new PHPParseErrorEvent(ERROR,
                                                path,
                                                "parameter expected",
                                                "parameter",
                                                e.currentToken.image,
                                                e.currentToken.sourceStart,
                                                e.currentToken.sourceEnd,
                                                e.currentToken.beginLine,
                                                e.currentToken.endLine,
                                                e.currentToken.endColumn,
                                                e.currentToken.endColumn+1));
        }
      )*
  ]
  try {
    <RPAREN>
  } catch (ParseException e) { //recup rparen si avant lbrace
      Token nextToken = getNextToken();
      while (nextToken.kind != EOF && nextToken.kind != RPAREN && nextToken.kind != LBRACE) {
        nextToken = getNextToken();
      }
      if (nextToken.kind == EOF) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected end of file",
                                              ")",
                                              e.currentToken.next.image,
                                              e.currentToken.sourceEnd,
                                              nextToken.sourceStart,
                                              e.currentToken.beginLine,
                                              nextToken.endLine,
                                              e.currentToken.endColumn,
                                              nextToken.endColumn));
      } else if (nextToken.kind == RPAREN) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected tokens",
                                              "",
                                              e.currentToken.next.image,
                                              e.currentToken.next.sourceEnd,
                                              nextToken.sourceStart,
                                              e.currentToken.next.beginLine,
                                              nextToken.beginLine,
                                              e.currentToken.next.endColumn+1,
                                              nextToken.beginColumn-1));
      } else {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                        path,
                                        "')' expected",
                                        ")",
                                        e.currentToken.next.image,
                                        e.currentToken.sourceEnd,
                                        nextToken.sourceStart,
                                        e.currentToken.beginLine,
                                        nextToken.endLine,
                                        e.currentToken.endColumn+1,
                                        nextToken.endColumn-1));
      }
  }
}

//}}}
//{{{ FormalParameter()

/**
 * A formal parameter.
 * $varname[=value] (,$varname[=value])
 */
FormalParameter FormalParameter() :
{
  final VariableDeclaration variableDeclaration;
  final FormalParameter parameter;
  Token bitAndToken = null;
}
{
  [bitAndToken = <BIT_AND>] variableDeclaration = VariableDeclaratorNoSuffix()
  {
    if (bitAndToken != null) {
      variableDeclaration.setReference(true,bitAndToken.sourceStart,bitAndToken.beginLine,bitAndToken.beginColumn);
    }
    Expression initialization = variableDeclaration.getInitialization();
    if (initialization == null) {
      parameter = new FormalParameter(variableDeclaration.getName(),
                                      bitAndToken != null,
                                      variableDeclaration.getSourceStart(),
                                      variableDeclaration.getSourceEnd(),
                                      variableDeclaration.getBeginLine(),
                                      variableDeclaration.getEndLine(),
                                      variableDeclaration.getBeginColumn(),
                                      variableDeclaration.getEndColumn());
    } else {
      parameter = new FormalParameter(variableDeclaration.getName(),
                                      bitAndToken != null,
                                      variableDeclaration.getInitialization().toStringExpression()                                      ,
                                      variableDeclaration.getSourceStart(),
                                      variableDeclaration.getSourceEnd(),
                                      variableDeclaration.getBeginLine(),
                                      variableDeclaration.getEndLine(),
                                      variableDeclaration.getBeginColumn(),
                                      variableDeclaration.getEndColumn());
    }
    return parameter;
  }
}

//}}}

//}}}

//{{{ Type()

ConstantIdentifier Type() :
{final Token token;}
{
  token = <STRING>    {return new ConstantIdentifier(token);}
| token = <BOOL>      {return new ConstantIdentifier(token);}
| token = <BOOLEAN>   {return new ConstantIdentifier(token);}
| token = <REAL>      {return new ConstantIdentifier(token);}
| token = <DOUBLE>    {return new ConstantIdentifier(token);}
| token = <FLOAT>     {return new ConstantIdentifier(token);}
| token = <INT>       {return new ConstantIdentifier(token);}
| token = <INTEGER>   {return new ConstantIdentifier(token);}
| token = <OBJECT>    {return new ConstantIdentifier(token);}
}

//}}}

//{{{ Expressions

//{{{ Expression()

Expression Expression() :
{
  final Expression expr;
  Expression initializer = null;
  Token assignOperator = null;
}
{
  LOOKAHEAD(1)
  expr = ConditionalExpression()
  [
    assignOperator = AssignmentOperator()
    initializer = Expression()
  ]
  {
    if (assignOperator != null) {// todo : change this, very very bad :(
        if (expr instanceof AbstractVariable) {
          if (initializer == null) {
            return new VariableDeclaration(currentSegment,
                                           (AbstractVariable) expr,
                                           null,
                                           assignOperator.image,
                                           expr.sourceStart,
                                           assignOperator.sourceEnd,
                                           expr.getBeginLine(),
                                           assignOperator.endLine,
                                           expr.getBeginColumn(),
                                           assignOperator.endColumn);
          }
          return new VariableDeclaration(currentSegment,
                                         (AbstractVariable) expr,
                                         initializer,
                                         assignOperator.image,
                                         expr.sourceStart,
                                         initializer.sourceEnd,
                                         expr.getBeginLine(),
                                         initializer.getEndLine(),
                                         expr.getBeginColumn(),
                                         initializer.getEndColumn());
        }
        final String varName = expr.toStringExpression().substring(1);
        return new VariableDeclaration(currentSegment,
                                       new Variable(varName,
                                                    expr.sourceStart,
                                                    expr.sourceEnd,
                                                    expr.getBeginLine(),
                                                    expr.getEndLine(),
                                                    expr.getBeginColumn(),
                                                    expr.getEndColumn()),
                                       expr.sourceStart,
                                       assignOperator.sourceEnd,
                                       expr.getBeginLine(),
                                       assignOperator.endLine,
                                       expr.getBeginColumn(),
                                       assignOperator.endColumn);
    }
    return expr;
  }
| expr = ExpressionWBang() {return expr;}
}

//}}}
//{{{ ExpressionWBang()

Expression ExpressionWBang() :
{
  final Expression expr;
  final Token bangToken;
}
{
  bangToken = <BANG> expr = ExpressionWBang()
  {return new PrefixedUnaryExpression(expr,
                                      OperatorIds.NOT,
                                      bangToken.sourceStart,
                                      bangToken.beginLine,
                                      bangToken.beginColumn);}
| expr = ExpressionNoBang() {return expr;}
}

//}}}
//{{{ ExpressionNoBang()

Expression ExpressionNoBang() :
{
  final Expression expr;
}
{
/*  expr = ListExpression()    {return expr;}
|*/
  expr = PrintExpression()   {return expr;}
}

//}}}
//{{{ AssignmentOperator()

/**
 * Any assignement operator.
 *
 * @return the assignement operator id
 */
Token AssignmentOperator() :
{
  final Token assignOperator;
}
{
  assignOperator = <ASSIGN>             {return assignOperator;}
| assignOperator = <STARASSIGN>         {return assignOperator;}
| assignOperator = <SLASHASSIGN>        {return assignOperator;}
| assignOperator = <REMASSIGN>          {return assignOperator;}
| assignOperator = <PLUSASSIGN>         {return assignOperator;}
| assignOperator = <MINUSASSIGN>        {return assignOperator;}
| assignOperator = <LSHIFTASSIGN>       {return assignOperator;}
| assignOperator = <RSIGNEDSHIFTASSIGN> {return assignOperator;}
| assignOperator = <ANDASSIGN>          {return assignOperator;}
| assignOperator = <XORASSIGN>          {return assignOperator;}
| assignOperator = <ORASSIGN>           {return assignOperator;}
| assignOperator = <DOTASSIGN>          {return assignOperator;}
| assignOperator = <TILDEEQUAL>         {return assignOperator;}
}

//}}}
//{{{ ConditionalExpression()

Expression ConditionalExpression() :
{
  final Expression expr;
  Expression expr2 = null;
  Expression expr3 = null;
}
{
  expr = ConditionalOrExpression() [ <HOOK> expr2 = Expression() <COLON> expr3 = ConditionalExpression() ]
{
  if (expr3 == null) {
    return expr;
  }
  return new ConditionalExpression(expr,expr2,expr3);
}
}

//}}}
//{{{ ConditionalOrExpression()

Expression ConditionalOrExpression() :
{
  Expression expr,expr2;
  int operator,sourceEnd,endLine,endColumn;
  Token orToken;
}
{
  expr = ConditionalAndExpression()
  (
    (
        orToken = <OR_OR> {operator = OperatorIds.OR_OR;}
      | orToken = <_ORL>  {operator = OperatorIds.ORL;}
      | orToken = <XOR>   {operator = OperatorIds.XOR;}
    )
    expr2 = ConditionalAndExpression()
    {
      if (expr2 == null) {
        sourceEnd = orToken.sourceEnd;
        endLine   = orToken.endLine;
        endColumn = orToken.endColumn;
      } else {
        sourceEnd = expr2.sourceEnd;
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,operator,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ ConditionalAndExpression()

Expression ConditionalAndExpression() :
{
  Expression expr,expr2;
  int operator,sourceEnd,endLine,endColumn;
  Token andToken;
}
{
  expr = ConcatExpression()
  (
  (  andToken = <AND_AND> {operator = OperatorIds.AND_AND;}
   | andToken = <_ANDL>   {operator = OperatorIds.ANDL;})
   expr2 = ConcatExpression() 
   {
     if (expr2 == null) {
       sourceEnd = andToken.sourceEnd;
       endLine   = andToken.endLine;
       endColumn = andToken.endColumn;
     } else {
       sourceEnd = expr2.sourceEnd;
       endLine   = expr2.getEndLine();
       endColumn = expr2.getEndColumn();
     }
     expr = new BinaryExpression(expr,expr2,operator,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
   }
  )*
  {return expr;}
}

//}}}
//{{{ ConcatExpression()

Expression ConcatExpression() :
{
  Expression expr,expr2;
  Token dotToken;
  int sourceEnd,endLine,endColumn;
}
{
  expr = InclusiveOrExpression()
  (
    dotToken = <DOT> expr2 = InclusiveOrExpression()
    {
      if (expr2 == null) {
        sourceEnd = dotToken.sourceEnd;
        endLine   = dotToken.endLine;
        endColumn = dotToken.endColumn;
      } else {
        sourceEnd = expr2.sourceEnd;
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,OperatorIds.DOT,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ InclusiveOrExpression()

Expression InclusiveOrExpression() :
{
  Expression expr,expr2;
  Token bitOrToken;
  int sourceEnd,endLine,endColumn;
}
{
  expr = ExclusiveOrExpression()
  (
   bitOrToken = <BIT_OR> expr2 = ExclusiveOrExpression()
   {
     if (expr2 == null) {
       sourceEnd = bitOrToken.sourceEnd;
       endLine   = bitOrToken.endLine;
       endColumn = bitOrToken.endColumn;
     } else {
       sourceEnd = expr2.sourceEnd;
       endLine   = expr2.getEndLine();
       endColumn = expr2.getEndColumn();
     }
     expr = new BinaryExpression(expr,expr2,OperatorIds.OR,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
   }
  )*
  {return expr;}
}

//}}}
//{{{ ExclusiveOrExpression()

Expression ExclusiveOrExpression() :
{
  Expression expr,expr2;
  Token bitXorToken;
  int sourceEnd,endLine,endColumn;
}
{
  expr = AndExpression()
  (
    bitXorToken = <BIT_XOR> expr2 = AndExpression()
    {
      if (expr2 == null) {
        sourceEnd = bitXorToken.sourceEnd;
        endLine   = bitXorToken.endLine;
        endColumn = bitXorToken.endColumn;
      } else {
        sourceEnd = expr2.sourceEnd;
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,OperatorIds.BIT_XOR,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}} 
//{{{ AndExpression()

Expression AndExpression() :
{
  Expression expr,expr2;
  Token bitAndToken;
  int sourceEnd,endLine,endColumn;
}
{
  expr = EqualityExpression()
  (
    LOOKAHEAD(1)
    bitAndToken = <BIT_AND> expr2 = EqualityExpression()
    {
      if (expr2 == null) {
        sourceEnd = bitAndToken.sourceEnd;
        endLine   = bitAndToken.endLine;
        endColumn = bitAndToken.endColumn;
      } else {
        sourceEnd = expr2.sourceEnd;
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,OperatorIds.AND,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ EqualityExpression()

Expression EqualityExpression() :
{
  Expression expr,expr2;
  int operator;
  Token token;
  int sourceEnd,endLine,endColumn;
}
{
  expr = RelationalExpression()
  (
  (   token = <EQUAL_EQUAL>      {operator = OperatorIds.EQUAL_EQUAL;}
    | token = <DIF>              {operator = OperatorIds.DIF;}
    | token = <NOT_EQUAL>        {operator = OperatorIds.DIF;}
    | token = <BANGDOUBLEEQUAL>  {operator = OperatorIds.BANG_EQUAL_EQUAL;}
    | token = <TRIPLEEQUAL>      {operator = OperatorIds.EQUAL_EQUAL_EQUAL;}
  )
  try {
    expr2 = RelationalExpression()
  } catch (ParseException e) {
    if (errorMessage != null) {
      throw e;
    }
    expr2 = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
                                   token.sourceEnd +1,
                                   token.sourceEnd +1,
                                   token.beginLine,
                                   token.endLine,
                                   token.beginColumn,
                                   token.endColumn);
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          token.sourceEnd,
                                          token.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    if (expr2 == null) {
      sourceEnd = token.sourceEnd;
      endLine   = token.endLine;
      endColumn = token.endColumn;
    } else {
      sourceEnd = expr2.sourceEnd;
      endLine   = expr2.getEndLine();
      endColumn = expr2.getEndColumn();
    }
    expr = new BinaryExpression(expr,expr2,operator,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
  }
  )*
  {return expr;}
}

//}}}
//{{{ RelationalExpression()

Expression RelationalExpression() :
{
  Expression expr,expr2;
  int operator, sourceEnd,endLine,endColumn;
  Token token;
}
{
  expr = ShiftExpression()
  (
  ( token = <LT> {operator = OperatorIds.LESS;}
  | token = <GT> {operator = OperatorIds.GREATER;}
  | token = <LE> {operator = OperatorIds.LESS_EQUAL;}
  | token = <GE> {operator = OperatorIds.GREATER_EQUAL;})
   expr2 = ShiftExpression()
  {
    if (expr2 == null) {
      sourceEnd = token.sourceEnd;
      endLine   = token.endLine;
      endColumn = token.endColumn;
    } else {
      sourceEnd = expr2.sourceEnd;
      endLine   = expr2.getEndLine();
      endColumn = expr2.getEndColumn();
    }
    expr = new BinaryExpression(expr,expr2,operator,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
  }
  )*
  {return expr;}
}

//}}}
//{{{ ShiftExpression()

Expression ShiftExpression() :
{
  Expression expr,expr2;
  int operator, sourceEnd,endLine,endColumn;
  Token token;
}
{
  expr = AdditiveExpression()
  (
  ( token = <LSHIFT>         {operator = OperatorIds.LEFT_SHIFT;}
  | token = <RSIGNEDSHIFT>   {operator = OperatorIds.RIGHT_SHIFT;}
  | token = <RUNSIGNEDSHIFT> {operator = OperatorIds.UNSIGNED_RIGHT_SHIFT;})
  expr2 = AdditiveExpression()
  {
    if (expr2 == null) {
      sourceEnd = token.sourceEnd;
      endLine   = token.endLine;
      endColumn = token.endColumn;
    } else {
      sourceEnd = expr2.sourceEnd;
      endLine   = expr2.getEndLine();
      endColumn = expr2.getEndColumn();
    }
    expr = new BinaryExpression(expr,expr2,operator,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
  }
  )*
  {return expr;}
}  

//}}}
//{{{ AdditiveExpression()

Expression AdditiveExpression() :
{
  Expression expr,expr2;
  int operator,sourceEnd,endLine,endColumn;
  Token token;
}
{
  expr = MultiplicativeExpression()
  (
    LOOKAHEAD(1)
     ( token = <PLUS>  {operator = OperatorIds.PLUS;}
     | token = <MINUS> {operator = OperatorIds.MINUS;}
  )
   expr2 = MultiplicativeExpression()
  {
    if (expr2 == null) {
      sourceEnd = token.sourceEnd;
      endLine   = token.endLine;
      endColumn = token.endColumn;
    } else {
      sourceEnd = expr2.sourceEnd;
      endLine   = expr2.getEndLine();
      endColumn = expr2.getEndColumn();
    }
    expr = new BinaryExpression(expr,expr2,operator,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
  }
   )*
  {return expr;}
}

//}}}
//{{{ MultiplicativeExpression()

Expression MultiplicativeExpression() :
{
  Expression expr,expr2;
  int operator,sourceEnd,endLine,endColumn;
  Token token;
}
{
  try {
    expr = UnaryExpression()
  } catch (ParseException e) {
    if (errorMessage != null) throw e;
    errorMessage = "unexpected token '"+e.currentToken.next.image+'\'';
    errorLevel   = ERROR;
    errorStart = this.token.sourceStart;
    errorEnd   = this.token.sourceEnd;
    throw e;
  }
  (
   (  token = <STAR>      {operator = OperatorIds.MULTIPLY;}
    | token = <SLASH>     {operator = OperatorIds.DIVIDE;}
    | token = <REMAINDER> {operator = OperatorIds.REMAINDER;})
    expr2 = UnaryExpression()
    {
      if (expr2 == null) {
        sourceEnd = token.sourceEnd;
        endLine   = token.endLine;
        endColumn = token.endColumn;
      } else {
        sourceEnd = expr2.sourceEnd;
        endLine   = expr2.getEndLine();
        endColumn = expr2.getEndColumn();
      }
      expr = new BinaryExpression(expr,expr2,operator,expr.sourceStart,sourceEnd,expr.getBeginLine(),endLine,expr.getBeginColumn(),endColumn);
    }
  )*
  {return expr;}
}

//}}}
//{{{ UnaryExpression()

/**
 * An unary expression starting with @, & or nothing.
 *
 * @return the unary expression
 */
Expression UnaryExpression() :
{
  final Expression expr;
}
{
 /* <BIT_AND> expr = UnaryExpressionNoPrefix()             //why did I had that ?
  {return new PrefixedUnaryExpression(expr,OperatorIds.AND,pos);}
|      */
  try {
    expr = AtNotTildeUnaryExpression() {return expr;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "unexpected token : '"+e.currentToken.image+'\'',
                                          "",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.beginColumn,
                                          e.currentToken.endColumn));
      Token nextToken = getNextToken();
      while (nextToken.kind != EOF && nextToken.kind != SEMICOLON) {
        nextToken = getNextToken();
      }
      if (nextToken.kind == EOF) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected end of file",
                                              ")",
                                              e.currentToken.next.image,
                                              e.currentToken.sourceEnd,
                                              nextToken.sourceStart,
                                              e.currentToken.beginLine,
                                              nextToken.endLine,
                                              e.currentToken.endColumn,
                                              nextToken.endColumn));
      } else {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                        path,
                                        "expression expected",
                                        ")",
                                        e.currentToken.next.image,
                                        e.currentToken.sourceEnd,
                                        nextToken.sourceStart,
                                        e.currentToken.beginLine,
                                        nextToken.endLine,
                                        e.currentToken.endColumn+1,
                                        nextToken.endColumn-1));
      }
      return null;
    /*



    getNextToken();
    return UnaryExpression();
    */
  }

}

//}}}
//{{{ AtNotTildeUnaryExpression()

Expression AtNotTildeUnaryExpression() :
{
  if (shouldStop) throw new ParsingAbortedError();
  final Expression expr;
  final Token token;
}
{
  token = <AT>
  expr = AtNotTildeUnaryExpression()
  {return new PrefixedUnaryExpression(expr,OperatorIds.AT,token.sourceStart,token.beginLine,token.beginColumn);}
|
  token = <TILDE>
  expr = AtNotTildeUnaryExpression()
  {return new PrefixedUnaryExpression(expr,OperatorIds.TWIDDLE,token.sourceStart,token.beginLine,token.beginColumn);}
|
  token = <BANG>
  expr = AtNotUnaryExpression()
  {return new PrefixedUnaryExpression(expr,OperatorIds.NOT,token.sourceStart,token.beginLine,token.beginColumn);}
|
  expr = UnaryExpressionNoPrefix()
  {return expr;}
}

//}}}
//{{{ AtNotUnaryExpression()

/**
 * An expression prefixed (or not) by one or more @ and !.
 * @return the expression
 */
Expression AtNotUnaryExpression() :
{
  final Expression expr;
  final Token token;
}
{
  token = <AT>
  expr = AtNotUnaryExpression()
  {return new PrefixedUnaryExpression(expr,OperatorIds.AT,token.sourceStart,token.beginLine,token.beginColumn);}
|
  token = <BANG>
  expr = AtNotUnaryExpression()
  {return new PrefixedUnaryExpression(expr,OperatorIds.NOT,token.sourceStart,token.beginLine,token.beginColumn);}
|
  expr = UnaryExpressionNoPrefix()
  {return expr;}
}

//}}}
//{{{ UnaryExpressionNoPrefix()

Expression UnaryExpressionNoPrefix() :
{
  final Expression expr;
  final Token token;
}
{
  token = <PLUS> expr = AtNotTildeUnaryExpression()   {return new PrefixedUnaryExpression(expr,
                                                                                     OperatorIds.PLUS,
                                                                                     token.sourceStart,
                                      token.beginLine,
                                      token.beginColumn);}
|
  token = <MINUS> expr = AtNotTildeUnaryExpression()  {return new PrefixedUnaryExpression(expr,
                                                                                     OperatorIds.MINUS,
                                                                                     token.sourceStart,
                                      token.beginLine,
                                      token.beginColumn);}
|
  expr = PreIncDecExpression()
  {return expr;}
|
  expr = UnaryExpressionNotPlusMinus()
  {return expr;}
}

//}}}
//{{{ PreIncDecExpression()

Expression PreIncDecExpression() :
{
final Expression expr;
final int operator;
final Token token;
}
{
  (
      token = <PLUS_PLUS>   {operator = OperatorIds.PLUS_PLUS;}
    |
      token = <MINUS_MINUS> {operator = OperatorIds.MINUS_MINUS;}
  )
  expr = PrimaryExpression()
  {return new PrefixedUnaryExpression(expr,operator,token.sourceStart,
                                      token.beginLine,
                                      token.beginColumn);}
}

//}}}
//{{{ UnaryExpressionNotPlusMinus()

Expression UnaryExpressionNotPlusMinus() :
{
  final Expression expr;
}
{
  LOOKAHEAD( <LPAREN> (Type() | <ARRAY>) <RPAREN> )
  expr = CastExpression()         {return expr;}
| expr = PostfixExpression()      {return expr;}
| expr = Literal()                {return expr;}
| expr = ListExpression()         {return expr;}

| <LPAREN> expr = Expression()
  try {
    <RPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')'n expected",
                                          ")",
                                          e.currentToken.image,
                                          expr.sourceEnd,
                                          expr.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return expr;}
}

//}}}
//{{{ CastExpression()

CastExpression CastExpression() :
{
final ConstantIdentifier type;
final Expression expr;
final Token token,token1;
}
{
  token1 = <LPAREN>
  (
      type = Type()
    |
      token = <ARRAY> {type = new ConstantIdentifier(token);}
  )
  <RPAREN> expr = UnaryExpression()
  {return new CastExpression(type,
                             expr,
                             token1.sourceStart,
                             expr.sourceEnd,
                             token1.beginLine,
                             expr.getEndLine(),
                             token1.beginColumn,
                             expr.getEndColumn());}
}

//}}}
//{{{ PostfixExpression()

Expression PostfixExpression() :
{
  final Expression expr;
  int operator = -1;
  Token token = null;
}
{
  expr = PrimaryExpression()
  [
      token = <PLUS_PLUS>   {operator = OperatorIds.PLUS_PLUS;}
    |
      token = <MINUS_MINUS> {operator = OperatorIds.MINUS_MINUS;}
  ]
  {
    if (operator == -1) {
      return expr;
    }
    return new PostfixedUnaryExpression(expr,
                                        operator,
                                        token.sourceEnd,
                                        token.endLine,
                                        token.endColumn);
  }
}

//}}}
//{{{ PrimaryExpression()

Expression PrimaryExpression() :
{
  final Expression expr;
  Token token = null;
}
{
  [token = <BIT_AND>] expr = refPrimaryExpression(token)
  {return expr;}
|
  expr = ArrayDeclarator()
  {return expr;}
}

//}}}
//{{{ refPrimaryExpression(final Token reference)

Expression refPrimaryExpression(final Token reference) :
{
  Expression expr;
  Expression expr2 = null;
  final Token identifier, newToken;
  Token staticClassAccess;
}
{
  identifier = <IDENTIFIER>
  {
    expr = new ConstantIdentifier(identifier);
  }
  (
    staticClassAccess = <STATICCLASSACCESS>
    try {
      expr2 = ClassIdentifier()
      {
        expr = new ClassAccess(expr,expr2,ClassAccess.STATIC,expr2.getSourceEnd(),expr2.getEndLine(),expr2.getEndColumn());
      }
    } catch (ParseException e) {
      expr = new ClassAccess(expr,null,ClassAccess.STATIC,staticClassAccess.sourceEnd,staticClassAccess.endLine,staticClassAccess.endColumn);
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "identifier expected",
                                            "identifier",
                                            e.currentToken.image,
                                            e.currentToken.sourceStart,
                                            e.currentToken.sourceEnd,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
    }
  )*
  [ expr2 = Arguments(expr) ]
  {
    if (expr2 == null) {
      if (reference != null) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "you cannot use a constant by reference",
                                              "",
                                              "&",
                                              reference.sourceStart,
                                              reference.sourceEnd,
                                              reference.beginLine,
                                              reference.endLine,
                                              reference.endColumn,
                                              reference.endColumn+1));
      }
      return expr;
    }
    return expr2;
  }
|
  expr = VariableDeclaratorId()  //todo use the reference parameter ...
  [ expr = Arguments(expr) ]
  {return expr;}
|
  newToken = <NEW>
  expr = ClassIdentifier()
  {
    final int start, beginLine, beginColumn;
    if (reference == null) {
      start       = newToken.sourceStart;
      beginLine   = newToken.beginLine;
      beginColumn = newToken.beginColumn;
    } else {
      start       = reference.sourceStart;
      beginLine   = reference.beginLine;
      beginColumn = reference.beginColumn;
    }
    expr = new ClassInstantiation(expr,
                                  reference != null,
                                  start,
                                  beginLine,
                                  beginColumn);
  }
  [ expr = Arguments(expr) ]
  {return expr;}
}

//}}}
//{{{ ArrayDeclarator()

/**
 * An array declarator.
 * array(vars)
 * @return an array
 */
ArrayInitializer ArrayDeclarator() :
{
  final ArrayVariableDeclaration[] vars;
  final Token token;
}
{
  token = <ARRAY> vars = ArrayInitializer()
  {return new ArrayInitializer(vars,
                               token.sourceStart,
                               this.token.sourceEnd,
                               token.beginLine,
                               this.token.endLine,
                               token.beginColumn,
                               this.token.endColumn);}
}

//}}}
//{{{ ClassIdentifier()

Expression ClassIdentifier():
{
  final Expression expr;
  final Token identifierToken;
}
{
  identifierToken = <IDENTIFIER> {return new ConstantIdentifier(identifierToken);}
| expr = Type()                  {return expr;}
| expr = VariableDeclaratorId()  {return expr;}
}

//}}}
//{{{ VariableSuffix(final AbstractVariable prefix)

/**
 * Used by Variabledeclaratorid and primarysuffix
 */
AbstractVariable VariableSuffix(final AbstractVariable prefix) :
{
  Expression expression = null;
  final Token classAccessToken,lbrace,rbrace;
  Token token;
  int pos;
}
{
  classAccessToken = <CLASSACCESS>
  try {
    (
      lbrace = <LBRACE> expression = Expression() rbrace = <RBRACE>
                {
                 expression = new Variable(expression,
                              lbrace.sourceStart,
                              rbrace.sourceEnd,
                              lbrace.beginLine,
                              rbrace.endLine,
                              lbrace.beginColumn,
                              rbrace.endColumn);
                }
      |
        token = <IDENTIFIER>
        {expression = new ConstantIdentifier(token);}
      |
        expression = Variable()
    )
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "function call or field access expected",
                                          "",
                                          e.currentToken.image,
                                          classAccessToken.sourceEnd,
                                          classAccessToken.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  { //Here "expression" can be null !
    if (expression == null) {
      return new ClassAccess(prefix,
                             expression,
                             ClassAccess.NORMAL,
                             classAccessToken.sourceEnd,
                             classAccessToken.endLine,
                             classAccessToken.endColumn);
    } else {
      return new ClassAccess(prefix,
                             expression,
                             ClassAccess.NORMAL,
                             expression.getSourceEnd(),
                             expression.getEndLine(),
                             expression.getEndColumn());
    }
  }
|
  token = <LBRACKET> {pos = token.sourceEnd+1;}
  [  expression = Expression() {pos = expression.sourceEnd+1;}
   | expression = Type()       {pos = expression.sourceEnd+1;}]  //Not good
  try {
    token = <RBRACKET>
    {pos = token.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "']' expected",
                                          "]",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return new ArrayDeclarator(prefix,
                              expression,
                              pos,
                              token.endLine,
                              token.endColumn);}
|
  token = <LBRACE> {pos = token.sourceEnd+1;}
  [  expression = Expression() {pos = expression.sourceEnd+1;}
   | expression = Type()       {pos = expression.sourceEnd+1;}]  //Not good
  try {
    token = <RBRACE>
    {pos = token.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'}' expected",
                                          "}",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return new ArrayDeclarator(prefix,
                              expression,
                              pos,
                              token.endLine,
                              token.endColumn);}//todo : check braces here
}

//}}}
//{{{ Literal()

Literal Literal() :
{
  final Token token;
  final StringLiteral heredoc;
}
{
  token = <INTEGER_LITERAL>        {return new NumberLiteral(token);}
| token = <FLOATING_POINT_LITERAL> {return new NumberLiteral(token);}
| token = <STRING_LITERAL>         {return new StringLiteral(token);}
| token = <TRUE>                   {return new TrueLiteral(token);}
| token = <FALSE>                  {return new FalseLiteral(token);}
| token = <NULL>                   {return new NullLiteral(token);}
| heredoc = heredoc()              {return heredoc;}
//| literal = evaluableString()        {return literal;}
}

//}}}
//{{{ heredoc()

StringLiteral heredoc() :
{
  final Token heredocStart;
  Token startToken = null;
  Token endToken;
  String endImage;
}
{
  heredocStart = <HEREDOCSTARTTOKEN>
  try {
    startToken = <IDENTIFIER>
    {
      if(heredocStart.sourceEnd != startToken.sourceStart) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "unexpected spaces",
                                              "",
                                              "",
                                              heredocStart.sourceEnd+1,
                                              startToken.sourceStart-1,
                                              startToken.beginLine,
                                              startToken.endLine,
                                              heredocStart.endColumn+1,
                                              startToken.beginColumn-1));
      }
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "identifier expected",
                                          "identifier",
                                          e.currentToken.image,
                                          errorStart,
                                          errorEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    return new StringLiteral("",
                                        jj_input_stream.getBeginOffset(),
                                        jj_input_stream.getBeginOffset()+1,
                                        jj_input_stream.getBeginLine(),
            jj_input_stream.getEndLine(),
            jj_input_stream.getBeginColumn(),
            jj_input_stream.getEndColumn());
  }
  {
  while (true) {
    endToken = getNextToken();
    // Ensure that the parser will stay in php mode even if there is a ?> in the string
    // todo : find another trick it's seems ugly
    token_source.SwitchTo(PHPParserTokenManager.PHPPARSING);
    if (endToken.kind == PHPParserConstants.EOF) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "unexpected EOF",
                                            "",
                                            "",
                                            endToken.sourceStart,
                                            endToken.sourceEnd,
                                            endToken.beginLine,
                                            endToken.endLine,
                                            endToken.beginColumn,
                                            endToken.endColumn));
      break;
    }

    if (endToken.beginLine == startToken.beginLine) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "unexpected token",
                                            "identifier",
                                            endToken.image,
                                            endToken.sourceStart,
                                            endToken.sourceEnd,
                                            endToken.beginLine,
                                            endToken.endLine,
                                            endToken.beginColumn,
                                            endToken.endColumn));
      continue;
    }
    if (endToken.beginColumn != 1) continue;
    endImage = (endToken.image.charAt(endToken.image.length()-1) == ';') ? endToken.image.substring(0,endToken.image.length()-2) : endToken.image;
    if (endImage.equals(startToken.image)) {
      break;
    }
  }

  return new StringLiteral(jj_input_stream.getCurrentBuffer().substring(startToken.sourceEnd+1,endToken.sourceStart-1),
                           startToken.sourceEnd+1,
                           endToken.sourceStart-1,
                           startToken.beginLine,
                           endToken.endLine,
                           startToken.beginColumn,
                           endToken.endColumn);
  }
}

//}}}
//{{{ evaluableString()
       
              /*
StringLiteral evaluableString() :
{
  ArrayList list = new ArrayList();
  Token start,end;
  Token token,lbrace,rbrace;
  AbstractVariable var;
  Expression expr;
}
{
  start = <DOUBLEQUOTE>
  (
   <DOLLARS>
       (
        token = <IDENTIFIER> {list.add(new Variable(token.image,
                                                    token.sourceStart,
                                                    token.sourceEnd));}
        |
         lbrace = <LBRACE1>
         token = <ID>
         {list.add(new Variable(token.image,
                                token.sourceStart,
                                token.sourceEnd));}
         rbrace = <RBRACE1>
       )
   )*
  end = <DOUBLEQUOTE2>
  {
  AbstractVariable[] vars = new AbstractVariable[list.size()];
  list.toArray(vars);
  return new StringLiteral(jj_input_stream.getCurrentBuffer().substring(start.sourceEnd,end.sourceStart),
                           start.sourceStart,
                           end.sourceEnd,
                           vars);
  }
}
  */
  
  //}}}
//{{{ Arguments(final Expression func)

FunctionCall Arguments(final Expression func) :
{
Expression[] args = null;
final Token rparen,lparen;
}
{
  lparen = <LPAREN> [ args = ArgumentList() ]
  try {
    rparen = <RPAREN>
    {return new FunctionCall(func,
                             args,
                             rparen.sourceEnd,
                             rparen.endLine,
                             rparen.endColumn);}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          errorStart,
                                          errorEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
  final int sourceEnd, line, column;
  if (args == null || args.length == 0) {
    sourceEnd = lparen.sourceEnd+1;
    line = lparen.beginLine;
    column = lparen.beginColumn;
  } else {
    sourceEnd = args[args.length-1].sourceEnd;
    line = args[args.length-1].getBeginLine();
    column = args[args.length-1].getBeginColumn();
  }

  return new FunctionCall(func,
                          args,
                          sourceEnd,
                          line,
                          column);}
}

//}}}
//{{{ ArgumentList()

/**
 * An argument list is a list of arguments separated by comma :
 * argumentDeclaration() (, argumentDeclaration)*
 * @return an array of arguments
 */
Expression[] ArgumentList() :
{
Expression arg;
final ArrayList list = new ArrayList();
int pos;
Token token;
}
{
  arg = Expression()
  {list.add(arg);pos = arg.sourceEnd;}
  ( token = <COMMA> {pos = token.sourceEnd;}
      try {
        arg = Expression()
        {list.add(arg);
         pos = arg.sourceEnd;}
      } catch (ParseException e) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "expression expected",
                                              "expression",
                                              e.currentToken.image,
                                              pos,
                                              pos+1,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.endColumn,
                                              e.currentToken.endColumn+1));
      }
   )*
   {
   final Expression[] arguments = new Expression[list.size()];
   list.toArray(arguments);
   return arguments;}
}

//}}}
//{{{ StatementNoBreak()

/**
 * A Statement without break.
 * @return a statement
 */
Statement StatementNoBreak() :
{
  final Statement statement;
  Token token = null;
}
{
  LOOKAHEAD(2)
  statement = expressionStatement()     {return statement;}
| LOOKAHEAD(2)
  statement = LabeledStatement()        {return statement;}
| statement = Block()                   {return statement;}
| statement = EmptyStatement()          {return statement;}
| statement = SwitchStatement()         {return statement;}
| statement = IfStatement()             {return statement;}
| statement = WhileStatement()          {return statement;}
| statement = DoStatement()             {return statement;}
| statement = ForStatement()            {return statement;}
| statement = ForeachStatement()        {return statement;}
| statement = ContinueStatement()       {return statement;}
| statement = ReturnStatement()         {return statement;}
| statement = EchoStatement()           {return statement;}
| [token=<AT>] statement = IncludeStatement()
  {if (token != null) {
    ((InclusionStatement)statement).silent = true;
    statement.sourceStart = token.sourceStart;
  }
  return statement;}
| statement = StaticStatement()         {return statement;}
| statement = GlobalStatement()         {return statement;}
| statement = defineStatement()         {currentSegment.add((Outlineable)statement);return statement;}
}

//}}}
//{{{ expressionStatement()

/**
 * A statement expression.
 * expression ;
 * @return an expression
 */
Statement expressionStatement() :
{
  final Statement statement;
  Token token;
}
{
  try {
    statement = Expression()
  } catch (ParseException e) {
    token = error_skipto(SEMICOLON);
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          e.currentToken.sourceEnd,
                                          token.sourceEnd,
                                          e.currentToken.beginLine,
                                          token.endLine,
                                          e.currentToken.endColumn,
                                          token.beginColumn));
    return new EmptyStatement(e.currentToken.sourceStart,
                              token.sourceEnd,
                              e.currentToken.beginLine,
                              token.endLine,
                              e.currentToken.beginColumn,
                              token.endColumn);
  }
  try {
    token = <SEMICOLON>
    {statement.sourceEnd = token.sourceEnd;}
  } catch (ParseException e) {
    if (e.currentToken.next.kind != PHPParserConstants.PHPEND) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "';' expected",
                                            ";",
                                            e.currentToken.image,
                                            statement.sourceEnd,
                                            statement.sourceEnd+1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
    }
  }
  {return statement;}
}

//}}}
//{{{ defineStatement()

Define defineStatement() :
{
  Expression defineName,defineValue;
  final Token defineToken;
  Token token;
  int pos;
}
{
  defineToken = <DEFINE> {pos = defineToken.sourceEnd+1;}
  try {
    token = <LPAREN>
    {pos = token.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    defineName = Expression()
    {pos = defineName.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    defineName = new StringLiteral(SYNTAX_ERROR_CHAR,pos,pos,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1);
  }
  try {
    token = <COMMA>
    {pos = defineName.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "',' expected",
                                          ",",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    defineValue = Expression()
    {pos = defineValue.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    defineValue = new StringLiteral(SYNTAX_ERROR_CHAR,pos,pos,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1);
  }
  try {
    token = <RPAREN>
    {pos = token.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return new Define(currentSegment,
                     defineName,
                     defineValue,
                     defineToken.sourceStart,
                     pos,
                     defineToken.beginLine,
                     defineToken.endLine,
                     defineToken.beginColumn,
                     defineToken.endColumn);}
}

/**
 * A Normal statement.
 */
Statement Statement() :
{
  final Statement statement;
}
{
  statement = StatementNoBreak() {return statement;}
| statement = BreakStatement()   {return statement;}
}

//}}}
//{{{ htmlBlock()

/**
 * An html block inside a php syntax.
 */
HTMLBlock htmlBlock() :
{
  final int startIndex = nodePtr;
  final AstNode[] blockNodes;
  final int nbNodes;
  final Token phpEnd;
}
{
  phpEnd = <PHPEND>
  {
    htmlStart = phpEnd.sourceEnd;
    htmlLineStart = phpEnd.endLine;
    htmlColumnStart = phpEnd.endColumn;
  }
  (phpEchoBlock())*
  try {
    (<PHPSTARTLONG> | <PHPSTARTSHORT>)
    {createNewHTMLCode();}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'<?php' expected",
                                          "<?php",
                                          e.currentToken.image,
                                          e.currentToken.next.sourceStart,
                                          e.currentToken.next.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
  nbNodes    = nodePtr - startIndex;
  if (nbNodes == 0) {
    return null;
  }
  blockNodes = new AstNode[nbNodes];
  System.arraycopy(nodes,startIndex+1,blockNodes,0,nbNodes);
  nodePtr = startIndex;
  return new HTMLBlock(blockNodes);}
}

//}}}
//{{{ IncludeStatement()

/**
 * An include statement. It's "include" an expression;
 */
InclusionStatement IncludeStatement() :
{
  Expression expr;
  final int keyword;
  final InclusionStatement inclusionStatement;
  final Token token, token2;
  int pos,line,column;
}
{
      (  token = <REQUIRE>      {keyword = InclusionStatement.REQUIRE     ;pos=token.sourceEnd;line=token.beginLine;column=token.beginColumn;}
       | token = <REQUIRE_ONCE> {keyword = InclusionStatement.REQUIRE_ONCE;pos=token.sourceEnd;line=token.beginLine;column=token.beginColumn;}
       | token = <INCLUDE>      {keyword = InclusionStatement.INCLUDE     ;pos=token.sourceEnd;line=token.beginLine;column=token.beginColumn;}
       | token = <INCLUDE_ONCE> {keyword = InclusionStatement.INCLUDE_ONCE;pos=token.sourceEnd;line=token.beginLine;column=token.beginColumn;})
  try {
    expr = Expression()
    {
      pos = expr.sourceEnd;
      line = expr.getBeginLine();
      column = expr.getBeginColumn();
    }
  } catch (ParseException e) {
    if (errorMessage != null) {
      throw e;
    }
    expr = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
                                  pos,
                                  pos+1,
                                  line,
                                  line,
                                  column,
                                  column+1);
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          e.currentToken.next.sourceStart,
                                          e.currentToken.next.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    token2 = <SEMICOLON>
    {pos=token2.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          e.currentToken.next.sourceStart,
                                          e.currentToken.next.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
   inclusionStatement = new InclusionStatement(currentSegment,
                                               keyword,
                                               expr,
                                               token.sourceStart,
                                               pos);
   currentSegment.add(inclusionStatement);
   return inclusionStatement;
  }
}

//}}}
//{{{ PrintExpression()

PrintExpression PrintExpression() :
{
  final Expression expr;
  final Token printToken;
}
{
  printToken = <PRINT> expr = Expression()
  {return new PrintExpression(expr,printToken.sourceStart,expr.sourceEnd,printToken.beginLine,expr.getEndLine(),printToken.beginColumn,expr.getEndColumn());}
}

//}}}
//{{{ ListExpression()

ListExpression ListExpression() :
{
  Expression expr = null;
  final ArrayList list = new ArrayList();
  int pos,line,column;
  final Token listToken, rParen;
  Token token;
}
{
  listToken = <LIST> {pos = listToken.sourceEnd;line=listToken.beginLine;column=listToken.beginColumn;}
  try {
    token = <LPAREN> {pos = token.sourceEnd;line=token.beginLine;column=token.beginColumn;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          listToken.sourceEnd,
                                          listToken.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  [
    expr = VariableDeclaratorId()
    {list.add(expr);pos = expr.sourceEnd;line=expr.getBeginLine();column=expr.getBeginColumn();}
  ]
  {if (expr == null) list.add(null);}
  (
    try {
      token = <COMMA>
      {pos = token.sourceEnd;line=token.beginLine;column=token.beginColumn;}
    } catch (ParseException e) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "',' expected",
                                            ",",
                                            e.currentToken.image,
                                            pos,
                                            pos+1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
    }
    [expr = VariableDeclaratorId() {list.add(expr);pos = expr.sourceEnd;line=expr.getBeginLine();column=expr.getBeginColumn();}]
  )*
  try {
    rParen = <RPAREN>
    {pos = rParen.sourceEnd;line=rParen.beginLine;column=rParen.beginColumn;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    final AbstractVariable[] vars = new AbstractVariable[list.size()];
    list.toArray(vars);
    return new ListExpression(vars,
                              listToken.sourceStart,
                              pos,
                              listToken.beginLine,
                              line,
                              listToken.beginColumn,
                              column);}
}

//}}}

//}}}

//{{{ Statements

//{{{ EchoStatement()

/**
 * An echo statement.
 * echo anyexpression (, otherexpression)*
 */
EchoStatement EchoStatement() :
{
  final ArrayList expressions = new ArrayList();
  Expression expr;
  final Token echoToken;
  Token semicolonToken = null;
}
{
  echoToken = <ECHO> expr = Expression()
  {expressions.add(expr);}
  (
    <COMMA> expr = Expression()
    {expressions.add(expr);}
  )*
  try {
    semicolonToken = <SEMICOLON>
  } catch (ParseException e) {
    if (e.currentToken.next.kind != 4) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                            "';' expected",
                                            ";",
                                            e.currentToken.image,
                                            e.currentToken.sourceEnd,
                                            e.currentToken.sourceEnd+1,
                                            e.currentToken.beginLine,
                                            e.currentToken.endLine,
                                            e.currentToken.endColumn,
                                            e.currentToken.endColumn+1));
    }
  }
  {
   final Expression[] exprs = new Expression[expressions.size()];
   expressions.toArray(exprs);
   if (semicolonToken == null) {
     return new EchoStatement(exprs,
                              echoToken.sourceStart, 
                              exprs[exprs.length-1].sourceEnd,
                              echoToken.beginLine,
                              exprs[exprs.length-1].getEndLine(),
                              echoToken.beginColumn,
                              exprs[exprs.length-1].getEndColumn());
   }
   return new EchoStatement(exprs,
                            echoToken.sourceStart,
                            semicolonToken.sourceEnd,
                            echoToken.beginLine,
                            semicolonToken.endLine,
                            echoToken.beginColumn,
                            semicolonToken.endColumn);
   }
}

//}}}
//{{{ GlobalStatement()

GlobalStatement GlobalStatement() :
{
   Variable expr;
   final ArrayList vars = new ArrayList();
   final GlobalStatement global;
   final Token token, token2;
   int pos,line,column;
}
{
  token = <GLOBAL>
    expr = Variable()
    {vars.add(expr);pos = expr.sourceEnd+1;line=expr.getEndLine();column=expr.getEndColumn();}
  (<COMMA>
    expr = Variable()
    {vars.add(expr);pos = expr.sourceEnd+1;line=expr.getEndLine();column=expr.getEndColumn();}
  )*
  try {
    token2 = <SEMICOLON>
    {pos = token2.sourceEnd+1;line=token2.endLine;column=token2.endColumn;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
    {
    final Variable[] variables = new Variable[vars.size()];
    vars.toArray(variables);
    global = new GlobalStatement(currentSegment,
                                 variables,
                                 token.sourceStart,
                                 pos,
                                 token.beginLine,
                                 line,
                                 token.beginColumn,
                                 column);
    currentSegment.add(global);
    return global;}
}

//}}}
//{{{ StaticStatement()

StaticStatement StaticStatement() :
{
  final ArrayList vars = new ArrayList();
  VariableDeclaration expr;
  final Token token, token2;
  int pos,line,column;
}
{
  token = <STATIC> expr = VariableDeclarator() {vars.add(expr);pos = expr.sourceEnd+1;line=expr.getEndLine();column=expr.getEndColumn();}
  (
    <COMMA> expr = VariableDeclarator() {vars.add(expr);pos = expr.sourceEnd+1;line=expr.getEndLine();column=expr.getEndColumn();}
  )*
  try {
    token2 = <SEMICOLON>
    {pos = token2.sourceEnd+1;line=token2.endLine;column=token2.endColumn;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
    {
    final VariableDeclaration[] variables = new VariableDeclaration[vars.size()];
    vars.toArray(variables);
    return new StaticStatement(variables,
                               token.sourceStart,
                               pos,
                               token.beginLine,
                               line,
                               token.beginColumn,
                               column);}
}

//}}}
//{{{ LabeledStatement()

LabeledStatement LabeledStatement() :
{
  final Token label;
  Statement statement = null;
}
{
  label = <IDENTIFIER>
  try {
    <COLON>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "':' expected",
                                          ":",
                                          e.currentToken.image,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    statement = Statement()
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "statement expected",
                                          "statement",
                                          e.currentToken.image,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    return new LabeledStatement(label.image,statement,label.sourceStart,e.currentToken.sourceEnd);
  }
  {return new LabeledStatement(label.image,statement,label.sourceStart,statement.sourceEnd);}
}

//}}}
//{{{ Block()

/**
 * A Block is
 * {
 * statements
 * }.
 * @return a block
 */
Block Block() :
{
  final ArrayList list = new ArrayList();
  Statement statement;
  final Token lbrace, rbrace;
  int pos,endLine,endColumn;
  int start, beginLine, beginColumn;
}
{
  try {
    lbrace = <LBRACE>
    {
      pos         = lbrace.sourceEnd+1;
      start       = lbrace.sourceStart;
      beginLine   = lbrace.beginLine;
      beginColumn = lbrace.beginColumn;
      endLine     = lbrace.endLine;
      endColumn   = lbrace.endColumn;
    }
  } catch (ParseException e) {
    pos         = this.token.sourceEnd+1;
    start       = pos;
    beginLine   = this.token.endLine;
    beginColumn = this.token.endColumn;
    endLine     = this.token.endLine;
    endColumn   = this.token.endColumn;
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'{' expected",
                                          "{",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  ( statement = BlockStatement()
    {
      if (statement != null) {
        list.add(statement);
        pos         = statement.sourceEnd+1;
        endLine     = statement.getEndLine();
        endColumn   = statement.getEndColumn();
      }
    }
  | statement = htmlBlock()      {if (statement != null) {
                                    list.add(statement);
                                    pos       = statement.sourceEnd+1;
                                    endLine   = statement.getEndLine();
                                    endColumn = statement.getEndColumn();
                                  } else {
                                    pos       = this.token.sourceEnd+1;
                                    endLine   = this.token.endLine;
                                    endColumn = this.token.endColumn;
                                  }
                                 }
  )*
  try {
    rbrace = <RBRACE>
    {
      pos       = rbrace.sourceEnd+1;
      endLine   = rbrace.endLine;
      endColumn = rbrace.endColumn;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'}' expected",
                                          "}",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
  final Statement[] statements = new Statement[list.size()];
  list.toArray(statements);
  return new Block(statements,
                   start,
                   pos,
                   beginLine,
                   endLine,
                   beginColumn,
                   endColumn);}
}

//}}}
//{{{ BlockStatement()

Statement BlockStatement() :
{
  final Statement statement;
}
{
  try {
    statement = Statement() {if (phpDocument == currentSegment) pushOnAstNodes(statement); return statement;}
  } catch (ParseException e) {
    final Token semicolumn = error_skipto(SEMICOLON);
    final Token nextToken = e.currentToken.next;
    if (nextToken == semicolumn) {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "statement expected",
                                            "statement",
                                            nextToken.image,
                                            nextToken.sourceEnd,
                                            semicolumn.sourceStart,
                                            nextToken.endLine,
                                            semicolumn.beginLine,
                                            nextToken.endColumn,
                                            semicolumn.beginColumn));
    } else {
      fireParseError(new PHPParseErrorEvent(ERROR,
                                            path,
                                            "statement expected",
                                            "statement",
                                            nextToken.image,
                                            nextToken.sourceStart,
                                            nextToken.sourceEnd,
                                            nextToken.beginLine,
                                            nextToken.endLine,
                                            nextToken.beginColumn,
                                            nextToken.endColumn));
    }
    return null;
  }
/*  } catch (ParseException e) {
    errorMessage = "unexpected token : '"+ e.currentToken.image +"', a statement was expected";
    errorLevel   = ERROR;
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }*/
| statement = ClassDeclaration()  {return statement;}
| statement = MethodDeclaration() {if (phpDocument == currentSegment) pushOnAstNodes(statement);
                                   currentSegment.add((MethodDeclaration) statement);
                                   ((MethodDeclaration) statement).analyzeCode(this);
                                   return statement;}
}

//}}}
//{{{ BlockStatementNoBreak()

/**
 * A Block statement that will not contain any 'break'
 */
Statement BlockStatementNoBreak() :
{
  final Statement statement;
}
{
  statement = StatementNoBreak()  {return statement;}
| statement = ClassDeclaration()  {return statement;}
| statement = MethodDeclaration() {currentSegment.add((MethodDeclaration) statement);
                                   ((MethodDeclaration) statement).analyzeCode(this);
                                   return statement;}
}

//}}}
//{{{ LocalVariableDeclaration()

/**
 * used only by ForInit()
 */
Expression[] LocalVariableDeclaration() :
{
  final ArrayList list = new ArrayList();
  Expression var;
}
{
  var = Expression()
  {list.add(var);}
  ( <COMMA> var = Expression() {list.add(var);})*
  {
    final Expression[] vars = new Expression[list.size()];
    list.toArray(vars);
    return vars;
  }
}

//}}}
//{{{ LocalVariableDeclarator()

/**
 * used only by LocalVariableDeclaration().
 */
VariableDeclaration LocalVariableDeclarator() :
{
  final Variable varName;
  Expression initializer = null;
}
{
  varName = Variable() [ <ASSIGN> initializer = Expression() ]
  {
   if (initializer == null) {
    return new VariableDeclaration(currentSegment,
                                   varName,
                                   varName.sourceStart,
                                   varName.sourceEnd,
                                   varName.getBeginLine(),
                                   varName.getEndLine(),
                                   varName.getBeginColumn(),
                                   varName.getEndColumn());
   }
    return new VariableDeclaration(currentSegment,
                                   varName,
                                   initializer,
                                   "=",
                                   varName.sourceStart,
                                   initializer.sourceEnd,
                                   varName.getBeginLine(),
                                   initializer.getEndLine(),
                                   varName.getBeginColumn(),
                                   initializer.getEndColumn());
  }
}

//}}}
//{{{ EmptyStatement()

/**
 * An empty statement.
 * It will generate an INFO marker
 *
 * @return an empty statement
 */
EmptyStatement EmptyStatement() :
{
  final Token token;
}
{
  token = <SEMICOLON>
  {
/*    fireParseMessage(new PHPParseMessageEvent(INFO,
                                              path,
                                              "unneeded ';'",
                                              token.sourceStart,
                                              token.sourceEnd,
                                              token.beginLine,
                                              token.endLine,
                                              token.endColumn,
                                              token.endColumn+1));   */
    return new EmptyStatement(token.sourceStart,
                              token.sourceEnd,
                              token.beginLine,
                              token.endLine,
                              token.beginColumn,
                              token.endColumn);
  }
}

//}}}
//{{{ StatementExpression()

/**
 * used only by StatementExpressionList() which is used only by ForInit() and ForStatement()
 */
Expression StatementExpression() :
{
  final Expression expr;
  final Token operator;
}
{
  expr = PreIncDecExpression() {return expr;}
|
  expr = PrimaryExpression()
  [ operator = <PLUS_PLUS> {return new PostfixedUnaryExpression(expr,
                                                                OperatorIds.PLUS_PLUS,
                                                                operator.sourceEnd,
                                                                operator.endLine,
                                                                operator.endColumn);}
  | operator = <MINUS_MINUS> {return new PostfixedUnaryExpression(expr,
                                                                  OperatorIds.MINUS_MINUS,
                                                                  operator.sourceEnd,
                                                                  operator.endLine,
                                                                  operator.endColumn);}
  ]
  {return expr;}
}

//}}}
//{{{ SwitchStatement()

SwitchStatement SwitchStatement() :
{
  Expression variable;
  final AbstractCase[] cases;
  final Token switchToken,lparenToken,rparenToken;
  int pos;
}
{
  switchToken = <SWITCH> {pos = switchToken.sourceEnd+1;}
  try {
    lparenToken = <LPAREN>
    {pos = lparenToken.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    variable = Expression() {pos = variable.sourceEnd+1;}
  } catch (ParseException e) {
    if (errorMessage != null) {
      throw e;
    }
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "expression expected",
                                          "expression",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    variable = new ConstantIdentifier(SYNTAX_ERROR_CHAR,
                                      pos,
                                      pos,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1);
  }
  try {
    rparenToken = <RPAREN> {pos = rparenToken.sourceEnd+1;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  (  cases = switchStatementBrace()
   | cases = switchStatementColon(switchToken.sourceStart, switchToken.sourceEnd))
  {return new SwitchStatement(variable,
                              cases,
                              switchToken.sourceStart,
                              token.sourceEnd,
                              switchToken.beginLine,
                              token.endLine,
                              switchToken.beginColumn,
                              token.endColumn);}
}

//}}}
//{{{ switchStatementBrace()

AbstractCase[] switchStatementBrace() :
{
  AbstractCase cas;
  final ArrayList cases = new ArrayList();
  Token token;
  int pos;
}
{
  token = <LBRACE> {pos = token.sourceEnd;}
 ( cas = switchLabel0() {cases.add(cas);pos = cas.sourceEnd;})*
  try {
    token = <RBRACE>
    {pos = token.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'}' expected",
                                          "}",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    final AbstractCase[] abcase = new AbstractCase[cases.size()];
    cases.toArray(abcase);
    return abcase;
  }
}

//}}}
//{{{ switchStatementColon(final int start, final int end)

/**
 * A Switch statement with : ... endswitch;
 * @param start the begin offset of the switch
 * @param end the end offset of the switch
 */
AbstractCase[] switchStatementColon(final int start, final int end) :
{
  AbstractCase cas;
  final ArrayList cases = new ArrayList();
  Token token;
  int pos;
}
{
  token = <COLON> {pos = token.sourceEnd;}
  {
    fireParseMessage(new PHPParseMessageEvent(INFO,
                                              PHPParseMessageEvent.MESSAGE_SWITCH_ENDSWITCH_TAG,
                                              path,
                                              "Ugly syntax detected, you should switch () {...} instead of switch (): ... enswitch;",
                                              start,
                                              end,
                                              token.beginLine,
                                              token.endLine,
                                              token.beginColumn,
                                              token.endColumn));
  }
  ( cas = switchLabel0() {cases.add(cas);pos = cas.sourceEnd;})*
  try {
    token = <ENDSWITCH> {pos = token.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'endswitch' expected",
                                          "endswitch",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    token = <SEMICOLON> {pos = token.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    final AbstractCase[] abcase = new AbstractCase[cases.size()];
    cases.toArray(abcase);
    return abcase;
  }
}

//}}}
//{{{ switchLabel0()

AbstractCase switchLabel0() :
{
  final Expression expr;
  Statement statement;
  final ArrayList stmts = new ArrayList();
  final Token token = this.token;
  final int start = this.token.next.sourceStart;
}
{
  expr = SwitchLabel()
  ( statement = BlockStatementNoBreak() {stmts.add(statement);}
  | statement = htmlBlock()             {if (statement != null) {stmts.add(statement);}}
  | statement = BreakStatement()        {stmts.add(statement);})*
  //[ statement = BreakStatement()        {stmts.add(statement);}]
  {
    final int listSize = stmts.size();
    final Statement[] stmtsArray = new Statement[listSize];
    stmts.toArray(stmtsArray);
    if (expr == null) {//it's a default
      final int end = this.token.next.sourceStart;
      return new DefaultCase(stmtsArray,
                             start,
                             end,
                             this.token.next.beginLine,
                             this.token.next.endLine,
                             this.token.next.beginColumn,
                             this.token.next.endColumn);
    }
    if (listSize == 0) {
      return new Case(expr,
                      stmtsArray,
                      expr.sourceStart,
                      expr.sourceEnd,
                      expr.getBeginLine(),
                      expr.getEndLine(),
                      expr.getBeginColumn(),
                      expr.getEndColumn());
    } else {
      return new Case(expr,
                      stmtsArray,
                      expr.sourceStart,
                      stmtsArray[listSize-1].sourceEnd,
                      expr.getBeginLine(),
                      stmtsArray[listSize-1].getEndLine(),
                      expr.getBeginColumn(),
                      stmtsArray[listSize-1].getEndColumn());
    }
  }
}

//}}}
//{{{ SwitchLabel()

/**
 * A SwitchLabel.
 * case Expression() :
 * default :
 * @return the if it was a case and null if not
 */
Expression SwitchLabel() :
{
  final Expression expr;
  Token token;
}
{
  token = <CASE>
  try {
    expr = Expression()
  } catch (ParseException e) {
  //todo ameliorer ca
    if (errorMessage != null) throw e;
    errorMessage = "expression expected after 'case' keyword";
    errorLevel   = ERROR;
    errorStart = token.sourceEnd;
    errorEnd   = token.sourceEnd +1;
    throw e;
  }
  try {
    (
      token = <COLON> 
    | token = <SEMICOLON> // todo ugly do a warning ;)
    ) 
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "':' expected",
                                          ":",
                                          e.currentToken.image,
                                          expr.sourceEnd,
                                          expr.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return expr;}
|
  token = <_DEFAULT>
  try {
    <COLON>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "':' expected",
                                          ":",
                                          e.currentToken.image,
                                          token.sourceEnd,
                                          token.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return null;}
}

//}}}
//{{{ BreakStatement()

Break BreakStatement() :
{
  Expression expression = null;
  final Token token, token2;
  int pos;
}
{
  token = <BREAK> {pos = token.sourceEnd+1;}
  [ expression = Expression() {pos = expression.sourceEnd+1;}]
  try {
    token2 = <SEMICOLON>
    {pos = token2.sourceEnd;}
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          pos,
                                          pos+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return new Break(expression, token.sourceStart, pos,token.beginLine,token.endLine,token.beginColumn,token.endColumn);}
}

//}}}
//{{{ IfStatement()

IfStatement IfStatement() :
{
  final Expression condition;
  final IfStatement ifStatement;
  final Token ifToken;
}
{
  ifToken = <IF> condition = Condition("if")
  ifStatement = IfStatement0(condition,ifToken.sourceStart,ifToken.sourceEnd)
  {return ifStatement;}
}

//}}}
//{{{ Condition(final String keyword)

Expression Condition(final String keyword) :
{
  final Expression condition;
}
{
  try {
    <LPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          token.sourceEnd,
                                          token.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  condition = Expression()
  try {
     <RPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          condition.sourceEnd,
                                          condition.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {return condition;}
}

//}}}
//{{{ IfStatement0(final Expression condition, final int start,final int end)

IfStatement IfStatement0(final Expression condition, final int start,final int end) :
{
  Statement statement = null;
  final Statement stmt;
  final Statement[] statementsArray;
  ElseIf elseifStatement;
  Else elseStatement = null;
  final ArrayList stmts;
  final ArrayList elseIfList = new ArrayList();
  final ElseIf[] elseIfs;
  final int pos = jj_input_stream.getPosition();
  final int endStatements;
  final Token colonToken, elseToken;
}
{
  colonToken = <COLON>
  {stmts = new ArrayList();}
  (  statement = Statement() {stmts.add(statement);}
   | statement = htmlBlock() {if (statement != null) {stmts.add(statement);}}
  )*
   {endStatements = (statement == null) ? colonToken.sourceEnd : statement.sourceEnd;}
   (elseifStatement = ElseIfStatementColon() {elseIfList.add(elseifStatement);})*
   [elseStatement = ElseStatementColon()]

  {
      fireParseMessage(new PHPParseMessageEvent(INFO,
                                                PHPParseMessageEvent.MESSAGE_IF_ENDIF_TAG,
                                                path,
                                                "Ugly syntax detected, you should if () {...} instead of if (): ... endif;",
                                                colonToken.sourceStart,
                                                colonToken.sourceEnd,
                                                colonToken.beginLine,
                                                colonToken.endLine,
                                                colonToken.beginColumn,
                                                colonToken.endColumn));
  }
  try {
    <ENDIF>
  } catch (ParseException e) {
    errorMessage = "'endif' expected";
    errorLevel   = ERROR;
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
  try {
    <SEMICOLON>
  } catch (ParseException e) {
    errorMessage = "';' expected after 'endif' keyword";
    errorLevel   = ERROR;
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
    {
    elseIfs = new ElseIf[elseIfList.size()];
    elseIfList.toArray(elseIfs);
    if (stmts.size() == 1) {
      return new IfStatement(condition,
                             (Statement) stmts.get(0),
                              elseIfs,
                              elseStatement,
                              pos,
                              jj_input_stream.getPosition());
    } else {
      statementsArray = new Statement[stmts.size()];
      stmts.toArray(statementsArray);
      return new IfStatement(condition,
                             new Block(statementsArray,
                                       pos,
                                       endStatements),
                             elseIfs,
                             elseStatement,
                             pos,
                             jj_input_stream.getPosition());
    }
    }

|
  (stmt = Statement() | stmt = htmlBlock())
  ( LOOKAHEAD(1) elseifStatement = ElseIfStatement() {elseIfList.add(elseifStatement);})*
  [ LOOKAHEAD(1)
    elseToken = <ELSE>
    try {
      statement = Statement()
      {elseStatement = new Else(statement,
                                elseToken.sourceStart,
                                statement.sourceEnd,
                                elseToken.beginLine,
                                statement.getEndLine(),
                                elseToken.beginColumn,
                                statement.getEndColumn());}
    } catch (ParseException e) {
      if (errorMessage != null) {
        throw e;
      }
      errorMessage = "unexpected token '"+e.currentToken.next.image+"', a statement was expected";
      errorLevel   = ERROR;
      errorStart = e.currentToken.sourceStart;
      errorEnd   = e.currentToken.sourceEnd;
      throw e;
    }
  ]
  {
    elseIfs = new ElseIf[elseIfList.size()];
    elseIfList.toArray(elseIfs);
    return new IfStatement(condition,
                           stmt,
                           elseIfs,
                           elseStatement,
                           pos,
                           jj_input_stream.getPosition());}
}

//}}}
//{{{ ElseIfStatementColon()

ElseIf ElseIfStatementColon() :
{
  final Expression condition;
  Statement statement;
  final ArrayList list = new ArrayList();
  final Token elseifToken;
}
{
  elseifToken = <ELSEIF> condition = Condition("elseif")
  <COLON> (  statement = Statement() {list.add(statement);}
           | statement = htmlBlock() {if (statement != null) {list.add(statement);}})*
  {
  final int sizeList = list.size();
  final Statement[] stmtsArray = new Statement[sizeList];
  list.toArray(stmtsArray);
  return new ElseIf(condition,stmtsArray ,
                    elseifToken.sourceStart,
                    stmtsArray[sizeList-1].sourceEnd,
                    elseifToken.beginLine,
                    stmtsArray[sizeList-1].getEndLine(),
                    elseifToken.beginColumn,
                    stmtsArray[sizeList-1].getEndColumn());}
}

//}}}
//{{{ ElseStatementColon()

Else ElseStatementColon() :
{
  Statement statement;
  final ArrayList list = new ArrayList();
  final Token elseToken;
}
{
  elseToken = <ELSE> <COLON> (  statement = Statement() {list.add(statement);}
                  | statement = htmlBlock() {if (statement != null) {list.add(statement);}})*
  {
  final int sizeList = list.size();
  final Statement[] stmtsArray = new Statement[sizeList];
  list.toArray(stmtsArray);
  return new Else(stmtsArray,
                  elseToken.sourceStart,
                  stmtsArray[sizeList-1].sourceEnd,
                  elseToken.beginLine,
                  stmtsArray[sizeList-1].getEndLine(),
                  elseToken.beginColumn,
                  stmtsArray[sizeList-1].getEndColumn());}
}

//}}}
//{{{ ElseIfStatement()

ElseIf ElseIfStatement() :
{
  final Expression condition;
  //final Statement statement;
  final Token elseifToken;
  final Statement[] statement = new Statement[1];
}
{
  elseifToken = <ELSEIF> condition = Condition("elseif") statement[0] = Statement()
  {
  return new ElseIf(condition,
                    statement,
                    elseifToken.sourceStart,
                    statement[0].sourceEnd,
                    elseifToken.beginLine,
                    statement[0].getEndLine(),
                    elseifToken.beginColumn,
                    statement[0].getEndColumn());}
}

//}}}
//{{{ WhileStatement()

WhileStatement WhileStatement() :
{
  final Expression condition;
  final Statement action;
  final Token whileToken;
}
{
  whileToken = <WHILE>
    condition = Condition("while")
    action    = WhileStatementAction(whileToken.sourceStart,whileToken.sourceEnd)
    {return new WhileStatement(condition,
                               action,
                               whileToken.sourceStart,
                               action.sourceEnd,
                               whileToken.beginLine,
                               action.getEndLine(),
                               whileToken.beginColumn,
                               action.getEndColumn());}
}

//}}}
//{{{ WhileStatementAction(final int start, final int end)

Statement WhileStatementAction(final int start, final int end) :
{
  Statement statement;
  final ArrayList stmts = new ArrayList();
  final int pos = jj_input_stream.getPosition();
  final Token colonToken;
}
{
  colonToken = <COLON> (statement = Statement() {stmts.add(statement);})*
  {
        fireParseMessage(new PHPParseMessageEvent(INFO,
                                                  PHPParseMessageEvent.MESSAGE_WHILE_ENDWHILE_TAG,
                                                  path,
                                                  "Ugly syntax detected, you should while () {...} instead of while (): ... endwhile;",
                                                  start,
                                                  end,
                                                  colonToken.beginLine,
                                                  colonToken.endLine,
                                                  colonToken.beginColumn,
                                                  colonToken.endColumn));
  }
  try {
    <ENDWHILE>
  } catch (ParseException e) {
    errorMessage = "'endwhile' expected";
    errorLevel   = ERROR;
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
  try {
    <SEMICOLON>
    {
    final Statement[] stmtsArray = new Statement[stmts.size()];
    stmts.toArray(stmtsArray);
    return new Block(stmtsArray,pos,jj_input_stream.getPosition());}
  } catch (ParseException e) {
    errorMessage = "';' expected after 'endwhile' keyword";
    errorLevel   = ERROR;
    errorStart = e.currentToken.sourceStart;
    errorEnd   = e.currentToken.sourceEnd;
    throw e;
  }
|
  statement = Statement()
  {return statement;}
}

//}}}
//{{{ DoStatement()

DoStatement DoStatement() :
{
  final Statement action;
  final Expression condition;
  final Token token;
  Token token2 = null;
}
{
  token = <DO> action = Statement() <WHILE> condition = Condition("while")
  try {
    token2 = <SEMICOLON>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          condition.sourceEnd,
                                          condition.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    if (token2 == null) {
      return new DoStatement(condition,
                             action,
                             token.sourceStart,
                             condition.sourceEnd,
                             token.beginLine,
                             condition.getEndLine(),
                             token.beginColumn,
                             condition.getEndColumn());
    }
    return new DoStatement(condition,
                           action,
                           token.sourceStart,
                           token2.sourceEnd,
                             token.beginLine,
                             token2.endLine,
                             token.beginColumn,
                             token2.endColumn);
  }
}

//}}}
//{{{ ForeachStatement()

ForeachStatement ForeachStatement() :
{
  Statement statement = null;
  Expression expression = null;
  ArrayVariableDeclaration variable = null;
  final Token foreachToken;
  Token lparenToken = null;
  Token asToken = null;
  Token rparenToken = null;
  int pos,endLine,endColumn;
  final Token tokenEndForeach, tokenColon, tokenSemicolon;
  Statement action;
  final ArrayList list = new ArrayList();
}
{
  foreachToken = <FOREACH>
  try {
    lparenToken = <LPAREN>
    {
      pos       = lparenToken.sourceEnd+1;
      endLine   = lparenToken.endLine;
      endColumn = lparenToken.endColumn;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
    {
      pos       = foreachToken.sourceEnd+1;
      endLine   = foreachToken.endLine;
      endColumn = foreachToken.endColumn;
    }
  }
  try {
    expression = Expression()
    {
      pos       = expression.sourceEnd+1;
      endLine   = expression.getEndLine();
      endColumn = expression.getEndColumn();
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "variable expected",
                                          "variable",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    asToken = <AS>
    {
      pos       = asToken.sourceEnd+1;
      endLine   = asToken.endLine;
      endColumn = asToken.endColumn;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'as' expected",
                                          "as",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    variable = ArrayVariable()
    {
      pos       = variable.sourceEnd+1;
      endLine   = variable.getEndLine();
      endColumn = variable.getEndColumn();
    }
  } catch (ParseException e) {
    if (errorMessage != null) throw e;
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "variable expected",
                                          "variable",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  try {
    rparenToken = <RPAREN>
    {
      pos       = rparenToken.sourceEnd+1;
      endLine   = rparenToken.endLine;
      endColumn = rparenToken.endColumn;
    }
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "')' expected",
                                          ")",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  (
  try {
    statement = Statement()
    {
      pos       = statement.sourceEnd+1;
      endLine   = statement.getEndLine();
      endColumn = statement.getEndColumn();
    }
  } catch (ParseException e) {
    if (errorMessage != null) throw e;
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "statement expected",
                                          "statement",
                                          e.currentToken.image,
                                          e.currentToken.sourceStart,
                                          e.currentToken.sourceEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
   return new ForeachStatement(expression,
                               variable,
                               statement,
                               foreachToken.sourceStart,
                               pos,
                               foreachToken.beginLine,
                               endLine,
                               foreachToken.beginColumn,
                               endColumn);
 }
 |
  tokenColon = <COLON> {pos = tokenColon.sourceEnd+1;}
      (action = Statement() {list.add(action);pos = action.sourceEnd+1;})*
      {
        fireParseMessage(new PHPParseMessageEvent(INFO,
                                                  PHPParseMessageEvent.MESSAGE_FOREACH_ENDFOREACH_TAG,
                                                  path,
                                                  "Ugly syntax detected, you should foreach () {...} instead of foreach (): ... endforeach;",
                                                  tokenColon.sourceStart,
                                                  tokenColon.sourceEnd,
                                                  tokenColon.beginLine,
                                                  tokenColon.endLine,
                                                  tokenColon.beginColumn,
                                                  tokenColon.endColumn));
      }
      try {
        tokenEndForeach = <ENDFOREACH>
        {pos = tokenEndForeach.sourceEnd+1;}
      } catch (ParseException e) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "'endforeach' expected",
                                              "endforeach",
                                              e.currentToken.image,
                                              pos,
                                              pos+1,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.endColumn,
                                              e.currentToken.endColumn+1));
      }
      try {
        tokenSemicolon = <SEMICOLON>
        {pos = tokenSemicolon.sourceEnd+1;}
      } catch (ParseException e) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "';' expected",
                                              ";",
                                              e.currentToken.image,
                                              pos,
                                              pos+1,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.endColumn,
                                              e.currentToken.endColumn+1));
      }
      {
        if (list.size() == 0) {
          return new ForeachStatement(expression,
                                       variable,
                                       null,
                                       foreachToken.sourceStart,
                                       pos,
                                       foreachToken.beginLine,
                                       endLine,
                                       foreachToken.beginColumn,
                                       endColumn);
        } else {
          final Statement[] stmtsArray = new Statement[list.size()];
          list.toArray(stmtsArray);
          return new ForeachStatement(expression,
                                       variable,
                                       new Block(stmtsArray,
                                                stmtsArray[0].sourceStart,
                                                stmtsArray[stmtsArray.length-1].sourceEnd,
                                                stmtsArray[0].getBeginLine(),
                                                stmtsArray[stmtsArray.length-1].getEndLine(),
                                                stmtsArray[0].getBeginColumn(),
                                                stmtsArray[stmtsArray.length-1].getEndColumn()),
                                       foreachToken.sourceStart,
                                       pos,
                                       foreachToken.beginLine,
                                       endLine,
                                       foreachToken.beginColumn,
                                       endColumn);
        }
      }
      )
}

//}}}
//{{{ ForStatement()

/**
 * a for declaration.
 * @return a node representing the for statement
 */
ForStatement ForStatement() :
{
final Token token,tokenEndFor,token2,tokenColon;
int pos;
Expression[] initializations = null;
Expression condition = null;
Expression[] increments = null;
Statement action;
final ArrayList list = new ArrayList();
}
{
  token = <FOR>
  try {
    <LPAREN>
  } catch (ParseException e) {
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "'(' expected",
                                          "(",
                                          e.currentToken.image,
                                          token.sourceEnd,
                                          token.sourceEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
     [ initializations = ForInit() ] <SEMICOLON>
     [ condition = Expression() ] <SEMICOLON>
     [ increments = StatementExpressionList() ] <RPAREN>
    (
      action = Statement()
      {return new ForStatement(initializations,
                               condition,
                               increments,
                               action,
                               token.sourceStart,
                               action.sourceEnd);}
    |
      tokenColon = <COLON> {pos = tokenColon.sourceEnd+1;}
      (action = Statement() {list.add(action);pos = action.sourceEnd+1;})*
      {
        fireParseMessage(new PHPParseMessageEvent(INFO,
                                                  PHPParseMessageEvent.MESSAGE_FOR_ENDFOR_TAG,
                                                  path,
                                                  "Ugly syntax detected, you should for () {...} instead of for (): ... endfor;",
                                                  tokenColon.sourceStart,
                                                  tokenColon.sourceEnd,
                                                  tokenColon.beginLine,
                                                  tokenColon.endLine,
                                                  tokenColon.beginColumn,
                                                  tokenColon.endColumn));
      }
      try {
        tokenEndFor = <ENDFOR>
        {pos = tokenEndFor.sourceEnd+1;}
      } catch (ParseException e) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "'endfor' expected",
                                              "endfor",
                                              e.currentToken.image,
                                              pos,
                                              pos+1,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.endColumn,
                                              e.currentToken.endColumn+1));
      }
      try {
        token2 = <SEMICOLON>
        {pos = token2.sourceEnd+1;}
      } catch (ParseException e) {
        fireParseError(new PHPParseErrorEvent(ERROR,
                                              path,
                                              "';' expected",
                                              ";",
                                              e.currentToken.image,
                                              pos,
                                              pos+1,
                                              e.currentToken.beginLine,
                                              e.currentToken.endLine,
                                              e.currentToken.endColumn,
                                              e.currentToken.endColumn+1));
      }
      {
      final Statement[] stmtsArray = new Statement[list.size()];
      list.toArray(stmtsArray);
      return new ForStatement(initializations,
                              condition,
                              increments,
                              new Block(stmtsArray,
                                        stmtsArray[0].sourceStart,
                                        stmtsArray[stmtsArray.length-1].sourceEnd,
                                        stmtsArray[0].getBeginLine(),
                                        stmtsArray[stmtsArray.length-1].getEndLine(),
                                        stmtsArray[0].getBeginColumn(),
                                        stmtsArray[stmtsArray.length-1].getEndColumn()),
                              token.sourceStart,
                              pos);}
    )
}

//}}}
//{{{ ForInit()

Expression[] ForInit() :
{
  final Expression[] exprs;
}
{
  LOOKAHEAD(LocalVariableDeclaration())
  exprs = LocalVariableDeclaration()
  {return exprs;}
|
  exprs = StatementExpressionList()
  {return exprs;}
}

//}}}
//{{{ StatementExpressionList()

Expression[] StatementExpressionList() :
{
  final ArrayList list = new ArrayList();
  final Expression expr;
}
{
  expr = Expression()   {list.add(expr);} (<COMMA> Expression() {list.add(expr);})*
  {
    final Expression[] exprsArray = new Expression[list.size()];
    list.toArray(exprsArray);
    return exprsArray;
  }
}

//}}}
//{{{ ContinueStatement()

Continue ContinueStatement() :
{
  Expression expr = null;
  final Token continueToken;
  Token semicolonToken = null;
}
{
  continueToken = <CONTINUE> [ expr = Expression() ]
  try {
    semicolonToken = <SEMICOLON>
  } catch (ParseException e) {
    final int errorStart, errorEnd;
    if (expr == null) {
      errorStart = continueToken.sourceEnd;
      errorEnd   = continueToken.sourceEnd+1;
    } else {
      errorStart = expr.sourceEnd;
      errorEnd   = expr.sourceEnd+1;
    }
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          errorStart,
                                          errorEnd,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
  {
    if (semicolonToken == null) {
      if (expr == null) {
        return new Continue(expr,continueToken.sourceStart,continueToken.sourceEnd,continueToken.beginLine,continueToken.endLine,continueToken.beginColumn,continueToken.endColumn);
      }
      return new Continue(expr,continueToken.sourceStart,expr.sourceEnd,continueToken.beginLine,expr.getEndLine(),continueToken.beginColumn,expr.getEndColumn());
    }
    return new Continue(expr,continueToken.sourceStart,semicolonToken.sourceEnd,continueToken.beginLine,semicolonToken.endLine,continueToken.beginColumn,semicolonToken.endColumn);
  }
}

//}}}
//{{{ ReturnStatement()

/**
 * A return statement.
 * * It's return [expression];
 * @return a ReturnStatement
 */
ReturnStatement ReturnStatement() :
{
  Statement expr = null;
  final Token token;
  Token token2 = null;
}
{
  token = <RETURN>
(
   expr = IncludeStatement()
  {
    return new ReturnStatement(expr,token.sourceStart,expr.sourceEnd);
  }
|

  [ expr = Expression()]
  try {
    token2 = <SEMICOLON>
  } catch (ParseException e) {
    final int errorStart, errorEnd;
    if (expr == null) {
      errorStart = token.sourceEnd;
      errorEnd   = token.sourceEnd+1;
    } else {
      errorStart = expr.sourceEnd;
      errorEnd   = expr.sourceEnd+1;
    }
    fireParseError(new PHPParseErrorEvent(ERROR,
                                          path,
                                          "';' expected",
                                          ";",
                                          e.currentToken.image,
                                          errorStart,
                                          errorEnd+1,
                                          e.currentToken.beginLine,
                                          e.currentToken.endLine,
                                          e.currentToken.endColumn,
                                          e.currentToken.endColumn+1));
  }
    {
      if (token2 == null) {
        if (expr == null) {
          return new ReturnStatement(expr,token.sourceStart,token.sourceEnd);
        }
        return new ReturnStatement(expr,token.sourceStart,expr.sourceEnd);
      }
      return new ReturnStatement(expr,token.sourceStart,token2.sourceEnd);
    }
    )
}

//}}}

//}}}

//}}}

