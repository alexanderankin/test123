
/*
Per Sreenivasa Viswanadha (as posted on the javacc user mailing list), the
original java 1.5 grammar is licensed under the BSD license, so this modified
grammar is also.

Copyright (c) 2014, Dale Anson
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
    * Neither the name of the <ORGANIZATION> nor the names of its contributors
    may be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


options {
  JAVA_UNICODE_ESCAPE = true;
  //ERROR_REPORTING = true;
  STATIC = false;
  //DEBUG_PARSER = true;
}

PARSER_BEGIN(TigerParser)

import java.io.*;
import java.util.*;

/**
 * References like JLS X.X are section numbers in the Java Language Specification
 * Third Edition.
 *
 * This has been modified to support Java 7 and 8.
 *
 * For Java 7 features, see http://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase7
 * - binary literals
 * - underscores in numeric literals
 * - strings in switch statements
 * - type inference for generic instance creation
 * - try with resources
 * - catch multiple exception types
 *
 * For Java 8 features, see http://docs.oracle.com/javase/8/docs/technotes/guides/language/enhancements.html#javase8
 * - Lambda Expressions
 * - Improved Type Inference
 * - Annotations on Java Types
 * - Repeating Annotations
 * - Method Parameter Reflection
 *
 */
public class TigerParser
{

    private InputStream inputStream = null;
   
    public static void main(String args[]) {
        TigerParser parser;
        if (args.length == 0) {
            System.out.println("TigerParser:  Reading from standard input . . .");
            parser = new TigerParser(System.in);
        } else if (args.length == 1) {
            System.out.println("TigerParser:  Reading from file " + args[0] + " . . .");
            try {
                parser = new TigerParser(new java.io.FileInputStream(args[0]));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("TigerParser:  File " + args[0] + " not found.");
                return;
            }
        } else {
            System.out.println("TigerParser:  Usage is one of:");
            System.out.println("         java TigerParser < inputfile");
            System.out.println("OR");
            System.out.println("         java TigerParser inputfile");
            return;
        }
        try {
            parser.enable_tracing();
            parser.CompilationUnit();
            if (args.length == 0) {
                System.out.println("TigerParser:  input parsed successfully.");
            } 
            else if (args.length == 1) {
                System.out.println("TigerParser: " + args[0] + " parsed successfully.");   
            }
        } catch (ParseException e) {
            if (args.length == 0) {
                System.err.println("TigerParser:  Encountered errors during parse.");
            } 
            else if (args.length == 1) {
                System.err.println("TigerParser: Encountered errors during parse of " + args[0]);   
            }
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

    /**
     * Constructor for TigerParser.
     * @param fileName name of the file to parse
     */
   public TigerParser(String filename)
   {
      this(System.in);
      try {
          inputStream = new FileInputStream(new File(filename));
          ReInit(inputStream);
      }
      catch(Exception e) {
        e.printStackTrace();
      }
   }

   TigerParser(JavaCharStream stream) {
        jj_input_stream = stream;
        token_source = new TigerParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
   }

   /**
    * @param pe ParseException, if null, one will be generated.
    * @param kinds One or more token types (see TigerParserConstants for 
    * definitions). Skipping will stop at the first token type found in
    * this list.
    * @return the token that was skipped to. This could be null since there is
    * a limit of checking no more than 100 tokens. If a token of the requested
    * kind is not found within the next 100 tokens, null will be returned.
    */
   public Token error_skipto(ParseException pe, int... kinds) {
       if (pe == null) {
           pe = generateParseException();  // generate the exception object.
       }
       addException(pe);
       return error_skipto(kinds);
   }
   
   private Token error_skipto(int... kinds) {
       Token t = null;
       int i = 0;
       do {
           i++;
           if (i > 100) {
                return t;
           }
           t = getNextToken();
           for (int type : kinds) {
               if (t.kind == type) {
                    return t;   
               }
           }
       } while (t != null);
       return t;
   }

   private List<Exception> exceptions = new ArrayList<Exception>();

   private void addException(ParseException pe) {
       exceptions.add(pe);
   }

   public List<Exception> getErrors() {
       return exceptions;
   }

   public void setTabSize(int size) {
        jj_input_stream.setTabSize(size);
   }

   public int getTabSize() {
        return jj_input_stream.getTabSize(0);
   }

  /*
   * Returns true if the next token is not in the FOLLOW list of "expansion".
   * It is used to decide when the end of an "expansion" has been reached.
   */
  private boolean notTailOfExpansionUnit() {
    Token t;
    t = getToken(1);
    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET) return false;
    return true;
  }
}

PARSER_END(TigerParser)



/********************************************
 * THE JAVA TOKEN SPECIFICATION STARTS HERE *
 ********************************************/

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  /* danson, added backup(2) for special handling of single line comments at
  the end of a file, see <IN_SINGLE_LINE_COMMENT> special token below */
  "//" { input_stream.backup(2); } : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  /* this is the original, I've replaced with the next line to allow a single
  line comment at the end of a java file without a new line following the
  comment.  The java language specification says that single line comments
  must be followed by an end-of-line marker (see section 3.4), so this new rule
  relaxes that requirement slightly by allowing the line terminator to be
  optional.  This only makes sense when the comment is the last line of the
  source file, all other single line comments will have a line terminator. This
  request was posted as a bug against JBrowse, I don't see any problem with
  allowing it, especially since Sun's compiler doesn't complain. */
  /* <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT */
  < SINGLE_LINE_COMMENT: "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

/* JAVACC RESERVED WORDS: These are the only tokens in JavaCC but not in Java */
/* danson, using these keywords as tokens causes problems when parsing java
code, so I'm replacing these keyworks with semantic lookahead as described in
the javacc faq. */
/*
TOKEN :
{
  < _OPTIONS: "options" >
| < _LOOKAHEAD: "LOOKAHEAD" >
| < _IGNORE_CASE: "IGNORE_CASE" >
| < _PARSER_BEGIN: "PARSER_BEGIN" >
| < _PARSER_END: "PARSER_END" >
| < _JAVACODE: "JAVACODE" >
| < _TOKEN: "TOKEN" >
| < _SPECIAL_TOKEN: "SPECIAL_TOKEN" >
| < _MORE: "MORE" >
| < _SKIP: "SKIP" >
| < _TOKEN_MGR_DECLS: "TOKEN_MGR_DECLS" >
| < _EOF: "EOF" >
}
*/

/* LITERALS */
// DONE: Java 7 allows a binary literal.
// DONE: Java 7 allows underscores in numeric literals to improve readability, e.g. 
// long creditCardNumber = 1234_5678_9012_3456L;
TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <BINARY_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] ((["_"])*["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])((["_"])*["0"-"9","a"-"f","A"-"F"])* >
|
  < #BINARY_LITERAL: "0" ["b","B"] (["0"-"1"])((["_"])*["0"-"1"])* >   // new for Java 7
|
  < #OCTAL_LITERAL: "0" ((["_"])*(["0"-"7"]))* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])((["_"])*(["0"-"9"]))* "." ((["0"-"9"])((["_"])*(["0"-"9"]))*)* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? ["f","F","d","D"]
  >
  
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| < POINTER: "->" >
| < DIAMOND: "<>" >

}

/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
  {
     matchedToken.kind = GT;
     ((Token.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
     input_stream.backup(2);
  }
| < RSIGNEDSHIFT: ">>" >
  {
     matchedToken.kind = GT;
     ((Token.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
     input_stream.backup(1);
  }
| < GT: ">" >
}




/************************************************
 * THE JAVACC GRAMMAR SPECIFICATION STARTS HERE *
 ************************************************/
void getJavaCCRootNode(int tab_size) :
{
}
{
  javacc_input()
}

void javacc_input() :
{
}
{
  javacc_options()

  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("PARSER_BEGIN")} )
  <IDENTIFIER> <LPAREN> identifier() <RPAREN>

  CompilationUnit()

  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("PARSER_END")} )
  <IDENTIFIER> <LPAREN> identifier() <RPAREN>

  ( 
      production() 
  )+
  <EOF>
}

void javacc_options() :
{
}
{
  // special handling for javacc keyword
  [
    LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("options")} )
    (<IDENTIFIER> <LBRACE> ( option_binding() )+ <RBRACE> )
  ]
}


void option_binding() :
{}
{
  (
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("LOOKAHEAD")} )
  identifier()
  |
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("IGNORE_CASE")} )
  identifier()
  |
  <IDENTIFIER>
  |
  <STATIC> )
  <ASSIGN>
  ( IntegerLiteral() | BooleanLiteral() | StringLiteral() )
  <SEMICOLON>
}

void production() :
{
}
{
    (
  LOOKAHEAD(1)
  /*
   * Since JAVACODE is both a JavaCC reserved word and a Java identifier,
   * we need to give preference to "javacode_production" over
   * "bnf_production".
   */
  javacode_production()
|
  LOOKAHEAD(1)
  /*
   * Since SKIP, TOKEN, etc. are both JavaCC reserved words and Java
   * identifiers, we need to give preference to "regular_expression_production"
   * over "bnf_production".
   */
  regular_expr_production()
|
  LOOKAHEAD(1)
  /*
   * Since TOKEN_MGR_DECLS is both a JavaCC reserved word and a Java identifier,
   * we need to give preference to "token_manager_decls" over
   * "bnf_production".
   */
  token_manager_decls()
|
  bnf_production()
  )
}

void javacode_production() :
{
}
{
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("JAVACODE")} )
  <IDENTIFIER>
  ResultType() identifier() FormalParameters()
  [ LOOKAHEAD(2) <THROWS> Name() ( <COMMA> Name() )* ]
  [ LOOKAHEAD(2) node_descriptor() ]
  Block()

}

void bnf_production() :
{
}
{
  ResultType() identifier() FormalParameters()
  [ <THROWS> Name() ( <COMMA> Name() )* ]
  [ node_descriptor() ]
  <COLON>
  Block()
  <LBRACE> expansion_choices() <RBRACE>

}

void regular_expr_production() :
{
}
{
  [
    LOOKAHEAD(2) <LT> <STAR> <GT> 
  |
    <LT> <IDENTIFIER>  ( <COMMA> <IDENTIFIER>  )* <GT> 
  ]
  regexpr_kind() [ <LBRACKET>
                        // special handling for javacc keyword
                        LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("IGNORE_CASE")} )
                        <IDENTIFIER>
                        <RBRACKET>
                      ] <COLON>
  <LBRACE> regexpr_spec() ( "|" regexpr_spec() )* <RBRACE>

}

void token_manager_decls() :
{
}
{
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("TOKEN_MGR_DECLS")} )
  <IDENTIFIER> <COLON> TokenMgrDeclBlock()

}

Token regexpr_kind() :
{
    Token t = null;
}
{
    (
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("TOKEN")} )
  t=<IDENTIFIER>
|
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("SPECIAL_TOKEN")} )
  t=<IDENTIFIER>
|
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("SKIP")} )
  t=<IDENTIFIER>
|
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("MORE")} )
  t=<IDENTIFIER>
    )
  {
    return t;
  }
}

void regexpr_spec() :
{}
{
  regular_expression() [ Block() ] [ <COLON> <IDENTIFIER> ]
}

void expansion_choices() :
{}
{
  expansion() ( "|" expansion() )*
}

void expansion() :
{}
{
  ( LOOKAHEAD(1)
    // special handling for javacc keyword
    LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("LOOKAHEAD")} )
    <IDENTIFIER> <LPAREN> local_lookahead() <RPAREN>
  )?
  ( LOOKAHEAD(0, { notTailOfExpansionUnit() } )
    expansion_unit()
    [ node_descriptor() ]
  )+
}

void local_lookahead() :
    {
      boolean commaAtEnd = false, emptyLA = true;
    }
{
  [
    /*
     * The lookahead of 1 is to turn off the warning message that lets
     * us know that an expansion choice can also start with an integer
     * literal because a primary expression can do the same.  But we
     * know that this is what we want.
     */
    LOOKAHEAD(1)
    IntegerLiteral()
    {
      emptyLA = false;
    }
  ]
  [ LOOKAHEAD(0, { !emptyLA && (getToken(1).kind != RPAREN) } )
    <COMMA>
    {
      commaAtEnd = true;
    }
  ]
  [ LOOKAHEAD(0, { getToken(1).kind != RPAREN && getToken(1).kind != LBRACE } )
    expansion_choices()
    {
      emptyLA = false; commaAtEnd = false;
    }
  ]
  [ LOOKAHEAD(0, { !emptyLA && !commaAtEnd && (getToken(1).kind != RPAREN) } )
    <COMMA>
    {
      commaAtEnd = true;
    }
  ]
  [ LOOKAHEAD(0, { emptyLA || commaAtEnd } )
    <LBRACE> Expression() <RBRACE>
  ]
}

void expansion_unit() :
{}
{
  LOOKAHEAD(1)
  /*
   * We give this priority over primary expressions which use LOOKAHEAD as the
   * name of its identifier.
   */
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("LOOKAHEAD")} )
  <IDENTIFIER> <LPAREN> local_lookahead() <RPAREN>
|
  Block()
|
  <LBRACKET> expansion_choices() <RBRACKET>
|
  <TRY> <LBRACE> expansion_choices() <RBRACE>
  ( <CATCH> <LPAREN> Name() <IDENTIFIER> <RPAREN> Block() )*
  [ <FINALLY> Block() ]
|
  LOOKAHEAD( identifier() | StringLiteral() | <LT> | PrimaryExpression() <ASSIGN> )
  [
    LOOKAHEAD(PrimaryExpression() <ASSIGN>)
    PrimaryExpression() <ASSIGN>
  ]
  ( regular_expression() | identifier() Arguments() )
|
  <LPAREN> expansion_choices() <RPAREN> ( "+" | <STAR> | "?" )?
}

void regular_expression() :
{}
{
  StringLiteral()
|
  LOOKAHEAD(3)
  <LT> [ [ "#" ] identifier() <COLON> ] complex_regular_expression_choices() <GT>
|
  LOOKAHEAD(2)
  <LT> identifier() <GT>
|
  <LT>
  // special handling for javacc keyword
  LOOKAHEAD( {getToken(1).kind == IDENTIFIER && getToken(1).image.equals("EOF")} )
  <IDENTIFIER>
  <GT>
}

void complex_regular_expression_choices() :
{}
{
  complex_regular_expression() ( "|" complex_regular_expression() )*
}

void complex_regular_expression() :
{}
{
  ( complex_regular_expression_unit() )+
}

void complex_regular_expression_unit() :
{}
{
  StringLiteral()
|
  <LT> identifier() <GT>
|
  character_list()
|
  <LPAREN> complex_regular_expression_choices() <RPAREN> ( "+" | <STAR> | "?" )?
}

void character_list() :
{}
{
  [ "~" ] <LBRACKET> [ character_descriptor() ( <COMMA> character_descriptor() )* ] <RBRACKET>
}

void character_descriptor() :
{}
{
  StringLiteral() [ "-" StringLiteral() ]
}

String identifier() :
{
    Token t = null;
}
{
  t=<IDENTIFIER>
  {
    return t.image;
  }
}


/**********************************************
 * THE JJTREE PRODUCTIONS START HERE          *
 **********************************************/

void node_descriptor() :
{}
{
  "#" ( <IDENTIFIER> | <VOID> )
  [
   LOOKAHEAD(1)
   <LPAREN> [ <GT> ] node_descriptor_expression() <RPAREN>
  ]
}


JAVACODE
void node_descriptor_expression()
{
  Token tok;
  int nesting = 1;
  while (true) {
    tok = getToken(1);
    if (tok.kind == 0) {
      throw new ParseException();
    }
    if (tok.kind == LPAREN) nesting++;
    if (tok.kind == RPAREN) {
      nesting--;
      if (nesting == 0) break;
    }
    tok = getNextToken();
  }
}

/* javacc productions */

void IntegerLiteral() :
{}
{
  <INTEGER_LITERAL>
}


void StringLiteral() :
{}
{
  <STRING_LITERAL>
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

void getJavaRootNode() :
{
}
{
  JavaCompilationUnit()
}

/**
 * Main entry point for parsing the PARSER section in javacc files. Use
 * JavaCompilationUnit as main entry point for parsing java files.
 */
void CompilationUnit():
{
}
{
    try {
      (
          
           [ LOOKAHEAD(2) PackageDeclaration() ]
           ( ImportDeclaration()  )*

           // TypeDeclaration, this will be one or more classes or
           // interfaces, add these as child nodes of the root node
           (
             TypeDeclaration()
           )*
       )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE, PUBLIC, PRIVATE, PROTECTED, CLASS, INTERFACE, ENUM);
    }

}

/**
 * Main entry point for parsing java files.
 */
void JavaCompilationUnit():
{
}
{
    try {
      (
           CompilationUnit()

           // read the whole file
           <EOF>
       )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE);
    }
}

void PackageDeclaration():
{
}
{
    try {
        [ Annotation() ]        // Java 8
        <PACKAGE> Name() <SEMICOLON>  
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, IMPORT, CLASS, INTERFACE, ENUM, PUBLIC, PRIVATE, PROTECTED);
    }

}

void ImportDeclaration():
{
}
{
    try {
        <IMPORT> [ <STATIC> ] Name() [ <DOT> <STAR> ] <SEMICOLON> 
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, IMPORT, CLASS, INTERFACE, ENUM, PUBLIC, PRIVATE, PROTECTED);
    }
}

/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */

void Modifiers():
{
}
{
 (
  LOOKAHEAD(2)
  (
   <PUBLIC> 
  |
   <STATIC>
  |
   <PROTECTED>
  |
   <PRIVATE>
  |
   <FINAL>
  |
   <ABSTRACT>
  |
   <SYNCHRONIZED>
  |
   <NATIVE>
  |
   <TRANSIENT>
  |
   <VOLATILE>
  |
   <STRICTFP>
  |
   Annotation()
  )
 )*

}

/*
 * Declaration syntax follows.
 */

// Handle classes, interfaces, enums, and annotations.
void TypeDeclaration():
{
}
{
    try {

          <SEMICOLON>
        |
          Modifiers()
          (
              LOOKAHEAD(2)
             ClassOrInterfaceDeclaration()
           |
             EnumDeclaration()
           |
             AnnotationTypeDeclaration() 
          )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE, PUBLIC, PRIVATE, PROTECTED);
    }
}

void ClassOrInterfaceDeclaration():
{
}
{
    try {
      ( 
          [ Annotation() ]      // Java 8
          <CLASS> | <INTERFACE> 
      )
      <IDENTIFIER>
      [ TypeParameters() ]
      [ ExtendsList() ]
      [ ImplementsList() ]
      ClassOrInterfaceBody()
      [ LOOKAHEAD(2) <SEMICOLON> ]
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, CLASS, INTERFACE, ENUM, PUBLIC, PRIVATE, PROTECTED);
    }
}

void ExtendsList():
{}
{
    try {
       <EXTENDS> ClassOrInterfaceType()
       ( <COMMA> ClassOrInterfaceType() )*

    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE);
    }
}

void ImplementsList():
{
}
{
    try {
        <IMPLEMENTS> ClassOrInterfaceType()
       ( <COMMA> ClassOrInterfaceType())*

    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE);
    }
}

void EnumDeclaration():
{
}
{
    try {
        <ENUM> <IDENTIFIER>
        [ ImplementsList() ]
        EnumBody()

    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE);
    }
}

void EnumBody():
{
}
{
    try {
        <LBRACE>
        EnumConstant() ( <COMMA> EnumConstant() )*
        [ <SEMICOLON> ( ClassOrInterfaceBodyDeclaration()  )* ]
        <RBRACE>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE);
    }
}

void EnumConstant():
{
}
{
    try {
        [ Annotation() ]     // Java 8
        <IDENTIFIER> [ Arguments() ] [ ClassOrInterfaceBody() ]
    }
    catch(ParseException pe) {
        // This grammar expects commas to be followed by EnumConstants, but
        // neither javac nor the language spec says it has to, so something like
        // public enum {ACE, BASE, CASE, } is allowed.
        // TODO: rethrow the exception? This is poor coding practice.
        return;
    }
}

void TypeParameters():
{
}
{
    try {
        (
            <LT>
            (
            TypeParameter()
            )?
            (
                <COMMA>
                TypeParameter()
            )*
            <GT>
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, GT);
    }
}

void TypeParameter():
{
}
{
    try {
        (
            <IDENTIFIER> [ TypeBound() ]
        )

    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void TypeBound():
{
}
{
    try {

        (
            <EXTENDS>
            ClassOrInterfaceType()
            (
                "&"
                ClassOrInterfaceType()
            )*
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ClassOrInterfaceBody():
{
}
{
    try {

        (
            <LBRACE>
            (
                ClassOrInterfaceBodyDeclaration()
            )*
            <RBRACE>
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE, PUBLIC, PRIVATE, PROTECTED);
    }
}

void ClassOrInterfaceBodyDeclaration():
{
}
{
    try {
          (
          LOOKAHEAD(2)
          Initializer()
        |
          Modifiers() // Just get all the modifiers out of the way. If you want to do
                      // more checks, pass the modifiers down to the member
          (
              LOOKAHEAD(3)
              ClassOrInterfaceDeclaration()
            |
              EnumDeclaration()
            |
              LOOKAHEAD( [ TypeParameters() ] <IDENTIFIER> <LPAREN> )
              ConstructorDeclaration()
            |
              LOOKAHEAD( Type() <IDENTIFIER> ( <LBRACKET> <RBRACKET> )* ( <COMMA> | <ASSIGN> | <SEMICOLON> ) )
              FieldDeclaration()
            |
              LOOKAHEAD(2)
              AnnotationTypeDeclaration()
            |
              MethodDeclaration()
          )
        |
          <SEMICOLON> 
          )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, PUBLIC, PRIVATE, PROTECTED);
    }
}

void FieldDeclaration():
{
}
{
    try {

        (
            // Modifiers are already matched in the caller
            [ LOOKAHEAD(2) Annotation() ]        // Java 8
            Type() VariableDeclarator()
            (
                <COMMA> VariableDeclarator()
            )*
            <SEMICOLON>
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void VariableDeclarator():
{
}
{
    try {
        (
            VariableDeclaratorId() [ <ASSIGN> VariableInitializer() ]
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void VariableDeclaratorId():
{
}
{
    try {
        [ Annotation() ]        // Java 8 
        <IDENTIFIER> 
        ( 
            [ Annotation() ]    // Java 8
            <LBRACKET> <RBRACKET> 
        )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void VariableInitializer():
{
}
{
    try {

          ArrayInitializer()
        |
          Expression()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ArrayInitializer():
{
}
{
    try {

        <LBRACE> [ VariableInitializer()  ( LOOKAHEAD(2) <COMMA> VariableInitializer()  )* ] [ <COMMA> ] <RBRACE>

    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void MethodDeclaration():
{
}
{
    try {
        (
          // Modifiers already matched in the caller!
          [ LOOKAHEAD(2) Annotation() ]        // Java 8
          [ TypeParameters() ]
          ResultType()
          [ Annotation() ]    // Java 8
          MethodDeclarator() [ <THROWS> NameList() ]
          ( Block() | <SEMICOLON> )
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE, PUBLIC, PRIVATE, PROTECTED);
    }
}

void MethodDeclarator():
{
}
{
    try {
        (
            <IDENTIFIER> FormalParameters() ( <LBRACKET> <RBRACKET> )*
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, LBRACE, RBRACE);
    }
}

void FormalParameters():
{
}
{
    try {
        (
         <LPAREN>
         [
              FormalParameter()
              (
                  <COMMA>
                  FormalParameter()
              )*
         ]
         <RPAREN>
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE, PUBLIC, PRIVATE, PROTECTED);
    }
}

void FormalParameter():
{
}
{
    try {
      (
        Modifiers()
        Type()
       [ LOOKAHEAD(2) Annotation() ]     // Java 8
       [
        <ELLIPSIS>  // ...
       ]
       VariableDeclaratorId()
      )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RPAREN); 
    }
}

void ConstructorDeclaration():
{
}
{
    try {
        (
            [ Annotation() ]
            [ TypeParameters() ]
            <IDENTIFIER> FormalParameters() [ <THROWS> NameList() ]
            <LBRACE>
                [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation()  ]
            ( BlockStatement() )*
            <RBRACE>
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE);
    }
}

void ExplicitConstructorInvocation():
{
}
{
    try {
          LOOKAHEAD(<THIS> Arguments() <SEMICOLON>)
          <THIS> Arguments() <SEMICOLON>
        |
        [ LOOKAHEAD(2) PrimaryExpression() <DOT> ] <SUPER> Arguments() <SEMICOLON>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void Initializer():
{
}
{
    try {
        [ <STATIC> ] Block()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}


void Type():
{
}
{
    try {
        (
         LOOKAHEAD(2) ReferenceType()
        |
         PrimitiveType()
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ReferenceType():
{
}
{
    try {
        (
            LOOKAHEAD(3)
            PrimitiveType() ( LOOKAHEAD(2) <LBRACKET> <RBRACKET>  )+
        |
        ( ClassOrInterfaceType() ) ( LOOKAHEAD(2) <LBRACKET> <RBRACKET> )*
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ClassOrInterfaceType():
{
}
{
    try {
        (
          [ Annotation() ]    // Java 8
          <IDENTIFIER> [ LOOKAHEAD(2) TypeArguments() ]
          // checks for types with package names, like com.whatever.MyClass as
          // opposed to just MyClass, which is covered in the block above
          ( LOOKAHEAD(2) <DOT> 
              [ 
                Annotation()
              ]      // Java 8 
              <IDENTIFIER> [ LOOKAHEAD(2) TypeArguments() ]
          )*
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void TypeArguments():
{
}
{
    try {
        (
         <DIAMOND>   
        )
        |
        (
        <LT> TypeArgument() 

        ( <COMMA> TypeArgument() )* <GT>
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void TypeArgument():
{
}
{
    try {
        (
           ReferenceType()
         |
         "?" [ WildcardBounds() ]
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void WildcardBounds():
{
}
{
    try {

        (
        <EXTENDS> ReferenceType() 
     |
        <SUPER> ReferenceType()
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}


void PrimitiveType():
{
}
{
    try {
        [ Annotation() ]        // Java 8
        (
              <BOOLEAN> 
            |
              <CHAR>
            |
              <BYTE>
            |
              <SHORT>
            |
              <INT>
            |
              <LONG>
            |
              <FLOAT>
            |
              <DOUBLE>
        )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ResultType():
{
}
{
    try {
          (
          <VOID>
        |
          Type()
          )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE);
    }
}

void Name():
{
}
{
    try {

        <IDENTIFIER>
        (
            LOOKAHEAD(2)
            <DOT> <IDENTIFIER>
        )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void NameList():
{
}
{
    try {
        Name() 
        ( <COMMA> Name() )* 
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}


void Expression():
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{
}
{
    try {
      LOOKAHEAD(LambdaExpression())
      LambdaExpression()      // Java 8
      |
      (
          ConditionalExpression()
          [
            LOOKAHEAD(2)
            AssignmentOperator()  Expression() 
          ]
      )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void LambdaExpression():
{
}
{
    try {
        LambdaParameters() <POINTER> LambdaBody()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void LambdaParameters():
{
}
{
    try {
        <IDENTIFIER>
        |
        LOOKAHEAD(3) 
        <LPAREN> [FormalParameters()] <RPAREN>
        |
        LOOKAHEAD(3) 
        <LPAREN> InferredFormalParameterList() <RPAREN>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

// Java 8
void InferredFormalParameterList():
{
}
{
    try {
        <IDENTIFIER>
        (
            <COMMA> 
            <IDENTIFIER>
        )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

// Java 8
void LambdaBody():
{
}
{
    try {
        Expression()
        |
        Block()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void AssignmentOperator():
{}
{
  <ASSIGN> | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
}

void ConditionalExpression():
{
}
{
    try {
        ConditionalOrExpression() [ "?" Expression() <COLON> Expression() ]
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ConditionalOrExpression():
{
}
{
    try {
        ConditionalAndExpression() ( "||" ConditionalAndExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ConditionalAndExpression():
{
}
{
    try {
        InclusiveOrExpression() ( "&&" InclusiveOrExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void InclusiveOrExpression():
{
}
{
    try {
        ExclusiveOrExpression() ( "|" ExclusiveOrExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}
// TODO: continue from here
void ExclusiveOrExpression():
{
}
{
    try {
        AndExpression() ( "^" AndExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void AndExpression():
{
}
{
    try {
        EqualityExpression() ( "&" EqualityExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

/* @return List<Type> */
void EqualityExpression():
{
}
{
    try {
        InstanceOfExpression() ( ( "==" | "!=" ) InstanceOfExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void InstanceOfExpression():
{
}
{
    try {
        RelationalExpression() [ <INSTANCEOF> Type() ]
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void RelationalExpression():
{
}
{
    try {
        ShiftExpression() ( ( <LT> | <GT> | "<=" | ">=" ) ShiftExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ShiftExpression():
{
}
{
    try {
        AdditiveExpression() ( ( "<<" | RSIGNEDSHIFT() | RUNSIGNEDSHIFT() ) AdditiveExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void AdditiveExpression():
{
}
{
    try {
        MultiplicativeExpression() ( ( "+" | "-" ) MultiplicativeExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void MultiplicativeExpression():
{
}
{
    try {
        UnaryExpression() ( ( <STAR> | "/" | "%" ) UnaryExpression() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void UnaryExpression():
{
}
{
    try {
          ( "+" | "-" ) UnaryExpression()
        |
          PreIncrementExpression()
        |
          PreDecrementExpression()
        |
          UnaryExpressionNotPlusMinus()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void PreIncrementExpression():
{
}
{
    try {
        "++" PrimaryExpression()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void PreDecrementExpression():
{
}
{
    try {
        "--" PrimaryExpression()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void UnaryExpressionNotPlusMinus():
{
}
{
    try {
          ( "~" | "!" ) UnaryExpression()
        |
          LOOKAHEAD( CastLookahead() )
          CastExpression()
        |
          PostfixExpression()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead():
{
}
{
    try {
          LOOKAHEAD(2)
          <LPAREN> PrimitiveType()
        |
          LOOKAHEAD(<LPAREN> Type() <LBRACKET>)
          <LPAREN> Type() <LBRACKET> <RBRACKET>
        |
          <LPAREN> Type() <RPAREN> ( "~" | "!" | <LPAREN> | <IDENTIFIER> | <THIS> | <SUPER> | <NEW> | Literal() )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void PostfixExpression():
{
}
{
    try {
        PrimaryExpression() [ "++" | "--" ]
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void CastExpression():
{
}
{
    try {
          LOOKAHEAD(<LPAREN> PrimitiveType())
          <LPAREN> Type() <RPAREN> UnaryExpression()
        |
          <LPAREN> Type() <RPAREN> UnaryExpressionNotPlusMinus()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

/**
 * JLS 15.8 Primary Expressions
 * Primary expressions include most of the simplest kinds of expressions, from
 * which all others are constructed: literals, class literals, field accesses,
 * method invocations, and array accesses. A parenthesized expression is also
 * treated syntactically as a primary expression.
 */
void PrimaryExpression():
{
}
{
    try {
        PrimaryPrefix()
        ( LOOKAHEAD(2)
            PrimarySuffix()
        )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void MemberSelector():
{
}
{
    try {
        <DOT> TypeArguments() <IDENTIFIER>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void PrimaryPrefix():
{
}
{
    try {
          Literal()
        |
          <THIS>
        |
          <SUPER> <DOT> <IDENTIFIER>
        |
          LOOKAHEAD( ClassOrInterfaceType() <DOT> <IDENTIFIER> )
          ClassOrInterfaceType()  <DOT> <IDENTIFIER>
        |
          LOOKAHEAD( ClassOrInterfaceType() <DOT> <SUPER> <DOT> <IDENTIFIER> )
          ClassOrInterfaceType()  <DOT> <SUPER> <DOT> <IDENTIFIER>
        |
            <LPAREN> Expression()  <RPAREN>
        |
            AllocationExpression() 
        |
          LOOKAHEAD( ResultType() <DOT> <CLASS> )
          ResultType()  <DOT> <CLASS>
        |
            Name()   
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void PrimarySuffix():
{
}
{
    try {
          LOOKAHEAD(2)
          <DOT> <THIS>
        |
          LOOKAHEAD(2)
          <DOT> AllocationExpression()
        |
          LOOKAHEAD(3)
          MemberSelector()
        |
          <LBRACKET> Expression() <RBRACKET>
        |
          <DOT> <IDENTIFIER>
        |
          Arguments()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void Literal():
{}
{
    try {
          <INTEGER_LITERAL>
        |
          <FLOATING_POINT_LITERAL>
        |
          <CHARACTER_LITERAL>
        |
          <STRING_LITERAL>
        |
          BooleanLiteral()
        |
          NullLiteral()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void BooleanLiteral():
{}
{
  <TRUE>
|
  <FALSE>
}

void NullLiteral():
{}
{
  <NULL>
}

void Arguments():
{
}
{
    try {
        <LPAREN> [ ArgumentList() ] <RPAREN>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ArgumentList():
{
}
{
    try {
        Expression()  ( <COMMA> Expression()  )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void AllocationExpression():
{
}
{
    try {
          LOOKAHEAD(2)
          <NEW> PrimitiveType()  ArrayDimsAndInits() 
        |
          <NEW> ClassOrInterfaceType()  [ TypeArguments()  ]
            (
                ArrayDimsAndInits() 
            |
                Arguments()  [ ClassOrInterfaceBody()  ]
            )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits():
{
}
{
    try {
          LOOKAHEAD(2)
          ( LOOKAHEAD(2) <LBRACKET> Expression()  <RBRACKET> )+ ( LOOKAHEAD(2) <LBRACKET> <RBRACKET> )*
        |
          ( <LBRACKET> <RBRACKET> )+ ArrayInitializer()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}


/*
 * Statement syntax follows.
 */

void Statement():
{
}
{
    try {
          (
          LOOKAHEAD(2)
          LabeledStatement()
        |
          AssertStatement()
        |
          Block()
        |
          EmptyStatement()
        |
          StatementExpression() <SEMICOLON>
        |
          SwitchStatement()
        |
          IfStatement()
        |
          WhileStatement()
        |
          DoStatement()
        |
          ForStatement()
        |
          BreakStatement()
        |
          ContinueStatement()
        |
          ReturnStatement()
        |
          ThrowStatement()
        |
          SynchronizedStatement()
        |
          TryStatement()
          )

    }
    catch(ParseException pe) {
        //error_skipto(pe, SEMICOLON);
        throw pe;
    }
}

void AssertStatement():
{}
{
    try {
        <ASSERT> Expression() [ <COLON> Expression() ] <SEMICOLON>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void LabeledStatement():
{}
{
    try {
        <IDENTIFIER> <COLON> Statement()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void Block():
{
}
{
    try {
        <LBRACE> ( BlockStatement() )* <RBRACE>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON, RBRACE);
    }
}

void BlockStatement():
{
}
{
    try {
        [LOOKAHEAD(2) Annotation()]
            (
          LOOKAHEAD( Modifiers() Type() <IDENTIFIER>)
          LocalVariableDeclaration() <SEMICOLON>
        |
          LOOKAHEAD(3)
          Statement()
        |
          ClassOrInterfaceDeclaration()
             )
    }
    catch(ParseException pe) {
        //error_skipto(pe, SEMICOLON, RBRACE);
        throw pe;
    }
}

void TokenMgrDeclBlock():
{
}
{
    try {
        <LBRACE> ( TokenMgrDeclBlockStatement() )* <RBRACE>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void TokenMgrDeclBlockStatement():
{
}
{
    try {
        Modifiers()
            (
         /*
          LOOKAHEAD([ "final" ] Type() <IDENTIFIER>)
          LocalVariableDeclaration() <SEMICOLON>
        |
         */
          LOOKAHEAD( Type() <IDENTIFIER> ( <LBRACKET> <RBRACKET> )* ( <COMMA> | <ASSIGN> | <SEMICOLON> ) )
          FieldDeclaration()
        |
          LOOKAHEAD(3)
          MethodDeclaration()
        |
          LOOKAHEAD(3)
          Statement()
        |
          ClassOrInterfaceDeclaration()
             )
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void LocalVariableDeclaration():
{
}
{
    try {
      Modifiers() Type() VariableDeclarator()
      ( <COMMA> VariableDeclarator()
      )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }

}

void EmptyStatement():
{}
{
  <SEMICOLON>
}

void StatementExpression():
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{
}
{
    try {
          PreIncrementExpression()
        |
          PreDecrementExpression()
        |
          PrimaryExpression()
          [
            "++"
          |
            "--"
          |
            AssignmentOperator() Expression()
          ]
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void SwitchStatement():
{
}
{
    try {
        <SWITCH> <LPAREN> Expression()  <RPAREN> <LBRACE>
            ( SwitchLabel()  ( BlockStatement()  )* )*
      <RBRACE>

    }
    catch(ParseException pe) {
        error_skipto(pe, RBRACE);
    }
}

void SwitchLabel():
{
}
{
    try {
          <CASE> Expression() <COLON>
        |
          <_DEFAULT> <COLON>
    }
    catch(ParseException pe) {
        error_skipto(pe, COLON);
    }
}

void IfStatement():
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
}
{
    try {
        <IF> <LPAREN> Expression() <RPAREN> Statement() [ LOOKAHEAD(1) <ELSE> Statement() ]
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void WhileStatement():
{
}
{
    try {
        <WHILE> <LPAREN> Expression() <RPAREN> Statement()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void DoStatement():
{
}
{
    try {
        <DO> Statement() <WHILE> <LPAREN> Expression() <RPAREN> <SEMICOLON>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ForStatement():
{
}
{
    try {
      <FOR> <LPAREN>
      (
          LOOKAHEAD([ <FINAL> ] Type() <IDENTIFIER> <COLON>)
          [ <FINAL> ] Type() <IDENTIFIER> <COLON> Expression()
        |
         [ ForInit() ] <SEMICOLON> [ Expression() ] <SEMICOLON> [ ForUpdate() ]
      )
      <RPAREN> Statement()

    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ForInit():
{
}
{
    try {
          LOOKAHEAD( [ <FINAL> ] Type() <IDENTIFIER> )
          LocalVariableDeclaration() 
        |
        StatementExpressionList() 
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void StatementExpressionList():
{
}
{
    try {
        StatementExpression()  ( <COMMA> StatementExpression()  )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ForUpdate():
{}
{
    try {
        StatementExpressionList()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void BreakStatement():
{}
{
  <BREAK> [ <IDENTIFIER> ] <SEMICOLON>
}

void ContinueStatement():
{}
{
  <CONTINUE> [ <IDENTIFIER> ] <SEMICOLON>
}

void ReturnStatement():
{
}
{
    try {
        <RETURN> [ Expression() ] <SEMICOLON>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void ThrowStatement():
{
}
{
    try {
        <THROW> Expression() <SEMICOLON>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void SynchronizedStatement():
{
}
{
    try {
        <SYNCHRONIZED> <LPAREN> Expression() <RPAREN> Block()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void TryStatement():
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
 // DONE: Java 7 allows try with resources, where the resource implements Closeable.
 // e.g.
 // try (BufferedReader br = new BufferedReader(new FileReader(path))) {
 //   return br.readLine();
 // }
 // Note that neither 'catch' nor 'finally' are required in this case.
 //
 // DONE: Java 7 allows 'catch' to handle more than one exception type, e.g.
 // catch (IOException|SQLException ex)
{
}
{
    try {
        <TRY> [<LPAREN> LocalVariableDeclaration()(LOOKAHEAD(2) <SEMICOLON> LocalVariableDeclaration())* [<SEMICOLON>] <RPAREN>]
        Block() 
        
        ( <CATCH> <LPAREN> 
                        (
                            LOOKAHEAD(3)
                            FormalParameter() 
                            |
                            ClassOrInterfaceType()(LOOKAHEAD(2) "|" ClassOrInterfaceType())+ VariableDeclaratorId()
                        )
                  <RPAREN> 
            Block() 
        )*
        
        [ <FINALLY> 
            Block() 
        ]
    }
    catch(ParseException pe) {
        error_skipto(pe, RBRACE);
    }
}

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

void RUNSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                 getToken(1) instanceof Token.GTToken &&
                ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
   <GT> <GT> <GT>
  )
}

void RSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                 getToken(1) instanceof Token.GTToken &&
                ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT} )
  <GT> <GT>
  )
}

/* Annotation syntax follows. */

void Annotation():
{
}
{
    try {
       LOOKAHEAD( <AT> Name() <LPAREN> ( <IDENTIFIER> <ASSIGN> | <RPAREN> ))
       NormalAnnotation()
     |
       LOOKAHEAD( <AT> Name() <LPAREN> )
       SingleMemberAnnotation()
     |
       MarkerAnnotation()
    }
    catch(ParseException pe) {
        // TODO: what to do here?
        addException(pe);
    }
}

void NormalAnnotation():
{
}
{
    try {
        <AT> Name() <LPAREN> [ MemberValuePairs() ] <RPAREN>
    }
    catch(ParseException pe) {
        error_skipto(pe, RPAREN);   
    }
}

void MarkerAnnotation():
{
}
{
    try {
        <AT> Name()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);    // TODO is there a better token to skip to?   
    }
}

void SingleMemberAnnotation():
{
}
{
    try {
        <AT> Name() <LPAREN> MemberValue() <RPAREN>
    }
    catch(ParseException pe) {
        error_skipto(pe, RPAREN);   
    }
}

void MemberValuePairs():
{
}
{
    try {
        MemberValuePair() ( <COMMA> MemberValuePair() )*
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);   
    }
}

void MemberValuePair():
{
}
{
    try {
        <IDENTIFIER> <ASSIGN> MemberValue()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);   
    }
}

void MemberValue():
{
}
{
    try {
           LOOKAHEAD(2)
           Annotation()      
         |
           MemberValueArrayInitializer()
         |
           ConditionalExpression()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);
    }
}

void  MemberValueArrayInitializer():
{
}
{
    try {
    <LBRACE> (MemberValue() ( LOOKAHEAD(2) <COMMA> MemberValue() )* [ <COMMA> ])? <RBRACE>
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);   
    }
}


/* Annotation Types. */
void AnnotationTypeDeclaration():
{
}
{
    Modifiers()
    try {
        <AT> <INTERFACE> <IDENTIFIER> AnnotationTypeBody()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);   
    }
}

void AnnotationTypeBody():
{
}
{
    try {
    <LBRACE> ( AnnotationTypeMemberDeclaration() )* <RBRACE>
    }
    catch(ParseException pe) {
        error_skipto(pe, RBRACKET);   
    }
}

void AnnotationTypeMemberDeclaration():
{
}
{
 Modifiers()
 try {
     (
         LOOKAHEAD(Type() <IDENTIFIER> <LPAREN>)
         Type()  <IDENTIFIER>  <LPAREN> <RPAREN> [ DefaultValue() ] <SEMICOLON> 
         |
         LOOKAHEAD(3)
         ClassOrInterfaceDeclaration()
         |
         EnumDeclaration()
         |
         LOOKAHEAD(2)
         AnnotationTypeDeclaration()
         |
         FieldDeclaration()
     )
     |
     ( <SEMICOLON> )
 }
 catch(ParseException pe) {
    error_skipto(pe, SEMICOLON);   
 }
}

void DefaultValue():
{
}
{
    try {
        <_DEFAULT> MemberValue()
    }
    catch(ParseException pe) {
        error_skipto(pe, SEMICOLON);   
    }
  
}

