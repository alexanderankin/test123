/*
This is a clean java 1.8 grammar from scratch.

Copyright (c) 2014, Dale Anson
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,

are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
    * Neither the name of the <ORGANIZATION> nor the names of its contributors
    may be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

options {
  JAVA_UNICODE_ESCAPE = true;
  ERROR_REPORTING = true;
  STATIC = false;
  DEBUG_PARSER = true;
}

PARSER_BEGIN(JavaParser)
import java.io.*;

public class JavaParser
{

   private InputStream inputStream = null;
   
    public static void main(String args[]) {
        JavaParser parser;
        if (args.length == 0) {
            System.out.println("JavaParser:  Reading from standard input . . .");
            parser = new JavaParser(System.in);
        } else if (args.length == 1) {
            System.out.println("JavaParser:  Reading from file " + args[0] + " . . .");
            try {
                parser = new JavaParser(new java.io.FileInputStream(args[0]));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("JavaParser:  File " + args[0] + " not found.");
                return;
            }
        } else {
            System.out.println("JavaParser:  Usage is one of:");
            System.out.println("         java JavaParser < inputfile");
            System.out.println("OR");
            System.out.println("         java JavaParser inputfile");
            return;
        }
        try {
            parser.enable_tracing();
            parser.CompilationUnit();
            if (args.length == 0) {
                System.out.println("JavaParser:  input parsed successfully.");
            } 
            else if (args.length == 1) {
                System.out.println("JavaParser: " + args[0] + " parsed successfully.");   
            }
        } catch (ParseException e) {
            if (args.length == 0) {
                System.err.println("JavaParser:  Encountered errors during parse.");
            } 
            else if (args.length == 1) {
                System.err.println("JavaParser: Encountered errors during parse of " + args[0]);   
            }
            System.err.println(e.getMessage());
            System.exit(1);
        }
    }

   public JavaParser(String filename)
   {
      this(System.in);
      try {
          inputStream = new FileInputStream(new File(filename));
          ReInit(inputStream);
      }
      catch(Exception e) {
        e.printStackTrace();
      }
   }

   JavaParser(JavaCharStream stream) {
        jj_input_stream = stream;
        token_source = new JavaParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
   }

  /*
   * Returns true if the next token is not in the FOLLOW list of "expansion".
   * It is used to decide when the end of an "expansion" has been reached.
   */
  private boolean notTailOfExpansionUnit() {
    Token t;
    t = getToken(1);
    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET) return false;
    return true;
  }
}

PARSER_END(JavaParser)

/********************************************
 * THE JAVA TOKEN SPECIFICATION STARTS HERE *
 ********************************************/

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  /* added backup(2) for special handling of single line comments at
  the end of a file, see <IN_SINGLE_LINE_COMMENT> special token below */
  "//" { input_stream.backup(2); } : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  /* this is the original, I've replaced with the next line to allow a single
  line comment at the end of a java file without a new line following the
  comment.  The java language specification says that single line comments
  must be followed by an end-of-line marker (see section 3.4), so this new rule
  relaxes that requirement slightly by allowing the line terminator to be
  optional.  This only makes sense when the comment is the last line of the
  source file, all other single line comments will have a line terminator. This
  request was posted as a bug against JBrowse, I don't see any problem with
  allowing it, especially since Sun's compiler doesn't complain. */
  /* <SINGLE_LINE_COMMENT:

 "\n" | "\r" | "\r\n" > : DEFAULT */
  < SINGLE_LINE_COMMENT:

 "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT:
 "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>

SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT:
 "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>

MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

/* LITERALS */
TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <BINARY_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] ((["_"])*["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])((["_"])*["0"-"9","a"-"f","A"-"F"])* >
|
  < #BINARY_LITERAL: "0" ["b","B"] (["0"-"1"])((["_"])*["0"-"1"])* >   
|
  < #OCTAL_LITERAL: "0" ((["_"])*(["0"-"7"]))* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])((["_"])*(["0"-"9"]))* "." ((["0"-"9"])((["_"])*(["0"-"9"]))*)* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? ["f","F","d","D"]
  >
  
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
|
  < BOOLEAN_LITERAL:
    "true"
    |
    "false"
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < DOUBLECOLON: "::" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < PERCENT: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < PERCENTASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| < POINTER: "->" >
| < DIAMOND: "<>" >
}

/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
  {
     matchedToken.kind = GT;
     ((Token.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
     input_stream.backup(2);
  }
| < RSIGNEDSHIFT: ">>" >
  {
     matchedToken.kind = GT;
     ((Token.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
     input_stream.backup(1);
     System.out.println("+++++ found >>");
  }
| < GT: ">" >
  {
    System.out.println("+++++ found GT");   
  }
}


/*
--------------------------------------------------------------------------------
Literals
*/
void Literal():
{}
{
    <INTEGER_LITERAL> 
    |
    <FLOATING_POINT_LITERAL>
    |
    <BOOLEAN_LITERAL>
    |
    <CHARACTER_LITERAL>
    |
    <STRING_LITERAL> 
    |
    <NULL>
}

/*
--------------------------------------------------------------------------------
Types(), Values(), and Variables()
*/

void Type():
{}
{
    LOOKAHEAD(3)
    PrimitiveType()
    |
    ReferenceType()
}

void PrimitiveType():
{}
{
    (Annotation())* ( LOOKAHEAD(2) NumericType() | <BOOLEAN> )
}

void NumericType():
{}
{
    <BYTE>
    |
    <SHORT> 
    |
    <INT>
    |
    <LONG> 
    |
    <CHAR>
    |
    <FLOAT>
    |
    <DOUBLE>
}

void ReferenceType():
{}
{
    LOOKAHEAD(3)
    ClassOrInterfaceType()
    |
    LOOKAHEAD(3)
    ArrayType()
    |
    LOOKAHEAD(3)
    TypeVariable()
}

void ClassOrInterfaceType():
{}
{
    (
        LOOKAHEAD(3)
        ClassType_lfno_classOrInterfaceType()
        |
        InterfaceType_lfno_classOrInterfaceType()
    )
    (
        LOOKAHEAD(3)
        ClassType_lf_classOrInterfaceType()
    )*
}

void ClassType():
{}
{
    LOOKAHEAD(3)
    (Annotation())* <IDENTIFIER> [TypeArguments()]
    |
    ClassOrInterfaceType() <DOT> (Annotation())* <IDENTIFIER> [TypeArguments()]
}

void ClassType_lf_classOrInterfaceType():
{}
{
    <DOT> (Annotation())* <IDENTIFIER> [TypeArguments()]   
}

void ClassType_lfno_classOrInterfaceType():
{}
{
    (Annotation())* <IDENTIFIER> [TypeArguments()]   
}

void InterfaceType():
{}
{
    ClassType()   
}

void InterfaceType_lf_classOrInterfaceType():
{}
{
    ClassType_lf_classOrInterfaceType()   
}

void InterfaceType_lfno_classOrInterfaceType():
{}
{
    ClassType_lfno_classOrInterfaceType()   
}

void TypeVariable():
{}
{
    (Annotation())* <IDENTIFIER>
}

void ArrayType():
{}
{
    LOOKAHEAD(3)
    PrimitiveType() Dims()
    |
    LOOKAHEAD(3)
    ClassOrInterfaceType() Dims()
    |
    LOOKAHEAD(3)
    TypeVariable() Dims()
}

void Dims():
{}
{
    (Annotation())* <LBRACKET> <RBRACKET> ( LOOKAHEAD(2) (Annotation())* <LBRACKET> <RBRACKET> )*

}

void TypeParameter():
{}
{
    (TypeParameterModifier())* <IDENTIFIER> [TypeBound()]
}

void TypeParameterModifier():
{}
{
    Annotation()   
}

void TypeBound():
{}
{
    LOOKAHEAD(3)
    <EXTENDS> TypeVariable()
    |
    <EXTENDS> ClassOrInterfaceType() (AdditionalBound())*
}

void AdditionalBound():
{}
{
   <BIT_AND> InterfaceType()
}

void TypeArguments():
{}
{
    <LT> TypeArgumentList() <GT>
}

void TypeArgumentList():
{}
{
    TypeArgument() (<COMMA> TypeArgument())*
}

void TypeArgument():
{}
{
    LOOKAHEAD(3)
    ReferenceType()
    |
    LOOKAHEAD(3)
    Wildcard()
}

void Wildcard():
{}
{
    (Annotation())* <HOOK> [WildcardBounds()]

}

void WildcardBounds():
{}
{
    //(<EXTENDS> | <SUPER>) ReferenceType()
    <EXTENDS> ReferenceType()
    |
    <SUPER> ReferenceType()
}

/*
--------------------------------------------------------------------------------
Productions() from §6 (Names)
*/
void TypeName():
{}
{
    <IDENTIFIER>( LOOKAHEAD(2) <DOT> <IDENTIFIER> )*
}

void PackageOrTypeName():
{}
{
    TypeName()   
}

void ExpressionName():
{}
{
    TypeName()
}

void MethodName():
{}
{
    <IDENTIFIER>
}

void PackageName():
{}
{
    TypeName()
}



/*
--------------------------------------------------------------------------------
Productions() from §7 (Packages())
*/

/* main entry point */
void CompilationUnit():
{}
{
    [ LOOKAHEAD(2) PackageDeclaration() ] ( ImportDeclaration() )* ( TypeDeclaration() )* 
}

/*
PackageDeclaration:
{PackageModifier} package Identifier {. Identifier} ;

PackageModifier:
Annotation
*/
void PackageDeclaration():
{}
{
    (PackageModifier())* <PACKAGE> PackageName()  
}

void PackageModifier():
{}
{
    Annotation()   
}

/*
ImportDeclaration:
SingleTypeImportDeclaration 
TypeImportOnDemandDeclaration 
SingleStaticImportDeclaration 
StaticImportOnDemandDeclaration
*/
void ImportDeclaration():
{}
{
    LOOKAHEAD(3)
    SingleTypeImportDeclaration()
    |
    LOOKAHEAD(2)
    TypeImportOnDemandDeclaration()
    |
    LOOKAHEAD(3)
    SingleStaticImportDeclaration()
    |
    StaticImportOnDemandDeclaration()
}

/*
SingleTypeImportDeclaration:
import TypeName ;
*/
void SingleTypeImportDeclaration():
{}
{
    <IMPORT> TypeName() <SEMICOLON>
}

/*
TypeImportOnDemandDeclaration:
import PackageOrTypeName . * ;
*/
void TypeImportOnDemandDeclaration():
{}
{
    <IMPORT> PackageOrTypeName() <DOT> <STAR> <SEMICOLON>  
}

/*
SingleStaticImportDeclaration:
import static TypeName . Identifier ;
*/
void SingleStaticImportDeclaration():
{}
{
    <IMPORT> <STATIC> TypeName() <DOT> <IDENTIFIER> <SEMICOLON>   
}
/*
StaticImportOnDemandDeclaration:
import static TypeName . * ;
*/
void StaticImportOnDemandDeclaration():
{}
{
    <IMPORT> <STATIC> TypeName() <DOT> <STAR> <SEMICOLON>   
}

void TypeDeclaration():
{}
{
    LOOKAHEAD(3)
    ClassDeclaration()
    |
    LOOKAHEAD(3)
    InterfaceDeclaration()
    |
    <SEMICOLON>
}

/*
--------------------------------------------------------------------------------
Productions() from §8 (Classes())
*/

void ClassDeclaration():
{}
{
    LOOKAHEAD(3)
    NormalClassDeclaration()
    |
    LOOKAHEAD(3)
    EnumDeclaration()
}

void NormalClassDeclaration():
{}
{
    (ClassModifier())* <CLASS> <IDENTIFIER> [TypeParameters()] [Superclass()] [Superinterfaces()] ClassBody()
}

void ClassModifier():
{}
{
    Annotation()
    |
    <PUBLIC> 
    |
    <PROTECTED> 
    |
    <PRIVATE>
    |
    <ABSTRACT> 
    |
    <STATIC> 
    |
    <STRICTFP>
    |
    <FINAL>
}

void TypeParameters():
{}
{
    <LT> TypeParameterList() <GT>
}

void TypeParameterList():
{}
{
    TypeParameter() (<COMMA> TypeParameter())*
}

void Superclass():
{}
{
    <EXTENDS> ClassType()
}

void Superinterfaces():
{}
{
    <IMPLEMENTS> InterfaceTypeList()
}

void InterfaceTypeList():
{}
{
    InterfaceType() (<COMMA> InterfaceType())*
}

void ClassBody():
{}
{
   <LBRACE> (ClassBodyDeclaration())* <RBRACE>
}

void ClassBodyDeclaration():
{}
{
    LOOKAHEAD(3)
    ClassMemberDeclaration()
    |
    InstanceInitializer()
    |
    StaticInitializer()
    |
    ConstructorDeclaration()
}

void ClassMemberDeclaration():
{}
{
    LOOKAHEAD(3)
    FieldDeclaration()
    |
    LOOKAHEAD(3)
    MethodDeclaration()
    |
    LOOKAHEAD(3)
    ClassDeclaration()
    |
    InterfaceDeclaration()
    |
    <SEMICOLON>
}

void FieldDeclaration():
{}
{
    (FieldModifier())* UnannType() VariableDeclaratorList() <SEMICOLON>
}

void FieldModifier():
{}
{
    Annotation()
    |
    <PUBLIC> 
    |
    <PROTECTED> 
    |
    <PRIVATE>
    |
    <STATIC> 
    |
    <FINAL> 
    |
    <TRANSIENT> 
    |
    <VOLATILE>
}

void VariableDeclaratorList():
{}
{
    VariableDeclarator() (<COMMA> VariableDeclarator())*
}

void VariableDeclarator():
{}
{
    VariableDeclaratorId() [<ASSIGN> VariableInitializer()]
}

void VariableDeclaratorId():
{}
{
    <IDENTIFIER> [LOOKAHEAD(2) Dims()]
}

void VariableInitializer():
{}
{
    //LOOKAHEAD(3)
    Expression()
    |
    //LOOKAHEAD(3)
    ArrayInitializer()
}

void UnannType():
{}
{
    LOOKAHEAD(3)
    UnannReferenceType()
    |
    UnannPrimitiveType()
}

void UnannPrimitiveType():
{}
{
    NumericType()
    |
    <BOOLEAN>
}

void UnannReferenceType():
{}
{
    LOOKAHEAD(3)
    UnannArrayType()
    |
    LOOKAHEAD(3)
    UnannClassOrInterfaceType()
    |
    LOOKAHEAD(3)
    UnannTypeVariable()
}

void UnannClassOrInterfaceType():
{}
{
    (
        LOOKAHEAD(3)
        UnannClassType_lfno_unannClassOrInterfaceType()
        |
        UnannInterfaceType_lfno_unannClassOrInterfaceType()
    )
    (
        LOOKAHEAD(2)
        UnannClassType_lf_unannClassOrInterfaceType()
    )*
}

void UnannClassType():
{}
{
    //<IDENTIFIER> [TypeArguments()] (<DOT> (Annotation())* <IDENTIFIER> [TypeArguments()])*
    LOOKAHEAD(3)
    <IDENTIFIER> [TypeArguments()]
    |
    LOOKAHEAD(3)
    UnannClassOrInterfaceType() <DOT> (Annotation())* <IDENTIFIER> [TypeArguments()]
}

void UnannClassType_lf_unannClassOrInterfaceType():
{}
{
    <DOT> (Annotation())* <IDENTIFIER> [TypeArguments()]   
}

void UnannClassType_lfno_unannClassOrInterfaceType():
{}
{
    <IDENTIFIER> [TypeArguments()]       
}

void UnannInterfaceType():
{}
{
    UnannClassType()   
}

void UnannInterfaceType_lf_unannClassOrInterfaceType():
{}
{
    UnannClassType_lf_unannClassOrInterfaceType()
}

void UnannInterfaceType_lfno_unannClassOrInterfaceType():
{}
{
    UnannClassType_lfno_unannClassOrInterfaceType()       
}

void UnannTypeVariable():
{}
{
    <IDENTIFIER>   
}

void UnannArrayType():
{}
{
    UnannPrimitiveType() Dims()
    |
    LOOKAHEAD(3)
    UnannClassOrInterfaceType() Dims()
    |
    LOOKAHEAD(3)
    UnannTypeVariable() Dims()
}

void MethodDeclaration():
{}
{
    (MethodModifier())* MethodHeader() MethodBody()
}

void MethodModifier():
{}
{
    Annotation()
    |
    <PUBLIC> 
    |
    <PROTECTED> 
    |
    <PRIVATE>
    |
    <ABSTRACT> 
    |
    <STATIC> 
    |
    <STRICTFP>
    |
    <FINAL>
    |
    <SYNCHRONIZED> 
    |
    <NATIVE> 
}

void MethodHeader():
{}
{
    Result() MethodDeclarator() [Throws()]
    |
    TypeParameters() (Annotation())* Result() MethodDeclarator() [Throws()]
}

void Result():
{}
{
    UnannType()
    |
    <VOID>
}

void MethodDeclarator():
{}
{
    <IDENTIFIER> <LPAREN> [FormalParameters()] <RPAREN> [Dims()]
}

// Not used, this causes problems, I'm just calling FormalParameters instead.
void FormalParameterList():
{}
{
    LOOKAHEAD(3)
    ReceiverParameter()
    |
    LOOKAHEAD(3)
    FormalParameters() <COMMA> LastFormalParameter()
    |
    LastFormalParameter()
}

void FormalParameters():
{}
{
    LOOKAHEAD(3)
    FormalParameter() ( LOOKAHEAD(2) <COMMA> FormalParameter() )*
    |
    LOOKAHEAD(3)
    ReceiverParameter() ( LOOKAHEAD(2) <COMMA> FormalParameter() )*
}

void FormalParameter():
{}
{
    (VariableModifier())* UnannType() VariableDeclaratorId()
}

void VariableModifier():
{}
{
    Annotation() 
    |
    <FINAL>
}

void LastFormalParameter():
{}
{
    LOOKAHEAD(3)
    FormalParameter()
    |
    LOOKAHEAD(3)
    (VariableModifier())* UnannType() (Annotation())* <ELLIPSIS> VariableDeclaratorId()
}

void ReceiverParameter():
{}
{
    (Annotation())* UnannType() [<IDENTIFIER> <DOT>] <THIS>
}

void Throws():
{}
{
    <THROWS> ExceptionTypeList()
}

void ExceptionTypeList():
{}
{
    ExceptionType() (<COMMA> ExceptionType())*
}

void ExceptionType():
{}
{
    LOOKAHEAD(3)
    ClassType()
    |
    LOOKAHEAD(3)
    TypeVariable()
}

void MethodBody():
{}
{
    Block()
    |
    <SEMICOLON>
}

void InstanceInitializer():
{}
{
    Block()
}

void StaticInitializer():
{}
{
    <STATIC> Block()
}

void ConstructorDeclaration():
{}
{
    (ConstructorModifier())* ConstructorDeclarator() [Throws()] ConstructorBody()
}

void ConstructorModifier():
{}
{
    Annotation()
    |
    <PUBLIC>
    |
    <PROTECTED>
    |
    <PRIVATE>
}

void ConstructorDeclarator():
{}
{
    [TypeParameters()] SimpleTypeName() <LPAREN> [FormalParameters()] <RPAREN> 
}

void SimpleTypeName():
{}
{
    <IDENTIFIER>   
}

void ConstructorBody():
{}
{
    <LBRACE> 
        [ LOOKAHEAD(3) ExplicitConstructorInvocation() ] 
        [ LOOKAHEAD(3) BlockStatements() ] 
    <RBRACE>
}

void ExplicitConstructorInvocation():
{}
{
    LOOKAHEAD(3)
    [TypeArguments()] <THIS> <LPAREN> [ArgumentList()] <RPAREN> <SEMICOLON>
    |
    LOOKAHEAD(3)
    [TypeArguments()] <SUPER> <LPAREN> [ArgumentList()] <RPAREN> <SEMICOLON>
    |
    LOOKAHEAD(3)
    ExpressionName() <DOT> [TypeArguments()] <SUPER> <LPAREN> [ArgumentList()] <RPAREN> <SEMICOLON>
    |
    LOOKAHEAD(3)
    Primary() <DOT> [TypeArguments()] <SUPER> <LPAREN> [ArgumentList()] <RPAREN> <SEMICOLON>
}

void EnumDeclaration():
{}
{
    (ClassModifier())* <ENUM> <IDENTIFIER> [Superinterfaces()] EnumBody()
}

void EnumBody():
{}
{
    <LBRACE> [EnumConstantList()] [<COMMA>] [EnumBodyDeclarations()] <RBRACE>
}

void EnumConstantList():
{}
{
    EnumConstant() ( LOOKAHEAD(2) <COMMA> EnumConstant())*
}

void EnumConstant():
{}
{
    ( Annotation() )* <IDENTIFIER> [ <LPAREN> [ArgumentList()] <RPAREN> ] [ ClassBody() ]
}

void EnumBodyDeclarations():
{}
{
    <SEMICOLON> (ClassBodyDeclaration())*
}

/*
--------------------------------------------------------------------------------
Productions() from §9 (Interfaces())
*/

void InterfaceDeclaration():
{}
{
    LOOKAHEAD(3)
    NormalInterfaceDeclaration()
    |
    LOOKAHEAD(3)
    AnnotationTypeDeclaration()
}

void NormalInterfaceDeclaration():
{}
{
    ( LOOKAHEAD(2) InterfaceModifier() )* <INTERFACE> <IDENTIFIER> [ LOOKAHEAD(2) TypeParameters() ] [ExtendsInterfaces()] InterfaceBody()
}

void InterfaceModifier():
{}
{
    Annotation()
    |
    <PUBLIC> 
    |
    <PROTECTED> 
    |
    <PRIVATE>
    |
    <ABSTRACT> 
    |
    <STATIC> 
    |
    <STRICTFP>
}

void ExtendsInterfaces():
{}
{
    <EXTENDS> InterfaceTypeList()
}

void InterfaceBody():
{}
{
    <LBRACE> ( LOOKAHEAD(2) InterfaceMemberDeclaration() )* <RBRACE> 
}

void InterfaceMemberDeclaration():
{}
{
    LOOKAHEAD(3)
    ConstantDeclaration()
    |
    LOOKAHEAD(3)
    InterfaceMethodDeclaration()
    |
    LOOKAHEAD(3)
    ClassDeclaration()
    |
    LOOKAHEAD(3)
    InterfaceDeclaration()
    |
    <SEMICOLON>
}

void ConstantDeclaration():
{}
{
    (ConstantModifier())* UnannType() VariableDeclaratorList() <SEMICOLON>
}

void ConstantModifier():
{}
{
    Annotation()
    |
    <PUBLIC>
    |
    <STATIC> 
    |
    <FINAL>
}

void InterfaceMethodDeclaration():
{}
{
    (InterfaceMethodModifier())* MethodHeader() MethodBody()
}

void InterfaceMethodModifier():
{}
{
    Annotation()
    |
    <PUBLIC>
    |
    <ABSTRACT> 
    |
    <_DEFAULT> 
    |
    <STATIC> 
    |
    <STRICTFP>
}

void AnnotationTypeDeclaration():
{}
{
    ( LOOKAHEAD(2) InterfaceModifier())* <AT> <INTERFACE> <IDENTIFIER> AnnotationTypeBody()
}

void AnnotationTypeBody():
{}
{
    <LBRACE> ( LOOKAHEAD(2) AnnotationTypeMemberDeclaration() )* <RBRACE> 
}

void AnnotationTypeMemberDeclaration():
{}
{
    LOOKAHEAD(3)
    AnnotationTypeElementDeclaration()
    |
    LOOKAHEAD(3)
    ConstantDeclaration()
    |
    LOOKAHEAD(3)
    ClassDeclaration()
    |
    LOOKAHEAD(3)
    InterfaceDeclaration()
    |
    <SEMICOLON>
}

void AnnotationTypeElementDeclaration():
{}
{
    (AnnotationTypeElementModifier())* UnannType() <IDENTIFIER> <LPAREN> <RPAREN> [Dims()] [DefaultValue()] <SEMICOLON>
}

void AnnotationTypeElementModifier():
{}
{
    Annotation()
    |
    <PUBLIC>
    |
    <ABSTRACT>
}

void DefaultValue():
{}
{
    <_DEFAULT> ElementValue()
}

void Annotation():
{}
{
    LOOKAHEAD(3)
    NormalAnnotation()
    |
    LOOKAHEAD(3)
    MarkerAnnotation()
    |
    LOOKAHEAD(3)
    SingleElementAnnotation()
}

void NormalAnnotation():
{}
{
    <AT> TypeName() <LPAREN> [ElementValuePairList()] <RPAREN> 
}

void ElementValuePairList():
{}
{
    ElementValuePair() (<COMMA> ElementValuePair())*
}

void ElementValuePair():
{}
{
    <IDENTIFIER> <ASSIGN> ElementValue()
}

void ElementValue():
{}
{
    LOOKAHEAD(3)
    ConditionalExpression()
    |
    ElementValueArrayInitializer()
    |
    LOOKAHEAD(3)
    Annotation()
}

void ElementValueArrayInitializer():
{}
{
    <LBRACE> [ElementValueList()] [<COMMA>] <RBRACE>
}

void ElementValueList():
{}
{
    ElementValue() ( LOOKAHEAD(2) <COMMA> ElementValue())*
}

void MarkerAnnotation():
{}
{
    <AT> TypeName()
}

void SingleElementAnnotation():
{}
{
    <AT> TypeName() <LPAREN> ElementValue() <RPAREN>
}

/*
--------------------------------------------------------------------------------
Productions() from §10 (Arrays())
*/

void ArrayInitializer():
{}
{
    <LBRACE> [VariableInitializerList()] [<COMMA>] <RBRACE>
}

void VariableInitializerList():
{}
{
    VariableInitializer() ( LOOKAHEAD(2) <COMMA> VariableInitializer())*
}

/*
--------------------------------------------------------------------------------
Productions() from §14 (Blocks() and Statements())
*/

void Block():
{}
{
    <LBRACE> [BlockStatements()] <RBRACE>
}

void BlockStatements():
{}
{
    BlockStatement() ( LOOKAHEAD(2) BlockStatement())*
}

void BlockStatement():
{}
{
    LOOKAHEAD(3)
    LocalVariableDeclarationStatement()
    |
    LOOKAHEAD(3)
    Statement()
    |
    LOOKAHEAD(3)
    ClassDeclaration()
}

void LocalVariableDeclarationStatement():
{}
{
    LocalVariableDeclaration() <SEMICOLON>
}

void LocalVariableDeclaration():
{}
{
    (VariableModifier())* UnannType() VariableDeclaratorList()
}

void Statement():
{}
{
    LOOKAHEAD(3)
    StatementWithoutTrailingSubstatement()
    |
    LOOKAHEAD(2)
    LabeledStatement()
    |
    LOOKAHEAD(3)
    IfThenStatement()
    |
    LOOKAHEAD(3)
    IfThenElseStatement()
    |
    WhileStatement()
    |
    ForStatement()
}

void StatementNoShortIf():
{}
{
    LOOKAHEAD(2)
    StatementWithoutTrailingSubstatement()
    |
    LOOKAHEAD(2)
    LabeledStatementNoShortIf()
    |
    IfThenElseStatementNoShortIf()
    |
    WhileStatementNoShortIf()
    |
    ForStatementNoShortIf()
}

void StatementWithoutTrailingSubstatement():
{}
{
    Block()
    |
    <SEMICOLON>     // EmptyStatement
    |
    ExpressionStatement()
    |
    AssertStatement()
    |
    SwitchStatement()
    |
    DoStatement()
    |
    BreakStatement()
    |
    ContinueStatement()
    |
    ReturnStatement()
    |
    SynchronizedStatement()
    |
    ThrowStatement()
    |
    TryStatement()
}

void LabeledStatement():
{}
{
    <IDENTIFIER> <COLON> Statement()
}

void LabeledStatementNoShortIf():
{}
{
    <IDENTIFIER> <COLON> StatementNoShortIf()
}

void ExpressionStatement():
{}
{
    StatementExpression() <SEMICOLON>
}

void StatementExpression():
{}
{
    LOOKAHEAD(3)
    Assignment()
    |
    LOOKAHEAD(3)
    MethodInvocation()
    |
    PreIncrementExpression()
    |
    PreDecrementExpression()
    |
    LOOKAHEAD(3)
    PostIncrementExpression()
    |
    LOOKAHEAD(3)
    PostDecrementExpression()
    |
    ClassInstanceCreationExpression()
}

void IfThenStatement():
{}
{
    <IF> <LPAREN> Expression() <RPAREN> Statement()
}

void IfThenElseStatement():
{}
{
    <IF> <LPAREN> Expression() <RPAREN> StatementNoShortIf() <ELSE> Statement()
}

void IfThenElseStatementNoShortIf():
{}
{
    <IF> <LPAREN> Expression() <RPAREN> StatementNoShortIf() <ELSE> StatementNoShortIf()
}

void AssertStatement():
{}
{
    //<ASSERT> Expression() [ LOOKAHEAD(2) <COLON> Expression()] <SEMICOLON>
    LOOKAHEAD(3)
    <ASSERT> Expression() <SEMICOLON>
    |
    <ASSERT> Expression() <COLON> Expression() <SEMICOLON>
}

void SwitchStatement():
{}
{
    <SWITCH> <LPAREN> Expression() <RPAREN> SwitchBlock()
}

void SwitchBlock():
{}
{
    <LBRACE> (LOOKAHEAD(2) SwitchBlockStatementGroup())* (LOOKAHEAD(2) SwitchLabel())* <RBRACE> 
}

void SwitchBlockStatementGroup():
{}
{
    SwitchLabels() BlockStatements()
}

void SwitchLabels():
{}
{
    (SwitchLabel())+
}

void SwitchLabel():
{}
{
    LOOKAHEAD(3)
    <CASE> Expression() <COLON>
    |
    <CASE> EnumConstantName() <COLON>
    |
    <_DEFAULT> <COLON>
}

void EnumConstantName():
{}
{
    <IDENTIFIER>   
}

void WhileStatement():
{}
{
    <WHILE> <LPAREN> Expression() <RPAREN> Statement()
}

void WhileStatementNoShortIf():
{}
{
    <WHILE> <LPAREN> Expression() <RPAREN> StatementNoShortIf()
}

void DoStatement():
{}
{
    <DO> Statement() <WHILE> <LPAREN> Expression() <RPAREN> <SEMICOLON>
}

void ForStatement():
{}
{
    LOOKAHEAD(3)
    BasicForStatement()
    |
    EnhancedForStatement()
}

void ForStatementNoShortIf():
{}
{
    LOOKAHEAD(3)
    BasicForStatementNoShortIf()
    |
    EnhancedForStatementNoShortIf()
}

void BasicForStatement():
{}
{
    <FOR> <LPAREN> [ForInit()] <SEMICOLON> [Expression()] <SEMICOLON> [ForUpdate()] <RPAREN> Statement()
}

void BasicForStatementNoShortIf():
{}
{
    <FOR> <LPAREN> [ForInit()] <SEMICOLON> [Expression()] <SEMICOLON> [ForUpdate()] <RPAREN> StatementNoShortIf()
}

void ForInit():
{}
{
    LOOKAHEAD(3)
    StatementExpressionList()
    |
    LOOKAHEAD(3)
    LocalVariableDeclaration()
}

void ForUpdate():
{}
{
    StatementExpressionList()
}

void StatementExpressionList():
{}
{
    StatementExpression() (<COMMA> StatementExpression())*
}

void EnhancedForStatement():
{}
{
    <FOR> <LPAREN> (VariableModifier())* UnannType() VariableDeclaratorId() <COLON> Expression() <RPAREN> Statement()
}

void EnhancedForStatementNoShortIf():
{}
{
    <FOR> <LPAREN> (VariableModifier())* UnannType() VariableDeclaratorId() <COLON> Expression() <RPAREN> StatementNoShortIf()
}

void BreakStatement():
{}
{
    <BREAK> [<IDENTIFIER>] <SEMICOLON>
}

void ContinueStatement():
{}
{
    <CONTINUE> [<IDENTIFIER>] <SEMICOLON>
}

void ReturnStatement():
{}
{
    <RETURN> [Expression()] <SEMICOLON>
}

void ThrowStatement():
{}
{
    <THROW> Expression() <SEMICOLON>
}

void SynchronizedStatement():
{}
{
    <SYNCHRONIZED> <LPAREN> Expression() <RPAREN> Block()
}

void TryStatement():
{}
{
    LOOKAHEAD(2)
    <TRY> Block() (LOOKAHEAD(3) Catches() | [Catches()] Finally())
    |
    LOOKAHEAD(2)
    TryWithResourcesStatement()
}

void Catches():
{}
{
    (CatchClause())+
}

void CatchClause():
{}
{
<CATCH> <LPAREN> CatchFormalParameter() <RPAREN> Block()   
}

void CatchFormalParameter():
{}
{
    (VariableModifier())* CatchType() VariableDeclaratorId()
}

void CatchType():
{}
{
    UnannClassType() (<BIT_OR> ClassType())*
}

void Finally():
{}
{
    <FINALLY> Block()
}

void TryWithResourcesStatement():
{}
{
    <TRY> ResourceSpecification() Block() [Catches()] [Finally()]
}

void ResourceSpecification():
{}
{
    <LPAREN> ResourceList() [<SEMICOLON>] <RPAREN> 
}

void ResourceList():
{}
{
    Resource() (LOOKAHEAD(2) <SEMICOLON> Resource())*
}

void Resource():
{}
{
    (VariableModifier())* UnannType() VariableDeclaratorId() <ASSIGN> Expression()
}

/*
--------------------------------------------------------------------------------
Productions() from §15 (Expressions())
*/

/*
Primary:
    PrimaryNoNewArray
    ArrayCreationExpression
*/
void Primary():
{}
{
    (
        LOOKAHEAD(3)
        PrimaryNoNewArray_lfno_primary()
        |
        ArrayCreationExpression()
    )
    (
        LOOKAHEAD(2)
        PrimaryNoNewArray_lf_primary()    
    )*
}

/*
PrimaryNoNewArray:
    Literal
    TypeName {[ ]} . class
    void . class
    this
    TypeName . this
    ( Expression )
    ClassInstanceCreationExpression
    FieldAccess
    ArrayAccess
    MethodInvocation
    MethodReference
*/
void PrimaryNoNewArray() :
{}
{
    LOOKAHEAD(3)
    Literal()
    |
    LOOKAHEAD(3)
    TypeName() (<LBRACKET> <RBRACKET>)* <DOT> <CLASS>
    |
    LOOKAHEAD(3)
    <VOID> <DOT> <CLASS>
    |
    LOOKAHEAD(3)
    <THIS>
    |
    LOOKAHEAD(3)
    TypeName() <THIS>
    |
    LOOKAHEAD(3)
    <LPAREN> Expression() <RPAREN>
    |
    LOOKAHEAD(3)
    ClassInstanceCreationExpression()
    |
    LOOKAHEAD(3)
    FieldAccess()
    |
    LOOKAHEAD(3)
    ArrayAccess()
    |
    LOOKAHEAD(3)
    MethodDeclaration()
    |
    MethodReference()
}

void PrimaryNoNewArray_lf_arrayAccess():
{}
{
    { return; }       
}

void PrimaryNoNewArray_lfno_arrayAccess():
{}
{
    LOOKAHEAD(3)
    Literal()
    |
    LOOKAHEAD(3)
    TypeName() (<LBRACKET> <RBRACKET>)* <DOT> <CLASS>
    |
    LOOKAHEAD(3)
    <VOID> <DOT> <CLASS>
    |
    LOOKAHEAD(3)
    <THIS>
    |
    LOOKAHEAD(3)
    TypeName() <DOT> <THIS>
    | 
    LOOKAHEAD(3)
    <LPAREN> Expression() <RPAREN>
    |
    LOOKAHEAD(3)
    ClassInstanceCreationExpression()
    |
    LOOKAHEAD(3)
    FieldAccess()
    |
    LOOKAHEAD(3)
    MethodInvocation()
    |
    MethodReference()
}

void PrimaryNoNewArray_lf_primary():
{}
{
    LOOKAHEAD(3)
    ClassInstanceCreationExpression_lf_primary()
    |
    LOOKAHEAD(3)
    FieldAccess_lf_primary()
    |
    LOOKAHEAD(3)
    ArrayAccess_lf_primary()
    |
    MethodInvocation_lf_primary()
    |
    MethodReference_lf_primary()
}

void PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary():
{}
{
    { return; }    
}

void PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary():
{}
{
    LOOKAHEAD(3)
    ClassInstanceCreationExpression_lf_primary()
    |
    LOOKAHEAD(3)
    FieldAccess_lf_primary()
    |
    MethodInvocation_lf_primary()
    |
    MethodReference_lf_primary()
}

void PrimaryNoNewArray_lfno_primary():
{}
{
    LOOKAHEAD(3)
	Literal()
	|	
	LOOKAHEAD(3)
	TypeName() (<LBRACKET> <RBRACKET>)* <DOT> <CLASS>
	|
	LOOKAHEAD(3)
	UnannPrimitiveType() (<LBRACKET> <RBRACKET>)* <DOT> <CLASS>
	|	
	LOOKAHEAD(3)
	<VOID> <DOT> <CLASS>
	|
	LOOKAHEAD(3)	
	<THIS>
	|
	LOOKAHEAD(3)
	TypeName() <DOT> <THIS>
	|	
	<LPAREN> Expression() <RPAREN>
	|	
	LOOKAHEAD(3)
	ClassInstanceCreationExpression_lfno_primary()
	|	
	LOOKAHEAD(3)
	FieldAccess_lfno_primary()
	|
	LOOKAHEAD(3)
	ArrayAccess_lfno_primary()
	|
	LOOKAHEAD(3)
	MethodInvocation_lfno_primary()
	|	
	MethodReference_lfno_primary()
}

void PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary():
{}
{
    { return; }   
}

void PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary():
{}
{
    Literal()
	|	
	LOOKAHEAD(3)
	TypeName() (<LBRACKET> <RBRACKET>)* <DOT> <CLASS>
	|
	LOOKAHEAD(3)
	UnannPrimitiveType() (<LBRACKET> <RBRACKET>)* <DOT> <CLASS>
	|	
	<VOID> <DOT> <CLASS>
	|	
	<THIS>
	|	
	LOOKAHEAD(3)
	TypeName() <DOT> <THIS>
	|	
	<LBRACKET> Expression() <RBRACKET>
	|
	LOOKAHEAD(3)
	ClassInstanceCreationExpression_lfno_primary()
	|
	LOOKAHEAD(3)
	FieldAccess_lfno_primary()
	|	
	LOOKAHEAD(3)
	MethodInvocation_lfno_primary()
	|	
	MethodReference_lfno_primary()
}

/*
ClassInstanceCreationExpression:
UnqualifiedClassInstanceCreationExpression 
ExpressionName . UnqualifiedClassInstanceCreationExpression 
Primary . UnqualifiedClassInstanceCreationExpression
*/
void ClassInstanceCreationExpression():
{}
{
    LOOKAHEAD(3)
    <NEW> [TypeArguments()] (Annotation())* <IDENTIFIER> (<DOT> (Annotation())* <IDENTIFIER>)* [TypeArgumentsOrDiamond()] <LPAREN> [ArgumentList()] <RPAREN> [ClassBody()]
    |
    LOOKAHEAD(3)
    ExpressionName() <DOT> <NEW> [TypeArguments()] (Annotation())* <IDENTIFIER> [TypeArgumentsOrDiamond()] <LPAREN> [ArgumentList()] <RPAREN> [ClassBody()]
    |
    Primary() <DOT> <NEW> [TypeArguments()] (Annotation())* <IDENTIFIER> [TypeArgumentsOrDiamond()] <LPAREN> [ArgumentList()] <RPAREN> [ClassBody()]
}

void ClassInstanceCreationExpression_lf_primary():
{}
{
    <DOT> <NEW> [TypeArguments()] (Annotation())* <IDENTIFIER> [TypeArgumentsOrDiamond()] <LPAREN> [ArgumentList()] <RPAREN> [ClassBody()]
}

void ClassInstanceCreationExpression_lfno_primary():
{}
{
    <NEW> [TypeArguments()] (Annotation())* <IDENTIFIER> (<DOT> (Annotation())* <IDENTIFIER>)* [TypeArgumentsOrDiamond()] <LPAREN> [ArgumentList()] <RPAREN> [ClassBody()]
    |
    ExpressionName() <DOT> <NEW> [TypeArguments()] (Annotation())* <IDENTIFIER> [TypeArgumentsOrDiamond()] <LPAREN> [ArgumentList()] <RPAREN> [ClassBody()]
}

void TypeArgumentsOrDiamond():
{}
{
    TypeArguments()
    |
    <DIAMOND>
}

void FieldAccess():
{}
{
    LOOKAHEAD(3)
    Primary() <DOT> <IDENTIFIER>
    |
    <SUPER> <DOT> <IDENTIFIER>
    |
    TypeName() <DOT> <SUPER> <DOT> <IDENTIFIER>
}

void FieldAccess_lf_primary():
{}
{
    <DOT> <IDENTIFIER>   
}

void FieldAccess_lfno_primary():
{}
{
    <SUPER> <DOT> <IDENTIFIER>
    |
    TypeName() <DOT> <SUPER> <DOT> <IDENTIFIER>
}

void ArrayAccess():
{}
{
    (
        LOOKAHEAD(3)
        ExpressionName() <LBRACKET> Expression() <RBRACKET>
        |
        PrimaryNoNewArray_lfno_arrayAccess() <LBRACKET> Expression() <RBRACKET>
    )
    (
        PrimaryNoNewArray_lf_arrayAccess() <LBRACKET> Expression() <RBRACKET>
    )*
}

void ArrayAccess_lf_primary():
{}
{
    (
        PrimaryNoNewArray_lf_primary_lfno_arrayAccess_lf_primary() <LBRACKET> Expression() <RBRACKET>
    )
    (
        PrimaryNoNewArray_lf_primary_lf_arrayAccess_lf_primary() <LBRACKET> Expression() <RBRACKET>
    )*
        
}

void ArrayAccess_lfno_primary():
{}
{
	(	
	    LOOKAHEAD(3)
	    ExpressionName() <LBRACKET> Expression() <RBRACKET>
	    |	
	    PrimaryNoNewArray_lfno_primary_lfno_arrayAccess_lfno_primary() <LBRACKET> Expression() <RBRACKET>
	)   
	(	
	    PrimaryNoNewArray_lfno_primary_lf_arrayAccess_lfno_primary() <LBRACKET> Expression() <RBRACKET>
	)*
	
}

/*
MethodInvocation:
    MethodName ( [ArgumentList] )
    TypeName . [TypeArguments] Identifier ( [ArgumentList] )
    ExpressionName . [TypeArguments] Identifier ( [ArgumentList] )
    Primary . [TypeArguments] Identifier ( [ArgumentList] )
    super . [TypeArguments] Identifier ( [ArgumentList] )
    TypeName . super . [TypeArguments] Identifier ( [ArgumentList] )    
*/
void MethodInvocation():
{}
{
    LOOKAHEAD(3)
    MethodName() <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN> 
    |
    // combined the 2 TypeNames
    LOOKAHEAD(3)
    TypeName() <DOT> [<SUPER> <DOT>] [LOOKAHEAD(2) TypeArguments()] <IDENTIFIER> <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN> 
    |
    LOOKAHEAD(3)
    ExpressionName() <DOT> [LOOKAHEAD(2) TypeArguments()] <IDENTIFIER> <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN>  
    |
    LOOKAHEAD(3)
    <SUPER> [<DOT> [LOOKAHEAD(2) TypeArguments()] <IDENTIFIER>] <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN>
    |
    LOOKAHEAD(3)
    Primary() <DOT> [LOOKAHEAD(2) TypeArguments()] <IDENTIFIER> <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN>
}

void MethodInvocation_lf_primary():
{}
{
    <DOT> [TypeArguments()] <IDENTIFIER>  <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN>  
}

void MethodInvocation_lfno_primary():
{}
{
    LOOKAHEAD(3)
    MethodName() <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN> 
    |
    // combined the 2 TypeNames
    LOOKAHEAD(3)
    TypeName() <DOT> [<SUPER> <DOT>] [LOOKAHEAD(2) TypeArguments()] <IDENTIFIER> <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN> 
    |
    LOOKAHEAD(3)
    ExpressionName() <DOT> [LOOKAHEAD(2) TypeArguments()] <IDENTIFIER> <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN>  
    |
    <SUPER> [<DOT> [LOOKAHEAD(2) TypeArguments()] <IDENTIFIER>] <LPAREN> [LOOKAHEAD(2) ArgumentList()] <RPAREN>
    
}

void ArgumentList():
{}
{
    Expression() (<COMMA> Expression())*
}

void MethodReference():
{}
{
    LOOKAHEAD(3)
    ExpressionName() <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    LOOKAHEAD(3)
    ReferenceType() <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    LOOKAHEAD(3)
    Primary() <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    <SUPER> <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    LOOKAHEAD(3)
    TypeName() <DOT> <SUPER> <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    LOOKAHEAD(3)
    ClassType() <DOUBLECOLON> [TypeArguments()] <NEW>
    |
    LOOKAHEAD(3)
    ArrayType() <DOUBLECOLON> <NEW>
}

void MethodReference_lf_primary():
{}
{
    <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>   
}

void MethodReference_lfno_primary():
{}
{
    LOOKAHEAD(3)
    ExpressionName() <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    LOOKAHEAD(3)
    ReferenceType() <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    <SUPER> <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    LOOKAHEAD(3)
    TypeName() <DOT> <SUPER> <DOUBLECOLON> [TypeArguments()] <IDENTIFIER>
    |
    LOOKAHEAD(3)
    ClassType() <DOUBLECOLON> [TypeArguments()] <NEW>
    |
    LOOKAHEAD(3)
    ArrayType() <DOUBLECOLON> <NEW>
    
}

void ArrayCreationExpression():
{}
{
    <NEW> 
    (
        LOOKAHEAD(3)
        PrimitiveType() DimExprs() [LOOKAHEAD(2)Dims()]
        |
        LOOKAHEAD(3)
        ClassOrInterfaceType() DimExprs() [LOOKAHEAD(2) Dims()]
        |
        LOOKAHEAD(3)
        PrimitiveType() Dims() ArrayInitializer()
        |
        ClassOrInterfaceType() Dims() ArrayInitializer()
    )
}

void DimExprs():
{}
{
    DimExpr() (LOOKAHEAD(2) DimExpr())*
}

void DimExpr():
{}
{
    (Annotation())* <LBRACKET> Expression() <RBRACKET>
}

void ConstantExpression():
{}
{
    Expression()   
}

void Expression():
{}
{
    LOOKAHEAD(3)
    LambdaExpression()
    |
    AssignmentExpression()
}

void LambdaExpression():
{}
{
    LambdaParameters() <POINTER> LambdaBody()
}

void LambdaParameters():
{}
{
    <IDENTIFIER>
    |
    LOOKAHEAD(3) 
    <LPAREN> [FormalParameters()] <RPAREN> 
    |
    LOOKAHEAD(3) 
    <LPAREN> InferredFormalParameterList() <RPAREN> 
}

void InferredFormalParameterList():
{}
{
    <IDENTIFIER> (<COMMA> <IDENTIFIER>)*
}

void LambdaBody():
{}
{
    Expression()
    |
    Block()
}

void AssignmentExpression():
{}
{
    LOOKAHEAD(3)
    ConditionalExpression()
    |
    LOOKAHEAD(3)
    Assignment()
}

void Assignment():
{}
{
    LeftHandSide() AssignmentOperator() Expression()
}

void LeftHandSide():
{}
{
    LOOKAHEAD(3)
    ExpressionName()
    |
    LOOKAHEAD(3)
    FieldAccess()
    |
    ArrayAccess()
}

void AssignmentOperator():
{}
{

    <ASSIGN>
    |
    <STARASSIGN>
    |
    <SLASHASSIGN>
    |
    <PERCENTASSIGN>
    |
    <PLUSASSIGN>  
    |
    <MINUSASSIGN>
    |
    <LSHIFTASSIGN>
    |
    <RSIGNEDSHIFTASSIGN>
    |
    <RUNSIGNEDSHIFTASSIGN>
    |
    <ANDASSIGN>  
    |
    <XORASSIGN>
    |
    <ORASSIGN>

}

/*
ConditionalExpression:
ConditionalOrExpression 
ConditionalOrExpression ? Expression : ConditionalExpression 
ConditionalOrExpression ? Expression : LambdaExpression 
*/
void ConditionalExpression():
{}
{
    ConditionalOrExpression() [LOOKAHEAD(2) <HOOK> Expression() <COLON> (LOOKAHEAD(3) ConditionalExpression() | LambdaExpression())]
}

void ConditionalOrExpression():
{}
{
    ConditionalAndExpression() ( LOOKAHEAD(2) <SC_OR> ConditionalAndExpression() )*
}

void ConditionalAndExpression():
{}
{
    InclusiveOrExpression() ( LOOKAHEAD(2) <SC_AND> InclusiveOrExpression() )*
}

void InclusiveOrExpression():
{}
{
    ExclusiveOrExpression() ( LOOKAHEAD(2) <BIT_OR> ExclusiveOrExpression() )*
}

void ExclusiveOrExpression():
{}
{
    AndExpression() ( LOOKAHEAD(2) <XOR> AndExpression() )*
}

void AndExpression():
{}
{
    EqualityExpression() ( LOOKAHEAD(2) <BIT_AND> EqualityExpression() )*
}

void EqualityExpression():
{}
{
    RelationalExpression() ( LOOKAHEAD(2) ( <EQ> | <NE> ) RelationalExpression() )*
}

void RelationalExpression():
{}
{
    ShiftExpression() ( LOOKAHEAD(2) ( <LT> | <GT> | <LE> | <GE> | <INSTANCEOF> ) ShiftExpression() )*
}

void ShiftExpression():
{}
{
    AdditiveExpression() ( LOOKAHEAD(2) ( <LSHIFT> | RSIGNEDSHIFT() | RUNSIGNEDSHIFT() ) AdditiveExpression() )*
}

void RUNSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                 getToken(1) instanceof Token.GTToken &&
                ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
   ">" ">" ">"
  )
}

void RSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                 getToken(1) instanceof Token.GTToken &&
                ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT} )
  ">" ">"
  )
}

void AdditiveExpression():
{}
{
    MultiplicativeExpression() ( LOOKAHEAD(2) ( <PLUS> | <MINUS> ) MultiplicativeExpression() )*
}

void MultiplicativeExpression():
{}
{
    UnaryExpression() ( LOOKAHEAD(2)( <STAR> | <SLASH> | <PERCENT> ) UnaryExpression()  )*
}

void UnaryExpression():
{}
{
    PreIncrementExpression()
    |
    PreDecrementExpression()
    |
    <PLUS> UnaryExpression()
    |
    <MINUS> UnaryExpression()
    |
    UnaryExpressionNotPlusMinus()
}

void PreIncrementExpression():
{}
{
    <INCR> UnaryExpression()
}

void PreDecrementExpression():
{}
{
    <DECR> UnaryExpression()
}

void UnaryExpressionNotPlusMinus():
{}
{
    ( <TILDE> | <BANG> ) UnaryExpression()
    |
    LOOKAHEAD(3)
    CastExpression()
    |
    PostfixExpression()
}

/**
 * 	:	(	primary
 * 		|	expressionName
 * 		)
 * 		(	postIncrementExpression_lf_postfixExpression
 * 		|	postDecrementExpression_lf_postfixExpression
 * 		)*
 * 	;
 */
void PostfixExpression():
{}
{
    (
        LOOKAHEAD(3)
        Primary()
        |
        ExpressionName()
    )
    (
        PostIncrementExpression_lf_postfixExpression()
        |
        PostDecrementExpression_lf_postfixExpression()
    )*
}

void PostIncrementExpression():
{}
{
    (LOOKAHEAD(3) Primary() | ExpressionName()) <INCR>
}

/**
 * postIncrementExpression_lf_postfixExpression
 * 	:	'++'
 * 	;
 */
void PostIncrementExpression_lf_postfixExpression():
{}
{
    <INCR>        
}

void PostDecrementExpression():
{}
{
    (LOOKAHEAD(3) Primary() | ExpressionName()) <DECR>
}

/**
 * postDecrementExpression_lf_postfixExpression
 * 	:	'--'
 * 	;
 */
void PostDecrementExpression_lf_postfixExpression():
{}
{
    <DECR>    
}

void CastExpression():
{}
{
    LOOKAHEAD(3)
    <LPAREN> PrimitiveType() <RPAREN> UnaryExpression()
    |
    <LPAREN> ReferenceType() (AdditionalBound())* <RPAREN> ( LOOKAHEAD(3) UnaryExpressionNotPlusMinus() | LambdaExpression() )
}



