<!-- Templates plugin user's guide: Directives chapter -->
<!-- (C) 2002 Steve Jakob -->
<!-- jEdit buffer-local properties: -->
<!-- :indentSize=1:noTabs=true:folding=explicit: -->

<!-- {{{ Chapter: Directives -->
<chapter id="directives"><title>Directives</title>

 <para>
  Directives are script elements in the Velocity Template Language that can be 
  used to manipulate the output generated by the Velocity engine. Brief 
  summaries of the standard VTL directives are included below. For a more 
  detailed description, refer to the Velocity User Guide on the Apache 
  website.
 </para>
 
 <para>
  In addition to the directives provided by the Velocity engine itself, the 
  Templates plugin includes several new directives specifically designed for 
  use within the jEdit environment. These are also described in the sections 
  below.
 </para>

 <!-- {{{ Section: Standard Velocity Directives -->
 <sect1><title>Standard Velocity Directives</title>
 
  <!-- {{{ Sub-Section: #set Directive -->
  <sect2><title>#set Directive</title>
   <para>
    One of the most basic VTL directives is the <function>#set</function> 
    directive. It is used to assign a value to either a variable 
    reference or a property reference.
   </para>
   
   <para>For example, the following are all valid #set statements:</para>
   <para>
   <example><title>#set Directive example</title>
<programlisting>
#set ( $country = "Canada" )                              ## string literal
#set ( $anumber = 1234 )                                  ## number literal
#set ( $myHome.country = $country )                       ## variable reference
#set ( $myHome.province = $country.ontario )              ## property reference
#set ( $country.leader = $worldleaders.lookup($country) ) ## method reference
#set ( $codes = ["us", $country.code, "uk", "de"] )       ## arraylist
</programlisting>
   </example>
   </para>

  </sect2>
  <!-- }}} -->
  
  <!-- {{{ Sub-Section: Conditionals -->
  <sect2><title>Conditionals (#if/#elseif/#else)</title>
   <para>
    Velocity allows for the optional inclusion of text through the use of the 
    conditional <function>#if</function> directive. The statement is considered  
    <function>true</function> if it is passed:
   </para>
    <orderedlist>
     <listitem><para>a boolean variable whose value is true</para></listitem>
     <listitem><para>an expression which evaluates to true</para></listitem>
     <listitem><para>an object which is not null</para></listitem>
    </orderedlist>
   <para>
    The following code illustrates these three cases:
   </para>
   <example><title>#if Directive example</title>
<programlisting>
#set ( $test = "true" )                              ## boolean variable
#if ( $test )
   This text is processed.
#end
#if ( $iq &lt; $shoesize )                              ## boolean expression
    Dumb as a post.
#end
#set ( $testStr = "cat")
#if ( $testStr )                                     ## non-null object
    Your pet is a $testStr.
#end
</programlisting>
   </example>
   <para>
    In addition, Velocty supports the logical AND (&amp;&amp;), OR (||) and 
    NOT (!) operators, as well as standard relational operators such as 
    equivalence (==), greater than (&gt;) and less than (&lt;). Refer to the 
    Velocity User's Guide for more information.
   </para>
   
  </sect2>
  <!-- }}} -->
  
  <!-- {{{ Sub-Section: Loops -->
  <sect2><title>Loops (#foreach)</title>
   <para>
    The <function>#foreach</function> directive provides a way to loop over a 
    template segment once for each object in a list of objects. For example, 
    the following template code:
   </para>
   <para>
   <example><title>#foreach Directive example</title>
<programlisting>
#set ( $numberList = ["one","two","three"] )
#foreach ( $number in $numberList )
... and a $number
#end
</programlisting>
   </example>
   </para>
   <para>
    ... would yield the following output when processed:
   </para>
   <para>
<programlisting>
... and a one
... and a two
... and a three
</programlisting>
   </para>
   
  </sect2>
  <!-- }}} -->
  
  <!-- {{{ Sub-Section: #include Directive -->
  <sect2><title>#include Directive</title>
   <para>
    The <function>#include</function> element can be used to import a local 
    file at the location where the <function>#include</function> directive is 
    encountered. The contents of the file are not parsed by the template engine.
   </para>
   <para>
    For example:
   </para>
   <para>
   <example><title>#include Directive example</title>
<programlisting>
## Importing a single static text file
#include ( "static_text_file.txt" );

## Importing several files
#include ( "file1.txt","file2.txt","file3.txt" );

## Referencing a file using a variable
#include ( $my_filename );
</programlisting>
   </example>
   </para>
   
  </sect2>
  <!-- }}} -->
  
  <!-- {{{ Sub-Section: #parse Directive -->
  <sect2><title>#parse Directive</title>
   <para>
    The <function>#parse</function> directive is similar to the 
    <function>#include</function> directive, but rather than importing a 
    static text file, the imported file is also parsed by the template engine.
   </para>
   
  </sect2>
  <!-- }}} -->
  
  <!-- {{{ Sub-Section: #stop Directive -->
  <sect2><title>#stop Directive</title>
   <para>
    The <function>#stop</function> directive will halt template processing by 
    the template engine. This is useful for debugging during template design.
   </para>
   
  </sect2>
  <!-- }}} -->
  
  <!-- {{{ Sub-Section: #macro Directive -->
  <sect2><title>Velocimacros (#macro Directive)</title>
   <para>
    The <function>#macro</function> directive provides an easy method of 
    defining repeated segments in a template. Here's a simple example:
   </para>
   <para>
   <example><title>Defining a simple #macro directive</title>
<programlisting>
#macro ( testmacro )
This is a test.
#end
</programlisting>
   </example>
   </para>
   <para>
    If we use our newly defined macro in a template like this:
   </para>
   <para>
<programlisting>
#testmacro ( )
#testmacro ( )
#testmacro ( )
</programlisting>
   </para>
   <para>
    ... we would end up with output like this:
   </para>
   <para>
<programlisting>
This is a test.
This is a test.
This is a test.
</programlisting>
   </para>
   <para>
    Velocimacros can be much more complex. Consider this example macro:
   </para>
   <para>
   <example><title>A more complex #macro example</title>
<programlisting>
#macro ( tablerows $myList )
#foreach( $listItem in $myList )
<![CDATA[    <tr><td>$listItem</td></tr> ]]>
#end
#end
</programlisting>
   </example>
   </para>
   <para>
    This macro could then be used to set up a simple HTML table. Here's the 
    template which makes use of the macro:
   </para>
   <para>
<programlisting>
#set ( $colours = ["red","green","blue"] )
<![CDATA[<table>]]>
#tablerows ( $colours )
<![CDATA[</table>]]>
</programlisting>
   </para>
   <para>
    ... which would result in output like this:
   </para>
   <para>
<programlisting>
<![CDATA[<table>
    <tr><td>red</td></tr>
    <tr><td>green</td></tr>
    <tr><td>blue</td></tr>
</table>]]>
</programlisting>
   </para>
   
  </sect2>
  <!-- }}} -->
  
 </sect1>
 <!-- }}} -->

 <!-- {{{ Section: jEdit-Specific Directives -->
 <sect1><title>jEdit-Specific Directives</title>
 
  <!-- {{{ Sub-Section: #prompt Directive -->
  <sect2><title>#prompt Directive</title>
   <para>
    The <function>#prompt</function> directive allows the template author to 
    specify a variable, and have the application prompt the user for a value. 
    This directive takes up to 4 parameters:
   </para>
   
    <orderedlist>
     <listitem><para>prompt string (required)</para></listitem>
     <listitem><para>variable name (required)</para></listitem>
     <listitem><para>default value (optional)</para></listitem>
     <listitem><para>override context flag (optional)</para></listitem>
    </orderedlist>
    
    <para>
     The following code:
     </para>
     <example><title>#prompt Directive example</title>
     <programlisting>#prompt ( "Class Name:" $className )</programlisting>
     </example>
     <para>would result in the user being prompted for the class name:</para>
     <para>
      <screenshot>
       <screeninfo>Velocity prompt dialog</screeninfo>
       <mediaobject>
        <imageobject>
         <imagedata align="center" fileref="images/prompt_dlg.png" format="PNG"/>
        </imageobject>
        <textobject> <phrase>Velocity prompt dialog</phrase> </textobject>
       </mediaobject>
      </screenshot>
     </para>
   
  </sect2>
<!-- }}} -->
  
  <!-- {{{ Sub-Section: #yes_no Directive -->
  <sect2><title>#yes_no Directive</title>
   <para>
    The <function>#yes_no</function> directive allows the template author to 
    have the application prompt the user to select one of two values (referred 
    to here as the "yes" and "no" values). After the user makes his/her 
    selection, the supplied variable will contain a Boolean object whose value 
    will be "true" if the user selected the "yes" value, "false" otherwise.
    This directive takes up to 4 parameters:
   </para>
   
    <orderedlist>
     <listitem><para>prompt string (required)</para></listitem>
     <listitem><para>variable name (required)</para></listitem>
     <listitem><para>text to display for the "Yes" button 
     (optional, default = "Yes")</para></listitem>
     <listitem><para>text to display for the "No" button 
     (optional, default = "No")</para></listitem>
    </orderedlist>
    
    <para>
     For example, the following code:
     </para>
     <example><title>#yes_no Directive example</title>
     <programlisting>#yes_no ( "Do you like cats?" $response "Yes, I do" "No, I don't")</programlisting>
     </example>
     <para>would result in the user being presented with the following dialog:</para>
     <para>
      <screenshot>
       <screeninfo>Velocity yes/no prompt dialog</screeninfo>
       <mediaobject>
        <imageobject>
         <imagedata align="center" fileref="images/yes_no_prompt_dlg.png" format="PNG"/>
        </imageobject>
        <textobject> <phrase>Velocity yes/no prompt dialog</phrase> </textobject>
       </mediaobject>
      </screenshot>
     </para>
   
  </sect2>
<!-- }}} -->
  
  <!-- {{{ Sub-Section: #today Directive -->
  <sect2><title>#today Directive</title>
   <para>
    The <function>#today</function> directive can be used to assign the current 
    date to a variable. Any of the date formatting options supported by 
    <function>java.text.SimpleDateFormat</function> may be used to format the 
    resulting date string.
    This directive takes up to 2 parameters:
   </para>
   
   <orderedlist>
    <listitem><para>variable name (required)</para></listitem>
    <listitem><para>formatting string (optional)</para></listitem>
   </orderedlist>
   
   <para>For example, the following code:</para>
   <example>
   <title>#today Directive example</title>
   <programlisting>
#today ( $defaultdate )
#today ( $yearonly "yyyy" )
#today ( $otherdate "dd-MMM-yyyy" )
The default format: $defaultdate
Year only: $yearonly
Another format: $otherdate
</programlisting>
   </example>
   <para>might yield the following output when processed:</para>
   <screen>
The default format: Wed May 08 01:00:05 EDT 2002
Year only: 2002
Another format: 08-MAY-2002
</screen>
   
  </sect2>
<!-- }}} -->
  
  <!-- {{{ Sub-Section: #caret Directive -->
  <sect2><title>#caret Directive</title>
   <para>
    The <function>#caret</function> directive can be used to mark the location
    at which the caret cursor should be placed following the processing of the 
    template. This directive takes no parameters.
   </para>
   <para>
    For example, the following code would create a skeleton web page, and 
    place the cursor in the body of the page in preparation for the user to 
    begin entering the page's HTML code:
   </para>
   <example>
   <title>#caret Directive example</title>
   <programlisting>
<![CDATA[
<HTML>
  <HEAD>
    <TITLE>Skeleton web page</TITLE>
  </HEAD>
  <BODY>
#caret ()
  </BODY>
</HTML>
]]>
</programlisting>
   </example>
   
  </sect2>
  <!-- }}} -->
  
  <!-- {{{ Sub-Section: #buffermode Directive -->
  <sect2><title>#buffermode Directive</title>
   <para>
    The <function>#buffermode</function> directive can be used to 
    programmatically set the mode of the current buffer. 
    This directive takes a single parameter:
   </para>
   
   <orderedlist>
    <listitem><para>buffer mode string (required)</para></listitem>
   </orderedlist>
   
   <para>
    For example, if we had a template for a generic Oracle SQL query, we 
    might want to have the template automatically set the buffer mode for
    Oracle PL-SQL. This could be accomplished with the following code:
   </para>
   <para>
   <example>
   <title>#buffermode Directive example</title>
   <programlisting>
#buffermode ( "pl-sql" )
##
## The remainder of the template starts here
##
</programlisting>
   </example>
   </para>
   
  </sect2>
  <!-- }}} -->
  
  <!-- {{{ Sub-Section: #beanshell Directive -->
  <sect2><title>#beanshell Directive</title>
   <para>
    The <function>#beanshell</function> directive is very powerful in that it
    can be used to take advantage of the BeanShell interpreter included with 
    jEdit. Embedded BeanShell scripts can be used for a multitude of 
    tasks, such as processing the contents of variables, or accessing jEdit
    internals.
   </para>
   <para>
    This directive is a block directive, so the BeanShell script
    is enclosed in a block which starts with the <function>#beanshell ()</function>
    directive, and ends with an <function>#end</function> statement. 
    This directive takes a single parameter:
   </para>
   
   <orderedlist>
    <listitem><para>return result flag (optional)</para></listitem>
   </orderedlist>
   
   <para>
    By default, the result of the script, if non-null, is written to the template. 
    You can disable this by passing a boolean "false" as the "return result 
    flag" parameter. The default value for this parameter is "true".
   </para>
   
   <para>
    For example, the following code will retrieve the file name corresponding
    to the current buffer, as well as the user name, and put them in variables
    called "filename" and "author" respectively.  Note that we pass in false as
    the first argument in order to suppress the return value of the last statement, 
    'context.put...', which returns the original value replaced by the 'put' call.
   </para>
   <para>
   <example>
   <title>#beanshell Directive example</title>
   <programlisting>
#beanshell (false)
    context.put("filename", buffer.getName());
    context.put("author", System.getProperty("user.name"));
#end
</programlisting>
   </example>
   </para>
   
  </sect2>
  <!-- }}} -->
  
 </sect1>
 <!-- }}} -->
 
</chapter>
<!-- }}} -->

