package git;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.StringList;

import common.threads.WorkRequest;
import common.threads.WorkerThreadPool;

/**
 * Refactored from p4plugin/Perforce.java
 * 
 * A simple way to execute commands as child processes, 
 * and get the output.
 * create an instance, setWorkDir(), call exec(), waitFor(), and 
 * get the output with getOutput().
 *  
 * stdout and stderr are merged into one common stream for simplicity.
 *  
 * @author ezust
 * 
 */
public class Command
{

	private ProcessBuilder pBuilder;
	private Process process;
	private StreamReader stdout;
	private Visitor visitor;
    private WorkRequest stdoutReq;
    /** 
     * 
     * @param args an array or sequence of String arguments, 
     *       the first being the actual command to execute
     */
	public Command(String... args)
	{
		if (args.length < 1)
			throw new IllegalArgumentException("command is null");
		pBuilder = new ProcessBuilder(args);
		// merge stdout and stderr 
		pBuilder.redirectErrorStream(true);
	}

	/** Set working directory for execution */
	void setWorkDir(File workDir)
	{
		pBuilder.directory(workDir);
	}

	public String toString() {
		StringList sl = new StringList();
		sl.addAll(pBuilder.command());
		String s = "(workdir=" + pBuilder.directory().toString() + ")";
		sl.add(s);
		return sl.join(" ");
	}
	/**
	 * Executes the command specified as the args to the constructor,
	 * returning true on success.
	 * 
	 */
	public boolean exec() throws IOException
	{
		if (process != null)
			throw new IllegalStateException("can't reuse CommandOutputReader objects");

		// try to run the command.
		process = pBuilder.start();

		stdout = new StreamReader(process.getInputStream());
		WorkRequest[] reqs = WorkerThreadPool.getSharedInstance().runRequests(
			new Runnable[] { stdout });
		stdoutReq = reqs[0];
		return true;
	}

	/** Wait for the process to finish, and for the process's output to 
	 * buffer.  
	 * @throws InterruptedException
	 */
	public void waitFor() throws InterruptedException
	{
		process.waitFor();
		stdoutReq.waitFor();
	}

	/**  
	 *  @return the entire output buffered as a String. */
	public String getOutput()
	{
		if (visitor != null)
			throw new IllegalStateException("no data is buffered if visitor is set");
		if (stdout == null)
			throw new IllegalStateException("command not being executed");
		if (!stdoutReq.isDone())
			throw new IllegalStateException("still reading from process");
		return stdout.getData();
	}

	/**
	 * If the visitor is set to something non-null, instead of buffering the
	 * output of the process, the CommandOutputReader will call the visitor
	 * directly as soon as lines are read from the output of the process.
	 * This makes the process more memory efficient when processing really
	 * long outputs (like those generated by "p4 files"). Be aware that the
	 * visitor's methods will be called from a thread that might not be the
	 * AWT thread.
	 * 
	 */
	public void setVisitor(Visitor v)
	{
		this.visitor = v;
	}
	
    public Process getProcess() {
        return process;
    }

    public boolean isSuccess() {
        return (process.exitValue() == 0);
    }

    public void showError(View v) {
        String msg = "Exit status: " + process.exitValue() ;
        Log.log(Log.ERROR, this, msg);
    }

    public void processOutput(Visitor visitor) {
        // break the list into individual lines.
        try {
            BufferedReader br = new BufferedReader(new StringReader(getOutput()));
            String line;
            while ((line = br.readLine()) != null)
                if (!visitor.process(line))
                    break;
            br.close();
        } catch (IOException ioe) {
            // not gonna happen for StringReader.
        }
    }

    
	private class StreamReader implements Runnable
	{

		private boolean foundError;
		private InputStream input;
		private StringBuilder data;

		public StreamReader(InputStream in)
		{
			this.input = in;

			this.data = new StringBuilder();
			this.foundError = false;
		}

		public String toString() {
			return Command.this.toString();
		}
		
		public void run()
		{
			try
			{
				byte[] buf = new byte[128];
				while (true)
				{
					int read = input.read(buf);
					if (read == -1)
						break;

					for (int i = 0; i < read; i++)
						data.append((char) buf[i]);

					if (visitor != null)
					{
						int idx;
						while ((idx = data.indexOf("\n")) >= 0)
						{
							if (idx > 0 && data.charAt(idx - 1) == '\r')
							{
								// ah, windows.
								idx--;
							}
							String line = data.substring(0, idx);
							data.delete(0, idx + 1);
							if (!foundError)
							{
								foundError = !visitor.process(line);
							}
							if (foundError)
							{
								break;
							}
						}
					}
				}
			}
			catch (IOException ioe)
			{
				Log.log(Log.DEBUG, this, ioe);
			}
		}

		public String getData()
		{
			return data.toString();
		}

	}
	/**
	 * Interface to implement a "visitor" pattern and make it easier to
	 * process the output of the command (less "cookie cutter" code).
	 */
	public static interface Visitor
	{
		/**
		 * Called once for every line in the output.
		 * 
		 * @return false if there is an error and/or we must stop reading the output.
		 */
		public boolean process(String line);

	}
}
