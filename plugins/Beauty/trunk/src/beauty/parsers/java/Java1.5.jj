
/*
Per Sreenivasa Viswanadha (as posted on the javacc user mailing list), the
original java 1.5 grammar is licensed under the BSD license, so this modified
grammar is also.

Copyright (c) 2005, Dale Anson
All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
    * Neither the name of the <ORGANIZATION> nor the names of its contributors
    may be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

options {
  //JAVA_UNICODE_ESCAPE = false;
  //UNICODE_INPUT = false;
  //ERROR_REPORTING = false;
  //DEBUG_PARSER = true;
  STATIC = false;
}

PARSER_BEGIN(JavaParser)

package beauty.parsers.java;

import java.io.*;
import java.util.*;

/**
 * Grammar to parse Java version 1.5
 * @author Sreenivasa Viswanadha - Simplified and enhanced for 1.5
 * @author Dale Anson, some updates for this and that
 *
 * DONE: look at whitespace handling in the jsp beautifier and port the ideas
 * here.  In particular, look at the special token handling and getSpecial(Token).
 * Current fix is to explicitly handle spacing in parser rules and not handle
 * whitespace in the tokenizer.
 *
 * TODO: look at javadoc stubs. This is a feature request from the mailing list.
 * The line by line parsing may make this difficult, but perhaps a post parsing
 * with a different parser (javasidekick maybe?) would be doable.
 */
public class JavaParser
{
    Token t;

    // shouldn't use this, a specific line separator should be set based on
    // buffer settings.  Of course, it may be the same as what the buffer
    // uses anyway.
    String lineSep = System.getProperty("line.separator");

    // one of these is inserted at every place in a line that qualifies as a
    // good place to break a line if it needs wrapped.  You can't type one of
    // these from the keyboard,
    char wrapSep = '\u001c';
    
    // a non-printable, non-typeable character to represent a non-breaking space
    char nbsp = '\u001d';
    
    // bracket styles
    public static final int ATTACHED = 1;
    public static final int BROKEN = 2;
    
    private int bracketStyle = ATTACHED;
    private boolean breakElse = false;
    private boolean padParens = false;

    public void setIndentWidth(int i) {
        token_source.setIndentWidth(i);
    }

    public void setTabSize(int size) {
        jj_input_stream.setTabSize(size);
    }

    public int getTabSize() {
        // this really isn't necessary for this beautifier.  Setting the tab
        // size on the input stream makes the token locations more accurate
        // is all.
        return jj_input_stream.getTabSize(0);
    }

    public void setUseSoftTabs(boolean b) {
        token_source.setUseSoftTabs(b);
    }

    public String getText() {
        return token_source.getText();
    }

    public void resetTokenSource() {
        token_source.reset();
    }

    private void add(Token t) {
        token_source.add(t);
    }

    private void add(String s) {
        token_source.add(s);
    }
     
    private void addStartBracket() {
        addStartBracket("{");
    }
    
    private void addStartBracket(String bracket) {
        switch(bracketStyle) {
            case BROKEN:
                add(lineSep);
                writeln();
                add(bracket);
                break;
            case ATTACHED:
            default:
                add(" " + bracket);
                break;
        }
    }
    
    private void addEndBracket() {
        addEndBracket("}");
    }
    
    private void addEndBracket(String bracket) {
        add(bracket);   
    }

    private void trim() {
        token_source.trim();
    }
    
    private void trimNL() {
        token_source.trimNL();   
    }
    
    private void trimNLs() {
        token_source.trimNLs();   
    }

    private void trimWhitespace() {
        token_source.trimWhitespace();
    }
    
    private void incLevel() {
        ++token_source.level;   
    }
    
    private void decLevel() {
        if (token_source.level > 0) {
            --token_source.level;   
        }
    }

    private void write() {
        token_source.write();
    }

    private void writeln() {
        token_source.writeln();
    }
    
    private void writeln(int howMany) {
        token_source.writeln(howMany);   
    }

    public void setLineSeparator(String le) {
        lineSep = le;
        token_source.setLineSeparator(le);
    }
    
    public void setBracketStyle(int style) {
        switch(style) {
            case ATTACHED:
            case BROKEN:
                bracketStyle = style;
                token_source.setBracketStyle(style);
                break;
        }
    }
    
    public void setBreakElse(boolean b) {
        breakElse = b;
        token_source.setBreakElse(b);
    }
    
    public void setPadParens(boolean pad) {
        padParens = pad; 
        token_source.setPadParens(pad);
    }
    
    public Token getNextSpecialToken(Token t) {
        return token_source.getNextSpecialToken(t);   
    }

   public JavaParser(String fileName)
   {
      this(System.in);
      try { ReInit(new FileInputStream(new File(fileName))); }
      catch(Exception e) { e.printStackTrace(); }
   }
   
   public void parse() throws ParseException {
       CompilationUnit();   
   }

    public static void main(String args[]) {
        JavaParser parser;
        if (args.length == 0) {
            System.out.println("Java Parser Version 1.1:  Reading from standard input . . .");
            parser = new JavaParser(System.in);
        } else{
            if (args.length == 1) {
                System.out.println("Java Parser Version 1.1:  Reading from file " + args[0] + " . . .");
                try {
                    parser = new JavaParser(new java.io.FileInputStream(args[0]));
                } catch (java.io.FileNotFoundException e) {
                    System.out.println("Java Parser Version 1.1:  File " + args[0] + " not found.");
                    return;
                }
            } else {
                System.out.println("Java Parser Version 1.1:  Usage is one of:");
                System.out.println("         java JavaParser < inputfile");
                System.out.println("OR");
                System.out.println("         java JavaParser inputfile");
                return;
            }
        }

        try {
            parser.CompilationUnit();
            System.out.println("Java Parser Version 1.1:  Java program parsed successfully.");
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            System.out.println("Java Parser Version 1.1:  Encountered errors during parse.");
        }
    }

}

PARSER_END(JavaParser)

/*
    A lot of work happens in the token manager.  All code in this section is
    added to a file named JavaParserTokenManager.java.  Some accessor are
    duplicated in the PARSER section above to make it a little easier to write
    code for the productions.
*/
TOKEN_MGR_DECLS :
{

    // line buffer, text is accumulated here, then written to the output stream
    // on end of line marker.
    static StringBuilder b = new StringBuilder();

    // all text is accumulated here.  When processing is complete, this buffer
    // will contain the final beautified text.
    static StringBuilder outputBuffer = new StringBuilder();

    // accumulate pieces a token or string at a time.  The objects in this array
    // will be ocnverted to strings, padded as appropriate, and added to the
    // line buffer b.  This is the "accumulator".
    static ArrayList a = new ArrayList();

    // where to write the completely beautified code.
    private static PrintWriter out = null;

    // level of indentation
    static int level = 0;

    // width of indent
    static int indent_width = 4;
    static String indent = "    ";
    static String double_indent = indent + indent;

    // the soft tab setting from jEdit, use soft tabs by default.
    static boolean useSoftTabs = true;

    // line separator, defaults to system line separator, but can be set to
    // a specific separator
    static String ls = System.getProperty("line.separator");
    
    // a non-printable, non-typeable character to represent a non-breaking space
    static char nbsp = '\u001d';

    static int bracketStyle = JavaParser.ATTACHED;
    static boolean breakElse = false;
    static boolean padParens = false;

    static void reset() {
        b = new StringBuilder();
        outputBuffer = new StringBuilder();
        a.clear();
        level = 0;
    }

    static String getText() {
        return outputBuffer.toString();
    }

    static void setLineSeparator(String le) {
        ls = le;
    }
    
    static void setBracketStyle(int style) {
        bracketStyle = style;   
    }

    static void setIndentWidth(int w) {
        indent_width = w;
        if (indent_width <= 0) {
            indent_width = 4;
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < w; i++) {
            sb.append(' ');
        }
        indent = sb.toString();
        double_indent = indent + indent;
    }

    static void setUseSoftTabs(boolean b) {
        useSoftTabs = b;
        if (b) {
            setIndentWidth(indent_width);
        }
        else {
            indent = "\t";
            double_indent = "\t\t";
        }
    }
    
    static void setBreakElse(boolean b) {
        breakElse = b;   
    }
    
    static void setPadParens(boolean pad) {
        padParens = pad;   
    }

    // add a token to the accumulator
    static void add(Token t) {
        if (t != null) {
            add(t.image);
        }
    }

    // add a string to the accumulator
    static void add(String s) {
        if (s != null) {
            a.add(s);
        }
    }

    // trim spaces from the last item in the accumulator
    static void trim() {
        if (a.size() == 0)
            return;
        Object o = a.get(a.size() - 1);
        StringBuilder sb = new StringBuilder();
        if (o instanceof Token)
            sb.append( ((Token)o).image );
        else
            sb.append((String)o);
        while(sb.length() > 0 && sb.charAt(sb.length() - 1) == ' ')
            sb.deleteCharAt(sb.length() - 1);
        a.set(a.size() - 1, sb.toString() );
    }

    // trim a single new line from the end of the output buffer
    // return true if a line ender was removed
    static boolean trimNL() {
        boolean trimmed = false;
        if(outputBuffer.length() > 0 && outputBuffer.charAt(outputBuffer.length() - 1) == '\n') {
            outputBuffer.deleteCharAt(outputBuffer.length() - 1);
            trimmed = true;
        }
        if(outputBuffer.length() > 0 && outputBuffer.charAt(outputBuffer.length() - 1) == '\r') {
            outputBuffer.deleteCharAt(outputBuffer.length() - 1);
            trimmed = true;
        }
        return trimmed;
    }
    
    static void trimNLs() {
        while(trimNL());   
    }

    // trim all \n and/or \r from the end of the given string
    static void trimNL(String s) {
        StringBuilder sb = new StringBuilder(s);
        while(sb.length() > 0 && (sb.charAt(sb.length() - 1) == '\r' || sb.charAt(sb.length() - 1) == '\n'))
            sb.deleteCharAt(sb.length() - 1);
    }

    // trim all whitespace (\r, \n, space, \t) from the start of the given string
    static String trimStart(String s) {
        StringBuilder sb = new StringBuilder(s);
        while(sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
            sb.deleteCharAt(0);
        }
        return sb.toString();
    }

    // trim up to max whitespace (\r, \n, space, \t) from the start of the given string
    static String trimStart(String s, int max) {
        StringBuilder sb = new StringBuilder(s);
        int trimmed = 0;
        while(sb.length() > 0 && Character.isWhitespace(sb.charAt(0)) && trimmed < max) {
            sb.deleteCharAt(0);
            ++trimmed;
        }
        return sb.toString();
    }

    // trims whitespace (\r, \n, space, \t) from the last items in the
    // accumulator.  If the last item is all whitespace, continues on to the
    // previous until a non-whitespace character is encountered.  If the
    // entire accumulator is whitespace, continues to trim whitespace from the
    // outputBuffer.
    static void trimWhitespace() {
        for (int i = a.size() - 1; i >= 0; i-- ) {
            Object o = a.get(i);
            StringBuilder sb = new StringBuilder();
            if (o instanceof Token)
                sb.append( ((Token)o).image );
            else
                sb.append((String)o);
            while(sb.length() > 0 && (Character.isWhitespace(sb.charAt(sb.length() - 1)))) {
                sb.deleteCharAt(sb.length() - 1);   
            }
            if (sb.length() == 0) {
                a.remove(i);
            }
            else {
                a.set(i, sb.toString());
                break;
            }
        }
        if (a.size() == 0) {
            while(outputBuffer.length() > 0 && (Character.isWhitespace(outputBuffer.charAt(outputBuffer.length() - 1)))) {
                outputBuffer.deleteCharAt(outputBuffer.length() - 1);   
            }
        }
    }

    // writes the contents of the accumulator to the outputBuffer.  The line
    // buffer (b) is used to build the line.
    static void write() {
        try {
            b.setLength(0); // clear the line buffer

            // this next section builds the output string while protecting
            // string literals.  All extra spaces are removed from the output
            // string, except that string literals are left as is.
            ArrayList list = new ArrayList();
            String s = new String("");
            for (int i = 0; i < a.size(); i++) {
                Object o = a.get(i);
                if (o instanceof Token) {
                    Token token = (Token)o;
                    if (token.kind == JavaParserConstants.STRING_LITERAL) {
                        s = s.replaceAll("[ ]+", " ");
                        list.add(s);
                        s = new String("");
                        list.add(token.image);
                    }
                    else {
                        s += ((Token)o).image;
                        s = s.replaceAll("[ ]+", " ");
                    }
                }
                else {
                    s += (String)o;
                    // replace all non-breaking space chars with actual spaces
                    s = s.replaceAll("[\u001d]", " ");
                    s = s.replaceAll("[ ]+", " ");
                }
            }
            for (int i = 0; i < list.size(); i++) {
                b.append((String)list.get(i));
            }

            b.append(s);
            s = b.toString();


            // check for blank line(s)
            String maybe_blank = new String(s);
            if (maybe_blank.trim().length() == 0) {
                // yep, it's a blank, so just print it out
                if (s.length() >= ls.length()) {
                    s = s.substring(0, s.length() - ls.length());
                }
                s = s.replaceAll(" ", "");
                s = s.replaceAll("\t", "");
                outputBuffer.append(s);
                a.clear();
                return;
            }

            // indent --
            // most lines get indented, but there are a few special cases:
            // "else" gets put on the same line as the closing "}" for the "if",
            // so don't want to indent.  Similarly with "catch" and "finally".
            // The "while" at the end of a "do" loop is marked as "^while" to
            // differentiate it from a regular "while" block. "else if" is also
            // a special case.
            if (!s.startsWith(" else")
                    && !s.startsWith(" catch")
                    && !s.startsWith(" finally")
                    && !s.startsWith(" ^while")
                    && !s.startsWith(" {")
                    && (!endsWith(outputBuffer, "else") && !endsWith(outputBuffer, "else "))) {
                s = s.trim();
                for (int i = 0; i < level; i++) {
                    s = indent + s;
                }
            }

            // maybe clean out the ^ from the specially marked "while" at the
            // end of a "do" loop
            if (s.startsWith(" ^while")) {
                b.deleteCharAt(1);
                s = b.toString();
            }

            // check if the output buffer does NOT end with a new line.  If it
            // doesn't, remove any leading whitespace from this line
            if (!endsWith(outputBuffer, "\n") && !endsWith(outputBuffer, "\r")) {
                s = trimStart(s);
            }

            // check that there aren't extra spaces in the buffer already --
            // this handles the case where the output buffer ends with a space
            // and the new string starts with a space, don't want 2 spaces.
            if (s.startsWith(" ") && endsWith(outputBuffer, " ")) {
                s = s.substring(1);
            }

            // check that there is one space between the end of the output
            // buffer and this line -- this handles the case where the output
            // buffer does not end in a space and the new string does not start
            // with a space, want one space in between, unless, of course, the
            // next character is ;.
            if (!s.startsWith(" ") && !s.startsWith(";")
                    && !endsWith(outputBuffer, " ")
                    && !endsWith(outputBuffer, "\r")
                    && !endsWith(outputBuffer, "\n")
                    && outputBuffer.length() > 0) {
                outputBuffer.append(" ");
            }

            // by the Sun standard, there is no situation where '(' is followed
            // by a space or ')' is preceded with by a space
            // -- Java 7 update: in "try with resources" there might be whitespace
            // before the last')'. I'm marking these as "^)".
            String startParen = padParens ? "( " : "(";
            String endParen = padParens ? " )" : ")";
            s = s.replaceAll("[(][ ]", startParen);
            s = s.replaceAll("[ ][)]", endParen);
            s = s.replaceAll("[(]\\s+[)]", "()");
            s = s.replaceAll("[\\^][)]", ")");
            
            // there should be no situation where a comma is preceded by a space,
            // although that seems to happen when formatting string arrays.
            s = s.replaceAll("\\s+[,]", ",");
            
            // there should be no situation where a semi-colon is preceded by a space.
            s = s.replaceAll("\\s+[;]", ";");
            
            // finally! add the string to the output buffer
            // check for line length, may need to wrap.  Sun says to avoid lines
            // longer than 80 characters.  This doesn't work well yet, so I've 
            // commented out the wrapping code.  Still need to clean out the
            // wrapping markers.
            //s = s.replaceAll("[\u001c]", "");
            outputBuffer.append(s);
            /*
            int wrap_sep_count = countWrapSep(s);
            if (s.length() - wrap_sep_count > 80) {
                String[] lines = wrapLines(s);
                if ( lines != null ) {
                    for (int i = 0; i < lines.length; i++) {
                        outputBuffer.append(lines[i]).append(ls);
                    }
                }
                else {
                    // whack any remaining \u001c characters
                    s = s.replaceAll("[\u001c]", "");
                    outputBuffer.append(s);
                }
            }
            else {
                // whack any remaining \u001c characters
                s = s.replaceAll("[\u001c]", "");
                outputBuffer.append(s);
            }
            */
            // clear the accumulator for the next line
            a.clear();
        }
        catch(Exception e) {
            e.printStackTrace();
        }
    }

    static void writeln() {
        writeln(1);
    }
    
    static void writeln(int howMany) {
        if (howMany < 1)
            return;
        write();
        trimNL();
        for (int i = 0; i < howMany; i++) {
            outputBuffer.append(ls);   
        }
    }

    static int countWrapSep(String s) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '\u001c') {
                ++count;
            }
        }
        return count;
    }

    // needs work, does a wrap, but not per spec
    static String[] wrapLines(String s) {
        if (s.length() <= 80) {
            return new String[]{s};
        }
        int wc = countWrapSep(s);
        if (wc > 0) {
            int[] break_points = new int[wc];
            int offset = 0;
            for (int i = 0; i < wc; i++) {
                int index = s.indexOf('\u001c', offset);
                break_points[i] = index;
                offset = index + 1;
            }

            int first_break = -1;
            for (int i = 0; i < break_points.length; i++) {
                int possible = break_points[i];
                if (possible > 80) {
                    break;
                }
                first_break = possible;
            }
            if ( first_break == -1 ) {
                first_break = s.length();
            }

            int ws_length = 0;
            for (int i = 0; i < s.length(); i++) {
                if (s.charAt(i) == ' ')
                    ++ws_length;
                else
                    break;
            }
            String leading_ws = s.substring(0, ws_length);
            String head = s.substring(0, first_break);
            String tail = s.substring(first_break);
            //head = head.replaceAll("[\u001c]", "");
            //tail = tail.replaceAll("[\u001c]", "");
            return new String[]{head, leading_ws + double_indent + tail};
        }
        return null;
    }

    // StringBuilder doesn't have an "endsWith" method
    static boolean endsWith(StringBuilder sb, String s) {
        if (sb == null && s == null)
            return true;
        if (sb == null && s != null)
            return false;
        if (sb.length() < s.length())
            return false;
        String end = sb.substring(sb.length() - s.length());
        return end.equals(s);
    }
    
    // TODO: look at dbconsole for the box writing routine and adapt for javadoc
    // and block comments
    static void writeJavadocComment(String s) {
        String[] lines = s.split(ls);
        
        // indent the first line.  It won't have any leading whitespace, but
        // may have trailing whitespace
        String line = lines[0].trim();
        for (int j = 0; j < level; j++) {
            line = indent + line;       // 4 spaces
        }
        outputBuffer.append(line);
        
        // handle the remaining lines, put stars in front of them.
        // TODO: this needs work.  Need to preserve whitespace after
        // the star.
        for (int i = 1; i < lines.length; i++) {
            outputBuffer.append(ls);
            line = lines[i].trim();
            
            // apply padding. All javadoc lines start with a *.
            if (line.startsWith("*")) {
                line = " " + line;
            }
            else {
                line = " * " + line;   
            }

            // apply indenting. The Sun rule is 4 spaces.
            for (int j = 0; j < level; j++) {
                line = indent + line;
            }
            
            outputBuffer.append(line);
        }
    }

    // comments of the /* ... */ variety.  This sort of comment is commonly
    // used to "comment out" a block of code, so I don't want to modify the
    // existing indenting within the block.
    static void writeBlockComment(String s) {
        String[] lines = s.split(ls);

        // indent the first line.  It won't have any leading whitespace, but
        // may have trailing whitespace
        String line = lines[0].trim();
        for (int j = 0; j < level; j++) {
            line = indent + line;
        }
        outputBuffer.append(line);
        
        // output body of comment without change
        for (int i = 1; i < lines.length - 1; i++) {
            outputBuffer.append(ls);
            line = lines[i];    // trimStart(lines[i], level * 4);
            outputBuffer.append(line);
        }
        
        // output the last line.  It will probably have leading whitespace, so
        // trim it then indent it the same as the first line.
        if (lines.length > 1) {
            outputBuffer.append(ls);
            line = lines[lines.length - 1].trim();
            for (int j = 0; j < level; j++) {
                line = indent + line;
            }
            outputBuffer.append(line);
        }
    }
    

    // handle comments like this one
    // @param t is always a special token
    static void writeEndOfLineComment(Token t) {
        String s = t.image;
        // determine if this comment is at the end of a line by going back through
        // the previous special tokens. If we hit a regular token before we
        // get a line ender, then it goes on the same line as the last regular token.
        // st will be null when it is a regular token
        boolean onNewLine = false;
        Token st = t.specialToken;
        if (st != null) {
            while(st != null) {
                if (st.kind == JavaParserConstants.LINE_ENDERS ||
                    st.kind == JavaParserConstants.BLANK_LINES ||
                    st.kind == JavaParserConstants.SINGLE_LINE_COMMENT_END ||
                    st.kind == JavaParserConstants.DOC_COMMENT_END ||
                    st.kind == JavaParserConstants.BLOCK_COMMENT_END ) {
                    onNewLine = true;
                    break;
                }
                st = st.specialToken;
            }
        }
        
        String line = s.trim();
        if (line.startsWith("//")) {
            java.util.regex.Pattern p = java.util.regex.Pattern.compile("(//+)(.*?)");
            java.util.regex.Matcher m = p.matcher(line);
            if (m.matches()) {
                String start = m.group(1);
                line = m.group(2).trim();
                line = start + " " + line;
            }
        }
        if (onNewLine) {
            for (int j = 0; j < level; j++) {
                line = indent + line;
            }
        }
        else {
            trimWhitespace();
            line = indent + line;   
        }
        outputBuffer.append(line).append(ls);
    }

    public Token getNextSpecialToken(Token t) {
        if (t == null) {
            return null;   
        }
        t = t.next;
        if (t == null) {
            return null;   
        }
        Token st = t.specialToken;
        while (st.specialToken != null) 
            st = st.specialToken;
        return st;
    }
}


/********************************************
 * THE JAVA TOKEN SPECIFICATION STARTS HERE *
 ********************************************/


/* WHITE SPACE */

SKIP :
{
    "\f"  // are these EVER used??
}


// DONE: this is the wrong way to handle these. See the jsp parser for a better way to do this.
// New approach -- skip all whitespace and blank lines and format them explicitly
// in the parser rules.
SPECIAL_TOKEN :
{
  <LINE_ENDERS: ("\n"|"\r"|"\r\n")+ >
| <BLANK_LINES: (" " | "\t")* ("\n"|"\r"|"\r\n")+ >
| <SPACES: ([" "])+ >  
| <TABS: (["\t"])+ >  
}


/* COMMENTS */
MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_DOC_COMMENT
|
  "/*" : IN_BLOCK_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT_END: "\n" | "\r" | "\r\n" > { writeEndOfLineComment(matchedToken); } : DEFAULT
}

<IN_DOC_COMMENT>
SPECIAL_TOKEN :
{
  <DOC_COMMENT_END: "*/" > { writeJavadocComment(matchedToken.image); } : DEFAULT
}

<IN_BLOCK_COMMENT>
SPECIAL_TOKEN :
{
  <BLOCK_COMMENT_END: "*/" > { writeBlockComment(matchedToken.image); } : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_DOC_COMMENT,IN_BLOCK_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

/* LITERALS */

TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <BINARY_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
|
  < #BINARY_LITERAL: "0" ["b","B"] (["0"-"1"])((["_"])*["0"-"1"])* >   // new for Java 7
|
  < #OCTAL_LITERAL: "0" (["0"-"7"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])((["_"])*(["0"-"9"]))* "." ((["0"-"9"])((["_"])*(["0"-"9"]))*)* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? ["f","F","d","D"]
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|

  <CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["u"] ["0"-"9","a"-"f"] ["0"-"9","a"-"f"] ["0"-"9","a"-"f"] ["0"-"9","a"-"f"]
            | ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  <STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >

}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| < POINTER: "->" >
| < DIAMOND: "<>" >
}

/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
  {
     matchedToken.kind = GT;
     ((Token.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
     input_stream.backup(2);
  }
| < RSIGNEDSHIFT: ">>" >
  {
     matchedToken.kind = GT;
     ((Token.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
     input_stream.backup(1);
  }
| < GT: ">" >
}


/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

/** 
 * This is the main entry  point of the parser. In general, a full compilation unit
 * is expected, however, a block statement is also acceptable.  This means that
 * this beautifier can be used to clean up random bits of java code, like
 * perhaps code in a scriptlet section in a jsp file.  A nice enhancement would
 * be to be able to support beanshell code.
 * TODO: this needs a little work, a valid compilation unit might not have a
 * package declaration or any import statements, in which case it's treated like
 * a block statement and much of the compilation unit will be lost. Not good.  
 */
void CompilationUnit():
{
}
{
    LOOKAHEAD(3)
    (
        BlockStatement()
    )
    |
    (
      [ PackageDeclaration() ]
      ( ImportDeclaration() )*
      ( TypeDeclaration() )*
    )
  <EOF>
}


void PackageDeclaration():
{}
{
    [ Annotation(true) ]        // Java 8
    t=<PACKAGE> { add("package "); } Name() ";" { add(";"); writeln(); }
}

void ImportDeclaration():
{}
{
  <IMPORT> { add("import "); } [ <STATIC> { add("static "); } ] Name() [ "." "*" { add(".*"); } ] ";" { add(";"); writeln(); }
}

/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */

int Modifiers():
{
   int modifiers = 0;
}
{
    try {
 (
  LOOKAHEAD(2)
  (
       <PUBLIC> { modifiers |= ModifierSet.PUBLIC; }
      |
       <STATIC> { modifiers |= ModifierSet.STATIC; }
      |
       <PROTECTED> { modifiers |= ModifierSet.PROTECTED; }
      |
       <PRIVATE> { modifiers |= ModifierSet.PRIVATE; }
      |
       <FINAL> { modifiers |= ModifierSet.FINAL; }
      |
       <ABSTRACT> { modifiers |= ModifierSet.ABSTRACT; }
      |
       <SYNCHRONIZED> { modifiers |= ModifierSet.SYNCHRONIZED; }
      |
       <NATIVE> { modifiers |= ModifierSet.NATIVE; }
      |
       <TRANSIENT> { modifiers |= ModifierSet.TRANSIENT; }
      |
       <VOLATILE> { modifiers |= ModifierSet.VOLATILE; }
      |
       <STRICTFP> { modifiers |= ModifierSet.STRICTFP; }
      |
       Annotation(true)
  )
 )*
    }
    catch(ParseException pe) {
        return 0;   
    }
   
 {
    return modifiers;
 }
}

/*
 * Declaration syntax follows.
 */
void TypeDeclaration():
{
   int modifiers;
}
{
    ";" { add(";"); writeln(); }
|
  modifiers = Modifiers()
  (
     LOOKAHEAD(2)
     ClassOrInterfaceDeclaration(modifiers)
   |
     EnumDeclaration(modifiers)
   |
     AnnotationTypeDeclaration(modifiers)
  )
}


void ClassOrInterfaceDeclaration(int modifiers):
{
   boolean isInterface = false;
   writeln(2);
   add(ModifierSet.toString(modifiers) + " ");
}
{
    [ Annotation(true) ]      // Java 8
  ( <CLASS> { add("class "); } | <INTERFACE> { add("interface ");  isInterface = true; } )
  t=<IDENTIFIER> { add(t); }
  [ TypeParameters() ]
  [ ExtendsList(isInterface) ]
  [ ImplementsList(isInterface) ]
  ClassOrInterfaceBody(isInterface)
}

void ExtendsList(boolean isInterface):
{
   boolean extendsMoreThanOne = false;
}
{
   <EXTENDS> { add("extends "); } ClassOrInterfaceType()
   ( "," { add(", "); } ClassOrInterfaceType() { extendsMoreThanOne = true; } )*
   {
      if (extendsMoreThanOne && !isInterface)
         throw new ParseException("A class cannot extend more than one other class");
   }
}

void ImplementsList(boolean isInterface):
{}
{
   <IMPLEMENTS> { add("implements "); } ClassOrInterfaceType()
   ( "," { add(", "); } ClassOrInterfaceType() )*
   {
      if (isInterface)
         throw new ParseException("An interface cannot implement other interfaces");
   }
}

void EnumDeclaration(int modifiers):
{
    add(ModifierSet.toString(modifiers) + " ");
}
{

  <ENUM> { add("enum "); } t=<IDENTIFIER> { add(t); }
  [ ImplementsList(false) ]
  EnumBody()
}

void EnumBody():
{}
{
    "{" { addStartBracket(); }
   EnumConstant() ( "," { add(", "); } EnumConstant() )*
   [ ";" { add(";"); writeln(); } ( ClassOrInterfaceBodyDeclaration(false) )* ]
   "}" { addEndBracket(); write(); }
}

void EnumConstant():
{}
{
    [ Annotation(true) ]     // Java 8
    t=<IDENTIFIER> { add(t); } [ Arguments() ] [ ClassOrInterfaceBody(false) ]
}

void TypeParameters():
{}
{
    "<" { trim(); add("<"); } TypeParameter() ( "," { add(", "); } TypeParameter() )* ">" { add("> "); }
}

void TypeParameter():
{}
{
    t=<IDENTIFIER> { add(t); } [ TypeBound() ]
}

void TypeBound():
{}
{
    <EXTENDS> { add("extends "); } ClassOrInterfaceType() ( "&" { add(" & "); } ClassOrInterfaceType() )*
}

void ClassOrInterfaceBody(boolean isInterface):
{}
{
    "{" { addStartBracket(); writeln(); incLevel(); } ( ClassOrInterfaceBodyDeclaration(isInterface) )* "}" { addEndBracket(); decLevel(); writeln(); }
}

void ClassOrInterfaceBodyDeclaration(boolean isInterface):
{
   boolean isNestedInterface = false;
   int modifiers;
}
{
  LOOKAHEAD(2)
  Initializer()
  {
     if (isInterface)
        throw new ParseException("An interface cannot have initializers");
  }
|
  modifiers = Modifiers() // Just get all the modifiers out of the way. If you want to do
              // more checks, pass the modifiers down to the member
  (
      ClassOrInterfaceDeclaration(modifiers)
    |
      EnumDeclaration(modifiers)
    |
      LOOKAHEAD( [ TypeParameters() ] <IDENTIFIER> "(" )   
      ConstructorDeclaration(modifiers)
    |
      LOOKAHEAD( Type() <IDENTIFIER> ( "[" "]" )* ( "," | "=" | ";" ) )
      FieldDeclaration(modifiers)
    |
      MethodDeclaration(modifiers)
  )
|
  ";" { add(";"); writeln(); }
}

void FieldDeclaration(int modifiers):
{
    add(ModifierSet.toString(modifiers) + " ");
}
{
  // Modifiers are already matched in the caller
  [ LOOKAHEAD(2) Annotation(true) ]        // Java 8
  Type() VariableDeclarator() ( "," { add(", "); } VariableDeclarator() )* ";" { add(";"); writeln(); }
}

void VariableDeclarator():
{}
{
  VariableDeclaratorId() [ "=" { add(" = "); } VariableInitializer() ]
}

void VariableDeclaratorId():
{}
{
    [ Annotation(false) ]        // Java 8
    t=<IDENTIFIER> { add(t); } 
    ( 
        [ Annotation(false) ]    // Java 8        
        "[" "]" { trim(); add("[] "); } 
    )*
}

void VariableInitializer():
{}
{
  ArrayInitializer()
|
  Expression()
}

// DONE: try to capture line separators after commas.  Long lines of array initializers
// are often split out by hand over several lines for readability.
void ArrayInitializer():
{}
{
    "{" { addStartBracket(); } 
    [ 
        VariableInitializer() 
        ( 
            LOOKAHEAD(2) t="," 
            { 
                add(", ");
                Token st = getNextSpecialToken(t);
                if (st != null && st.kind == JavaParserConstants.LINE_ENDERS) {
                    writeln();
                }
            } 
            VariableInitializer() 
        )* 
    ] 
    [ "," { add(", "); } ] 
    "}" { addEndBracket(); write(); }
}

void MethodDeclaration(int modifiers):
{
    // TODO: make it an option for how many blank lines should be before a method
    writeln(2);
    add(ModifierSet.toString(modifiers) + " ");
}
{
    // Modifiers already matched in the caller!
    [ LOOKAHEAD(2) Annotation(true) ]        // Java 8
    [ TypeParameters() ]
    ResultType()
    [ LOOKAHEAD(2) Annotation(false) ]    // Java 8
    MethodDeclarator() [ <THROWS> { add("throws "); } NameList() ]
    ( Block() | ";" { add(";"); writeln(); } )
}

void MethodDeclarator():
{}
{
  t=<IDENTIFIER> { add(t); } FormalParameters() ( "[" "]" { trim(); add("[] "); } )*
}

void FormalParameters():
{
    boolean added = false;
}
{
    "(" { trimWhitespace(); trim(); add("( "); } 
    [ 
        FormalParameter() { added = true; } 
        ( 
            "," { add(", "); } 
            FormalParameter() 
        )* 
    ] 
    ")" { if (!added) trim(); add(" )"); }
}

void FormalParameter():
{}
{
    [ Annotation(false) ]
    [ <FINAL> { add("final "); } ] 
    Type() 
    [ LOOKAHEAD(2) Annotation(false) ]     // Java 8
    [ 
        "..." { trim(); add("... "); } 
    ] 
    VariableDeclaratorId()
}

void ConstructorDeclaration(int modifiers):
{
    add(ModifierSet.toString(modifiers) + " ");
}
{
    [ LOOKAHEAD(2) Annotation(false) ]     // Java 8
  [ TypeParameters() ]
  t=<IDENTIFIER> { add(t); } FormalParameters() [ <THROWS> { add("throws "); } NameList() ]
  "{" { addStartBracket(); write(); incLevel();}
    // TODO: change lookahead to a number to avoid consuming too many tokens
    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ]
    ( BlockStatement() )*
  "}" { addEndBracket(); decLevel(); write(); }
}

void ExplicitConstructorInvocation():
{}
{
  LOOKAHEAD(<THIS> Arguments() ";")
  <THIS> { add("this"); } Arguments() ";" { add(";"); writeln(); }
|
  [ LOOKAHEAD(2) PrimaryExpression() "." ] <SUPER> { add("super"); } Arguments() ";" { add(";"); writeln(); }
}

void Initializer():
{}
{
  [ <STATIC> { add("static "); }] Block()
}


/*
 * Type, name and expression syntax follows.
 */

void Type():
{}
{
   LOOKAHEAD(2) ReferenceType()
 |
   PrimitiveType()
}

void ReferenceType():
{}
{
   PrimitiveType() ( LOOKAHEAD(2) "[" "]" { trim(); add("[] "); } )+
  |
   ( ClassOrInterfaceType() ) ( LOOKAHEAD(2) "[" "]" { trim(); add("[] "); } )*
}

void ClassOrInterfaceType():
{}
{
    [ Annotation(true) ]    // Java 8
    t=<IDENTIFIER> { add(t + " "); } [ LOOKAHEAD(2)  TypeArguments() ]
    ( LOOKAHEAD(2) "." { trim(); add("."); } [ Annotation(false) ] t=<IDENTIFIER> { add(t + " "); } [ LOOKAHEAD(2) TypeArguments() ] )*
}

void TypeArguments():
{}
{
    (
        // Java 7 allows <>
        <DIAMOND> { trim(); add("<>"); }
    )
    |
    (
        "<" { trim(); add("<"); } TypeArgument() ( "," { trim(); add(", "); } TypeArgument() )* ">" { trim(); add("> "); }
    )
}

void TypeArgument():
{}
{
   ReferenceType()
 |
   "?" { add("? "); } [ WildcardBounds() ]
}

void WildcardBounds():
{}
{
   <EXTENDS> { add("extends "); } ReferenceType()
 |
   <SUPER> { add("super "); } ReferenceType()
}


void PrimitiveType():
{}
{
    [ Annotation(false) ]    // Java 8
    (
          t=<BOOLEAN>
        |
          t=<CHAR>
        |
          t=<BYTE>
        |
          t=<SHORT>
        |
          t=<INT>
        |
          t=<LONG>
        |
          t=<FLOAT>
        |
          t=<DOUBLE>
    )
    {
        add(t + " ");
    }
}

void ResultType():
{}
{
  <VOID> { add("void "); }
|
  Type()
}

void Name():
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{}
{
    t=<IDENTIFIER> { add(t); }
  ( LOOKAHEAD(2) "." t=<IDENTIFIER> { add("."); add(t); }
  )*
}

void NameList():
{}
{
  Name() ( "," { add(", "); } Name() )*
}


/*
 * Expression syntax follows.
 */

void Expression():
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{}
{
    LOOKAHEAD(2)
    LambdaExpression()      // Java 8
    |
    ConditionalExpression()
    [
        LOOKAHEAD(2)
        AssignmentOperator() Expression()
    ]
}

// Java 8
void LambdaExpression():
{
}
{
    LambdaParameters() <POINTER> { add(" -> "); } LambdaBody()
}

// Java 8
void LambdaParameters():
{
}
{
    t=<IDENTIFIER> { add(t); } 
    |
    LOOKAHEAD(2) 
    <LPAREN> { add("("); } [FormalParameters()] <RPAREN> { add(")"); }
    |
    LOOKAHEAD(2) 
    <LPAREN> { add("("); } InferredFormalParameterList() <RPAREN> { add(")"); }
}

// Java 8
void InferredFormalParameterList():
{
}
{
    t=<IDENTIFIER> { add(t); }
    (
        <COMMA> { add(", "); } 
        t=<IDENTIFIER> { add(t); }
    )*
}

// Java 8
void LambdaBody():
{
}
{
    Expression()
    |
    Block() 
}

void AssignmentOperator():
{}
{
  (t="=" | t="*=" | t="/=" | t="%=" | t="+=" | t="-=" | t="<<=" | t=">>=" | t=">>>=" | t="&=" | t="^=" | t="|=")
  { add(" " + t.image + nbsp); }
}

void ConditionalExpression():
{}
{
    ConditionalOrExpression() [ "?" { add(" ?" + nbsp); } Expression() ":" { add(" :" + nbsp); } Expression() ]
}

void ConditionalOrExpression():
{}
{
  ConditionalAndExpression() ( "||" { add(" ||" + nbsp); } ConditionalAndExpression() )*
}

void ConditionalAndExpression():
{}
{
  InclusiveOrExpression() ( "&&" { add(" &&" + nbsp); } InclusiveOrExpression() )*
}

void InclusiveOrExpression():
{}
{
  ExclusiveOrExpression() ( "|" { add(" |" + nbsp); } ExclusiveOrExpression() )*
}

void ExclusiveOrExpression():
{}
{
  AndExpression() ( "^" { add(" ^" + nbsp); } AndExpression() )*
}

void AndExpression():
{}
{
  EqualityExpression() ( "&" { add(" &" + nbsp); } EqualityExpression() )*
}

void EqualityExpression():
{}
{
  InstanceOfExpression() ( ( "==" { add(" ==" + nbsp); } | "!=" { add(" !=" + nbsp); } ) InstanceOfExpression() )*
}

void InstanceOfExpression():
{}
{
  RelationalExpression() [ <INSTANCEOF> { add(" instanceof "); } Type() ]
}

void RelationalExpression():
{}
{
  ShiftExpression() ( ( "<" { add(" <" + nbsp); } | ">" { add(" >" + nbsp); } | "<=" { add(" <=" + nbsp); } | ">=" { add(" >=" + nbsp); } ) ShiftExpression() )*
}

void ShiftExpression():
{}
{
  AdditiveExpression() ( ( "<<" { add(" <<" + nbsp); } | RSIGNEDSHIFT() | RUNSIGNEDSHIFT() ) AdditiveExpression() )*
}

void AdditiveExpression():
{}
{
  MultiplicativeExpression() ( ( "+" { add(" +" + nbsp); } | "-" { add(" -" + nbsp); } ) MultiplicativeExpression() )*
}

void MultiplicativeExpression():
{}
{
  UnaryExpression() ( ( "*" { add(" *" + nbsp); } | "/" { add(" /" + nbsp); } | "%" { add(" %" + nbsp); } ) UnaryExpression() )*
}

void UnaryExpression():
{}
{
    // DONE: need to check for line separator following "+" and preserve it.
    // It is fairly common to break long strings into several lines concatenated
    // with +.  It's not good form, I know, but it is still done.
  ( t="+" 
    { 
        add(" +");
        Token st = getNextSpecialToken(t);
        if (st != null && st.kind == JavaParserConstants.LINE_ENDERS) {
            writeln();
        }
    } 
    | 
    "-" 
    { 
        add(" -"); 
    } 
  ) 
  UnaryExpression()
|
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  UnaryExpressionNotPlusMinus()
}

void PreIncrementExpression():
{}
{
  "++" { add(" ++"); } PrimaryExpression()
}

void PreDecrementExpression():
{}
{
  "--" { add(" --"); } PrimaryExpression()
}

void UnaryExpressionNotPlusMinus():
{}
{
  ( "~" { add(" ~"); } | "!" { add(" !"); } ) UnaryExpression()
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PostfixExpression()
}

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this. Nothing needs to be output from this production.
void CastLookahead():
{}
{
  LOOKAHEAD(2)
  "("  PrimitiveType()
|
  LOOKAHEAD("(" Type() "[")
  "("  Type() "[" "]" { trim(); add("[] "); }
|
  "("  Type() ")" ( "~" | "!" | "(" | <IDENTIFIER> | <THIS> | <SUPER> | <NEW> | Literal() )
}

void PostfixExpression():
{}
{
  PrimaryExpression() [ "++" { trim(); add("++"); } | "--" { trim(); add("--"); } ]
}

void CastExpression():
{}
{
  LOOKAHEAD("(" PrimitiveType())
  "(" { add("( "); } Type() ")" { trim(); add(" ) "); } UnaryExpression()
|
  "(" { add("( "); } Type() ")" { trim(); add(" ) "); } UnaryExpressionNotPlusMinus()
}

void PrimaryExpression():
{}
{
  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
}

void MemberSelector():
{}
{
  "." { add("."); } TypeArguments() t=<IDENTIFIER> { add(t); }
}

void PrimaryPrefix():
{}
{
  Literal()
|
  <THIS> { add("this"); }
|
  <SUPER> "." { add("super."); } t=<IDENTIFIER> { add(t); }
|
  LOOKAHEAD( ClassOrInterfaceType() "." <IDENTIFIER> )
  ClassOrInterfaceType() "." { trimWhitespace(); add("."); } t=<IDENTIFIER> { add(t); }
|
  // fix for 1561502
  LOOKAHEAD( ClassOrInterfaceType() "." <SUPER> "." <IDENTIFIER> )
  ClassOrInterfaceType()"." <SUPER> "." { trimWhitespace(); add(".super."); } t=<IDENTIFIER> { add(t); }
|
  "(" { add("( "); } Expression() ")" { add(" )"); }
|
  AllocationExpression()
|
  LOOKAHEAD( ResultType() "." <CLASS> )
  ResultType() "." <CLASS> { trim(); add(".class"); }
|
  Name()
}

void PrimarySuffix():
{}
{
  LOOKAHEAD(2)
  "." <THIS> { add(".this"); }
|
  LOOKAHEAD(2)
  "." { add("."); } AllocationExpression()
|
  LOOKAHEAD(3)
  MemberSelector()
|
  "[" { trim(); add("["); } Expression() "]" { trim(); add("]"); }
|
  "." { add("."); } t=<IDENTIFIER> { add(t); }
|
  Arguments()
}

void Literal():
{}
{
  t=<INTEGER_LITERAL> { /*trim();*/ add(t); }
|
  t=<FLOATING_POINT_LITERAL> { trim(); add(t); }
|
  t=<CHARACTER_LITERAL> { add(t); }
|
  t=<STRING_LITERAL> { add(t); }
|
  BooleanLiteral()
|
  NullLiteral()
}

void BooleanLiteral():
{}
{
  <TRUE> { add("true"); }
|
  <FALSE> { add("false"); }
}

void NullLiteral():
{}
{
  <NULL> { add("null"); }
}

void Arguments():
{
    boolean added = false;
}
{
    "(" { trimWhitespace(); trim(); add("( "); } [ ArgumentList() { added = true; } ] ")" { if (!added) trim(); add(" )"); }
}

void ArgumentList():
{}
{
  Expression() ( "," { add(", "); } Expression() )*
}

void AllocationExpression():
{}
{
  LOOKAHEAD(2)
  <NEW> { add("new "); } PrimitiveType() ArrayDimsAndInits()
|
  <NEW> { add("new "); } ClassOrInterfaceType() [ TypeArguments() ]
    (
      ArrayDimsAndInits()
    |
      Arguments() [ ClassOrInterfaceBody(false) ]
    )
}

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits():
{}
{
  LOOKAHEAD(2)
  ( LOOKAHEAD(2) "[" { trimWhitespace(); add("["); } Expression() "]" { trim(); add("]"); } )+ ( LOOKAHEAD(2) "[" "]" { trim(); add("[] "); } )*
|
  ( "[" "]" { trim(); add("[]"); } )+ ArrayInitializer()
}


/*
 * Statement syntax follows.
 */
void Statement():
{}
{
  LOOKAHEAD(2)
  LabeledStatement()
|
  AssertStatement()
|
  Block()
|
  EmptyStatement()
|
  StatementExpression() ";" { add(";"); writeln(); }
|
  SwitchStatement()
|
  IfStatement()
|
  WhileStatement()
|
  DoStatement()
|
  ForStatement()
|
  BreakStatement()
|
  ContinueStatement()
|
  ReturnStatement()
|
  ThrowStatement()
|
  SynchronizedStatement()
|
  TryStatement()
}


void AssertStatement():
{}
{
    <ASSERT> { add("assert "); } Expression() [ ":" { add(":"); } Expression() ] ";" { add(";"); writeln(); }
}

void LabeledStatement():
{}
{
    t=<IDENTIFIER> { add(t); } ":" { add(":"); } Statement()
}

void Block():
{
}
{
    "{" { trimWhitespace(); addStartBracket(); writeln(); incLevel(); }
        ( BlockStatement() )*
    "}" { addEndBracket(); decLevel(); writeln(); }    // TODO: don't always want to do this, for example with an anonymous inner class
}

void BlockStatement():
{}
{
    [LOOKAHEAD(2) Annotation(false) ]
    (
        LOOKAHEAD([ <FINAL> ] Type() <IDENTIFIER>)
        LocalVariableDeclaration() ";" { add(";"); writeln(); }
        |
        LOOKAHEAD(3)
        Statement()
        |
        ClassOrInterfaceDeclaration(0)
    )
}

void LocalVariableDeclaration():
{
    int m = 0;
}
{
  // old: [ "final" { add("final "); } ] Type() VariableDeclarator() ( "," { add(", "); } VariableDeclarator() )* 
  [LOOKAHEAD(2) Annotation(false)] 
  m = Modifiers() {add(ModifierSet.toString(m) + " ");} 
  Type() 
  VariableDeclarator() 
  ( 
      "," { add(", "); } 
      VariableDeclarator() 
  )* 
}

void EmptyStatement():
{}
{
  ";" 
  {
      // add(token_source.ls); add(token_source.ls);  write(); add(";"); write();
      add(";" + lineSep);
      write();
  }
}

void StatementExpression():
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{}
{
  PreIncrementExpression()
|
  PreDecrementExpression()
|
  PrimaryExpression()
  [
    "++" { add("++"); }
  |
    "--" { add("--"); }
  |
    AssignmentOperator() Expression()
  ]
}

void SwitchStatement():
{}
{
    <SWITCH> "(" { add("switch ( "); } Expression() ")" "{" { add(" ) "); addStartBracket(); write(); incLevel(); }
        ( SwitchLabel() { incLevel();} ( BlockStatement() )* { decLevel();} )*
    "}" { addEndBracket(); decLevel(); write(); }
}

void SwitchLabel():
{}
{
<CASE> { add("case "); } Expression() ":" { add(":"); write(); }
|
<_DEFAULT> ":" { add("default:"); write(); }
}

void IfStatement():
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
    boolean no_block = false;
    Token t;
}
{
    <IF> "("
    {
        add("if ( ");
    }
    Expression() ")"
    { 
        add(" ) ");
        
        // Sun's coding standard says there should always be a block following
        // an "if" statement, so add the brackets if they are missing
        if (!getToken(1).image.equals("{")) {
            trimWhitespace(); 
            trim(); 
            addStartBracket();
            writeln();
            incLevel();
            no_block = true;
        }
    }
    Statement()
    {
        if (no_block) {
            writeln();
            decLevel();
            addEndBracket();
            write();
        }
        no_block = false;
    }

    [
        LOOKAHEAD(1) t=<ELSE>
        { 
            Token st = t.specialToken;
            Token ct = null;    // comment token
            while (st != null && ct == null) {
                switch(st.kind) {
                    // skip over whitespace
                    case JavaParserConstants.LINE_ENDERS:
                    case JavaParserConstants.BLANK_LINES:
                    case JavaParserConstants.SPACES:
                    case JavaParserConstants.TABS:
                        st = st.specialToken;
                        continue;
                    default:
                        continue;
                }
            }
            trimWhitespace(); 
            trim(); 
            if (ct != null || bracketStyle == BROKEN || breakElse) {
                // have comment token preceding 'else', so start 'else' on new line
                writeln();
                add("else ");
            }
            else {
                add(" else "); 
            }
        }
        {
            if (getToken(1).image.equals("if")) {
                return;   
            }
            // Sun's coding standard says there should always be a block following
            // an "else" statement, so add the brackets if they are missing
            if (!getToken(1).image.equals("{")) {
                // remove any excess whitespace between the 'else' and the '{'
                trimWhitespace();
                trim();
                addStartBracket();
                writeln();
                incLevel();
                no_block = true;
            }
        }
        Statement()
        {
            if (no_block) {
                writeln();
                decLevel();
                addEndBracket();
                write();
            }
        }
    ]
}

void WhileStatement():
{
    boolean no_block = false;
}
{
    <WHILE> "(" { add("while ( "); } Expression() ")" { add(" )"); }
    {
        // if the next token isn't a "{" (indicating the start of a block) or
        // a ";" (indicating an empty statement), add "{" to make sure there is
        // indeed a block written.
        if (!getToken(1).image.equals("{") && !getToken(1).image.equals(";")) {
            addStartBracket();
            writeln();
            incLevel();
            no_block = true;
        }
    }
    Statement()
    {
        if (no_block) {
            writeln();
            decLevel();
            addEndBracket();
            writeln();
        }
    }
}

void DoStatement():
{}
{
    <DO> 
    { 
        add("do "); 
    } 
    Statement() 
    
    <WHILE> "(" 
    { 
        trimWhitespace(); 
        if (breakElse) {
            writeln();
            add("while ( ");
        }
        else {
            // adding a ^ to the front of 'while' to differentiate it from 'while' at the
            // start of a 'while' loop.  This will be stripped off later.
            add(" ^while ( ");
        }
    } 
    Expression() 
    ")" ";" 
    { 
        add(" );" + lineSep); 
        write(); 
    }
}

void ForStatement():
{
    boolean no_block = false;
}
{
  <FOR> "(" { add("for ( "); }

  (
      // DONE: allow optional "final" here, as in for(final myType : myList)
      LOOKAHEAD([Annotation(false)][<FINAL>] Type() <IDENTIFIER> ":")
      [LOOKAHEAD(2) Annotation(false)][ <FINAL> { add("final "); }] Type() t=<IDENTIFIER> { add(t); } ":" { add(" : "); } Expression()
    |
    [ ForInit() ] ";" { add("; "); } [ Expression() ] ";" { add("; "); } [ ForUpdate() ]
  )

  ")" { add(" )"); }
    {
        // if the next token isn't a "{" (indicating the start of a block) or
        // a ";" (indicating an empty statement), add "{" to make sure there is
        // indeed a block written.
        if (!getToken(1).image.equals("{") && !getToken(1).image.equals(";") ) {
            addStartBracket();
            writeln();
            incLevel();
            no_block = true;
        }
    }
    Statement()
    {
        if (no_block) {
            writeln();
            decLevel();
            addEndBracket();
            writeln();
        }
    }
}

void ForInit():
{}
{
  LOOKAHEAD( [ <FINAL> ] Type() <IDENTIFIER> )
  LocalVariableDeclaration()
|
  StatementExpressionList()
}

void StatementExpressionList():
{}
{
  StatementExpression() ( "," { add(", "); } StatementExpression() )*
}

void ForUpdate():
{}
{
  StatementExpressionList()
}

void BreakStatement():
{}
{
  <BREAK> { add("break"); } [ t=<IDENTIFIER> { add(t); } ] ";" { add(";"); writeln(); }
}

void ContinueStatement():
{}
{
  <CONTINUE> { add("continue"); } [ t=<IDENTIFIER> { add(t); } ] ";" { add(";"); writeln(); }
}

void ReturnStatement():
{}
{
  <RETURN> { add("return "); } [ Expression() ] ";" { trim(); add(";"); writeln(); }
}

void ThrowStatement():
{}
{
  <THROW> { add("throw"); } Expression() ";" { add(";"); writeln(); }
}

void SynchronizedStatement():
{}
{
  <SYNCHRONIZED> "(" { add("synchronized ( "); } Expression() ")" { add(" )"); } Block()
}

void TryStatement():
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
{
    Token st;
}
{
  <TRY> 
  { 
    add("try "); 
  } 
  // Java 7 supports "try with resources". Want to format like this:
  // try (
  //   java.util.zip.ZipFile zf = new java.util.zip.ZipFile(zipFileName);
  //   java.io.BufferedWriter writer = java.nio.file.Files.newBufferedWriter(outputFilePath, charset)
  // ) {  
  [
    "(" 
        { trimWhitespace(); addStartBracket("("); write(); incLevel(); }
        LocalVariableDeclaration()
        (
            LOOKAHEAD(2) 
            ";" { add(";"); writeln(); }
            LocalVariableDeclaration()
        )* 
        [ ";" { add(";"); writeln(); } ] 
        ")" { decLevel(); addEndBracket("^)"); write(); }
  ]
  
  Block()
  
  ( <CATCH> "(" 
      { 
            st = t.specialToken;
            Token ct = null;    // comment token
            while (st != null && ct == null) {
                switch(st.kind) {
                    // skip over whitespace
                    case JavaParserConstants.LINE_ENDERS:
                    case JavaParserConstants.BLANK_LINES:
                    case JavaParserConstants.SPACES:
                    case JavaParserConstants.TABS:
                        st = st.specialToken;
                        continue;
                    default:
                        continue;
                }
            }
            trimWhitespace(); 
            trim(); 
            if (ct != null || bracketStyle == BROKEN || breakElse) {
                // have comment token preceding 'catch', so start 'catch' on new line
                writeln();
                add("catch ( ");
            }
            else {
                add(" catch ( "); 
            }
      } 
      
      (
          LOOKAHEAD(3)
          FormalParameter() 
          |
          ClassOrInterfaceType()(LOOKAHEAD(2) "|" { add(" | "); } ClassOrInterfaceType())+ VariableDeclaratorId()
      )
      ")" { add(" ) "); } Block() )*
      
  [ 
    <FINALLY> 
        { 
            st = t.specialToken;
            Token ct = null;    // comment token
            while (st != null && ct == null) {
                switch(st.kind) {
                    // skip over whitespace
                    case JavaParserConstants.LINE_ENDERS:
                    case JavaParserConstants.BLANK_LINES:
                    case JavaParserConstants.SPACES:
                    case JavaParserConstants.TABS:
                        st = st.specialToken;
                        continue;
                    // check for comment
                    /*
                    case JavaParserConstants.END_OF_LINE_COMMENT:
                    case JavaParserConstants.JAVADOC_COMMENT:
                    case JavaParserConstants.BLOCK_COMMENT:
                        ct = st;
                        break;
                    */
                    default:
                        continue;
                }
            }
            trimWhitespace(); 
            trim(); 
            if (ct != null || bracketStyle == BROKEN || breakElse) {
                // have comment token preceding 'finally', so start 'finally' on new line
                writeln();
                add("finally ");
            }
            else {
                add(" finally"); 
            }
        } 
        Block() 
  ]
}

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

void RUNSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
      ">" ">" ">" { add(" >>> "); }
  )
}

void RSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT} )
      ">" ">" { add(" >> "); }
  )
}

/* Annotation syntax follows. */

void Annotation(boolean addLineBreak):
{
}
{
    LOOKAHEAD( "@" Name() "(" ( <IDENTIFIER> "=" | ")" ))
    NormalAnnotation(addLineBreak)
    |
    LOOKAHEAD( "@" Name() "(" )
    SingleMemberAnnotation(addLineBreak) 
    |
    MarkerAnnotation(addLineBreak)
}

void NormalAnnotation(boolean addLineBreak):
{
}
{
   "@" { if (addLineBreak){ writeln();} add("@"); } Name() "(" { add("( "); } [ MemberValuePairs() ] ")" 
   
    { 
        trimWhitespace(); 
        trim(); 
        add(" )");
        if (addLineBreak)
            writeln();
        else
            write();
    }
}

void MarkerAnnotation(boolean addLineBreak):
{
}
{
    "@" 
    { 
        if (addLineBreak) { 
            token_source.trimNL(); 
            writeln(); 
        }
        add("@"); 
    } 
    Name() 
    {
        if (addLineBreak)
            writeln();
        else
            write();
    }
}

void SingleMemberAnnotation(boolean addLineBreak):
{
}
{
  "@" { if (addLineBreak) writeln(); add("@"); } Name() "(" { add("( "); } MemberValue() ")" {add(")");}
  { 
        if (addLineBreak)
            writeln();
        else
            write();
  }
}

void MemberValuePairs():
{}
{
   MemberValuePair() ( "," { add(", "); } MemberValuePair() )*
}

void MemberValuePair():
{}
{
    t=<IDENTIFIER> { add(t); } "=" { add(" = "); } MemberValue()
}

void MemberValue():
{}
{
   Annotation(true)
 |
   MemberValueArrayInitializer()
 |
   ConditionalExpression()
}

void  MemberValueArrayInitializer():
{}
{
    "{" { addStartBracket(); } MemberValue() ( LOOKAHEAD(2) "," { add(", "); } MemberValue() )* [ "," { add(", "); } ] "}" { addEndBracket();  }
}


/* Annotation Types. */

void AnnotationTypeDeclaration(int modifiers):
{
    add(ModifierSet.toString(modifiers) + " ");
}
{
  "@" <INTERFACE> { add("@interface"); } t=<IDENTIFIER> { add(t); } AnnotationTypeBody()
}

void AnnotationTypeBody():
{}
{
    "{" { addStartBracket(); write(); incLevel(); } ( AnnotationTypeMemberDeclaration() )* "}" { decLevel(); addEndBracket(); write(); }
}

void AnnotationTypeMemberDeclaration():
{
   int modifiers;
}
{
 modifiers = Modifiers()
 (
   LOOKAHEAD(Type() <IDENTIFIER> "(")
   Type() t=<IDENTIFIER> { add(t); } "(" ")" { add("()"); } [ DefaultValue() ] ";" { add(";"); writeln(); }
  |
   LOOKAHEAD(3)
   ClassOrInterfaceDeclaration(modifiers)
  |
   EnumDeclaration(modifiers)
  |
   LOOKAHEAD(2)
   AnnotationTypeDeclaration(modifiers)
  |
   FieldDeclaration(modifiers)
 )
 |
   ( ";" { add(";"); writeln(); } )
}

void DefaultValue():
{}
{
  <_DEFAULT> { add("default"); } MemberValue()
}
