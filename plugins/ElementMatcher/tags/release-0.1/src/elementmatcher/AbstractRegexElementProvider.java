package elementmatcher;

import javax.swing.text.Segment;
import java.util.Iterator;
import java.util.regex.MatchResult;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/** !!!javadoc outdated!!!
 * Element provider.
 * Elements are first searched by regex, then each matching string is passed to {@link #getElement}, which either returns
 * element object or null, if string does not define correct element.
 * If element provider doesn't supply regex, entire text buffer are not searched, instead only selected text
 * is passed to {@link #getElement}.
 *
 * @param <T> class of elements generated by this provider
 */
public abstract class AbstractRegexElementProvider<T> extends AbstractElementProvider<T> {

    private MatcherElementIterator matcherElementIterator = new MatcherElementIterator();

    /** Return regex elements must match.
     *
     * @return regex or null, if regex matching should not be performed
     */
    protected abstract Pattern getRegex();

    protected abstract T getElement(MatchResult match);

    protected AbstractRegexElementProvider(String name) {
        super(name);
    }

    public Iterator<Element<T>> getElements(int line, Segment segment) {
        final Matcher matcher = getRegex().matcher(segment);
        matcherElementIterator.reset(line, matcher);
        return matcherElementIterator;
    }

    protected Element<T> getElementInternal(int line, Matcher match) {
        final T data = getElement(match);
        if (data != null) {
            return new Element<T>(AbstractRegexElementProvider.this, line, match.start(), match.end(), data);
        }
        return null;
    }

    private class MatcherElementIterator implements Iterator<Element<T>> {

        private int line;
        private Matcher matcher;
        private Element<T> next;

        private void reset(int line, Matcher matcher) {
            this.line = line;
            this.matcher = matcher;
            next = null;
        }

        public boolean hasNext() {
            if (next != null) {
                return true;
            }
            if (!matcher.find()) {
                return false;
            }
            next = getElementInternal(line, matcher);
            if (next != null) {
                return true;
            }
            return hasNext();
        }

        public Element<T> next() {
            final Element<T> current = next;
            next = null;
            return current;
        }

        public void remove() {
            throw new UnsupportedOperationException();
        }

    }

}