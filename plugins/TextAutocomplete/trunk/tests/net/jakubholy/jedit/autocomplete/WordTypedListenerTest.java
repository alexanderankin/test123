package net.jakubholy.jedit.autocomplete;

import java.util.Observable;
import java.util.Observer;
import java.util.Vector;

import net.jakubholy.jedit.autocomplete.WordTypedListener.Filter;

public class WordTypedListenerTest extends AbstractJEditBufferTest implements Observer
{
	
	WordTypedListener listener 	= null;
	private Filter isWordChecker;
	/** List of events generated by the listener. */
	Vector<Object> events = null;
	/** List of events expected to be generated by the listener. */
	private Vector<WordTypedEvent> expectedEvents = null;

	public WordTypedListenerTest(String arg0)
	{
		super(arg0);
	}
	
	/* (non-Javadoc)
	 * @see net.jakubholy.jedit.autocomplete.AbstractJEditTest#setUp()
	 */
	protected void setUp() throws Exception
	{
		super.setUp();
		
		listener = new WordTypedListener();
		listener.addObserver( this );
		isWordChecker = PreferencesManager.getPreferencesManager()
			.getIsWordFilter();
		listener.setCheckIsWord( isWordChecker );
		buffer.addBufferListener( listener );
		
		events 			= new Vector<Object>(10);
		expectedEvents 	= new Vector<WordTypedEvent>(10);
	}
	
	///////////////////////////////////////////////////////////////////////////

	/*
	 * Test method for 'net.jakubholy.jedit.autocomplete.WordTypedListener.contentInserted(JEditBuffer, int, int, int, int)'
	 */
	public void testContentInserted()
	{
		StringBuffer word = new StringBuffer(10);
		char insertion;
		WordTypedEvent event = null;
		int offset = 0;
		
		// Start a word
		insertion = 'a';
		event = new WordTypedEvent(WordTypedEvent.AT_START, 
				new StringBuffer(word).append(insertion), 
				String.valueOf(insertion));
		typeCharIntoBuffer(offset++, word, insertion, event, true);
		
		// Continue the word
		insertion = 'b';
		event = new WordTypedEvent(WordTypedEvent.INSIDE, 
				new StringBuffer(word).append(insertion), 
				String.valueOf(insertion));
		typeCharIntoBuffer(offset++, word, insertion, event, true);
		
		// End word char
		insertion = ';';
		event = new WordTypedEvent(WordTypedEvent.AT_END, 
				new StringBuffer(word), 
				String.valueOf(insertion));
		typeCharIntoBuffer(offset++, word, insertion, event, false);
		
		// Check expected vs. received events:
		waitUntilAllEvents();
		assertEquals(expectedEvents, events);		
	}

	/**
	 * Wait until the number of received events == count of expected events.
	 * With timeout (error printed into System.err).
	 */
	private void waitUntilAllEvents()
	{
		boolean timeout = false;
		synchronized(events)
		{
			while (events.size() < expectedEvents.size() && !timeout)
				try
				{
					events.wait(50);
					timeout = true;
				}
				catch (InterruptedException e)
				{}
		}
		
		if (timeout) System.err.println("Timeout while waiting for all " +
				"expected events to be received..."); 
			/*assertTrue("Timeout while waiting for all expected " +
				"events to be received...", false);*/
	}

	/**
	 * Simulate typing a character into the buffer.
	 * @param offset Offset of the character to insert into the buffer.
	 * @param word The word typed so far (the insertion will be appended to it)
	 * @param insertion The character to type/insert.
	 * @param event The event expected to be fired by the WordTypedListener
	 * @param isWord Is the character typed assumed to be a word character?
	 * @throws TestOutOfDateException If the isWord assumption is not true
	 */
	private void 
	typeCharIntoBuffer(int offset, StringBuffer word, char insertion, WordTypedEvent event, boolean isWord) 
	throws TestOutOfDateException
	{
		if(isWord)
		{ checkIsWord(word, insertion); }
		else
		{ checkIsNotWord(word, insertion); }
		word.append(insertion);
		buffer.insert(offset, String.valueOf(insertion));
		expectedEvents.add(event);
	}

	/*
	 * Test method for 'net.jakubholy.jedit.autocomplete.WordTypedListener.contentInserted(JEditBuffer, int, int, int, int)'
	 */
	public void testContentInserted_withJump()
	{
		StringBuffer word = new StringBuffer(10);
		char insertion;
		WordTypedEvent event = null;
		int offset = 0;
		
		// Start a word
		insertion = 'a';
		event = new WordTypedEvent(WordTypedEvent.AT_START, 
				new StringBuffer(word).append(insertion), 
				String.valueOf(insertion));
		typeCharIntoBuffer(offset++, word, insertion, event, true);
		
		// Continue the word
		insertion = 'b';
		event = new WordTypedEvent(WordTypedEvent.INSIDE, 
				new StringBuffer(word).append(insertion), 
				String.valueOf(insertion));
		typeCharIntoBuffer(offset++, word, insertion, event, true);
		
		// Reset - insert elsewhere
		insertion = 'a';
		event = new WordTypedEvent(WordTypedEvent.RESET, 
				new StringBuffer(word), 
				null);
		typeCharIntoBuffer(0, word, insertion, event, true);
		
		// Check expected vs. received events:
		waitUntilAllEvents();
		assertEquals(expectedEvents, events);
	}

	/** Invoked by the observed WordTypedListener */
	public void update(Observable o, Object arg)
	{
		// Store the event for later use
		synchronized(events){
			events.add( arg );		
			events.notifyAll();
		}
		
	}
	
	////////////////////////////////////////////////////////////////////////////
	/*
	 * Remove 2 chars from the end of the word typed.
	 * Remove all the word.
	 */
	public void testContentRemoved()
	{
		StringBuffer word = new StringBuffer(10);
		char insertion;
		WordTypedEvent event = null;
		int offset = 0;
		
		// Start a word
		insertion = 'a';
		event = new WordTypedEvent(WordTypedEvent.AT_START, 
				new StringBuffer(word).append(insertion), 
				String.valueOf(insertion));
		typeCharIntoBuffer(offset++, word, insertion, event, true);
		
		// Continue the word
		insertion = 'b';
		event = new WordTypedEvent(WordTypedEvent.INSIDE, 
				new StringBuffer(word).append(insertion), 
				String.valueOf(insertion));
		typeCharIntoBuffer(offset++, word, insertion, event, true);
		
		// Continue the word
		insertion = 'c';
		event = new WordTypedEvent(WordTypedEvent.INSIDE, 
				new StringBuffer(word).append(insertion), 
				String.valueOf(insertion));
		typeCharIntoBuffer(offset++, word, insertion, event, true);
		
		// Remove 2 chars from the end
		{
			int removeLen = 2;
			int wordLen = word.length();
			word.delete(wordLen - removeLen, wordLen);
			event = new WordTypedEvent(WordTypedEvent.TRUNCATED, 
					new StringBuffer(word), 
					new Integer(removeLen));
			offset -= removeLen;
			buffer.remove(offset, removeLen);
			expectedEvents.add(event);
		}
		// ArrayIndexOut - proc testuje 'offset + length > contentMgr.getLength()'?!
		// Melo by snad byt jen offset < contentMgr.getLength() 
		// a offset >= length
		//
		// V contentMgr spravne nastavi gap na (offset, offset+length) a zkrati
		// contentMgr.getLength()[delka platneho textu] o length
		// (na pocatku gepStart=gepEnd=0, tu 0 gap posune do offset a posune end o length)
		
		// Remove all the word left
		{
			event = new WordTypedEvent(WordTypedEvent.RESET, 
					new StringBuffer(word), 
					null);
			offset -= word.length();
			buffer.remove(offset, word.length());
			expectedEvents.add(event);
		}
		
		// Check expected vs. received events:
		waitUntilAllEvents();
		assertEquals(expectedEvents, events);
	}
	
	///////////////////////////////////////////////////////////////////////////

	/**
	 * Assert that the assumption what is a word is correct. 
	 * @see PreferencesManager#getIsWordFilter()
	 * @param word 
	 * @param insertion
	 * @throws TestOutOfDateException If word+insertion isn't a word
	 */
	private void checkIsWord(StringBuffer word, char insertion) throws TestOutOfDateException
	{
		if(! isWordChecker.accept(word, insertion))
		{ 
			throw new TestOutOfDateException(word + "+" + insertion 
				+ " isn't word as assumed"); 
		}
	}

	/**
	 * Assert that the assumption what is not a word is correct. 
	 * @see PreferencesManager#getIsWordFilter()
	 * @param word 
	 * @param insertion
	 * @throws TestOutOfDateException If word+insertion is a word
	 */
	private void checkIsNotWord(StringBuffer word, char insertion) throws TestOutOfDateException
	{
		if(isWordChecker.accept(word, insertion))
		{ 
			throw new TestOutOfDateException(word + "+" + insertion 
				+ " is a word while the opposite was assumed"); 
		}
	}

}
