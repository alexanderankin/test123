/*
 * NetRexxScriptPlugin.nrx - NetRexx jEdit Scripting Plugin
 * Copyright (C) 2014 Kermit Kiser
 * Copyright (C) 2012 Kermit Kiser
 * Copyright (C) 2009 Kermit Kiser
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

 ******** remember to update the version number in NetRexx.props and build.xml  **********
 
 Version 1.0.0 (2014-03-15)
 
 	* add "shared" to keywords is netrexx.xml per Dave Woodman suggestion
 	* update help files to reflect version 1.0.0 in preparation for Plugin Central release
 
 Version 0.2.14 (2013-01-12)
 
 	* modify Add_jEdit_prefix to cast BufferedWriter to Writer so it will work with NetRexx 3.01
 	* modify NetRexxScriptPlugin.nrx to skip flush during netrexxstartscript to fix NPE in NetRexx 3.01
 	* move setup call (copy new user files) before classloader/interpreter init so preparse OK in 3.01
 	* skip interpreter rebuild after exec if running 3.01 or earlier (no exiting method present)
 	* remove exit statement from Android IDE macros
 
 Version 0.2.13 (2012-12-12)
 
	* skip compile for netrexxstartscript, update help for info on extra plugins for added features.	

 Version 0.2.12 (2012-12-12)
 
	* replace netrexxscript.nrx with netrexxstartscript.nrx - plugin should load now even if old version has not been deleted.	

 Version 0.2.11 (Dec 11, 2012)
 
	* mod NetRexx.nrx to save command/parm text whenever a button is clicked

 Version 0.2.10 (Dec 03, 2012)
 
	* use reflection to call NetRexxA.exiting() so plugin will work with NetRexx 3.01 (eliminated .size calls also for that)
	* updated Android IDE to handle library projects
	* modified first parse call after NetRexxA instantiated to pass my custom classloader to advanced NetRexx version so RxProxyLoader will chain to it (via thread context classloader) 
	
 Version 0.2.9 (Nov 07, 2012)
 
	* auto switch between interpreter parse output button and compiler error output button
	* force init of interpreter so classloading with it always works (cmdline classes failed if no prior interpret was run)
	
 Version 0.2.8 (Nov 05, 2012)
 
	* create any macros subdirectories and copy contents (not just "NetRexx" dirs)
	* fix missing EBComponent hook (handleMessage) problem
	* add our .jedit/NetRexx settings dir to automatic classpath for access to utility classes
	* run class macro was not setting NetRexxScriptPath property
	* buttons were not responding correctly
	* drop 4.2 support due to conflicts
	
 Version 0.2.7 (Oct 25, 2012)
 
	* create combination compile/interpret dockable window
	
 Version 0.2.6 (Oct 17, 2012)
 
	* Fix some Android IDE issues (binary copy jars and share common target info code)
	
 Version 0.2.5 (Oct 12, 2012)
 
	* Fix buf.getText call for jEdit 4.2 api in NetRexxScriptPlugin
	* Fix jEdit.getIntegerProperty call in NrxParser for jEdit 4.2 api
	* make ref to class PropertiesChanging in NrxParser soft to allow compile with jEdit 4.2 api
	* rename empty mode catalog file before copy new mode files
	* verify script name is a legal NetRexx symbol (no '-', etc in file name like some file systems allow!)
	* fix Add_jEdit_prefix macro pgm name prob and add missing imports
 
 Version 0.2.4 (Oct 10, 2012)
 
	* Fix leading null line miscount in NetRexxScriptPlugin module for errorlist report corrections
	* update Android IDE shell script to allow hiding the console if not needed
 		
 Version 0.2.3 (Oct 09, 2012)
 
	* Made all plugin dependencies optional - errorlist, sidekick, and commoncontrols are helpful but not required for NetRexx support. 
	* Added a base doc page to link to the compiler and interpreter help docs - they are not updated yet however!

 Version 0.2.2 (Oct 07, 2012)

	* if in prefix mode, scan programs for "class" instruction and add imports+class+prefix+main after prolog statements if not found
	* above change allows use of imports in scripts and static properties in the jEdit prefix
	* auto correct errorlist reports for prefix newlines count so prefix can be multiple lines long
	* add "GlobalObjects" public static placeholder for shared script objects
	* add new macros for inserting a main method or a complete jEdit type prefix with class+prefix-file+main-method
	* include Android IDE macros in distribution
	* in prefix mode, scripts are now interpreted from memory buffers without being written to disk with the prefix first
	* include new netrexx.xml syntax highlight mode file and auto-install it - this one handles nested comments better, (could use more Java class labels)
	* auto import org.gjt.sp.jedit., javax.swing., and netrexxplugin for scripts in prefix mode
	* version 0.2.x requires NetRexx tag after3.01-rev264 or later version of NetRexxC.jar
 
 Version 0.2.1 (Oct 04, 2012) 
 
 	* initial merge NetRexxScript and NetRexxDE to create new NetRexxPlugin - still separate consoles and option panels
 
 Version 0.2.0 (Sep 23, 2012) 

    * change all classes to package netrexxplugin - allows access to public interfaces from NetRexx scripts
    * change NetRexxC.jar to experimental after3.01 version with method resolution fixes - allows direct compile of TeeStream class
    * Add NetRexxErrorList class - allows ErrorList plugin use to be optional
    * add check of new NetRexxA.exiting api (after3.01 version) -  allows us to force a new NetRexxA instance if a script executed "Exit" instruction and killed the old one
    * add a copy of the new ant-netrexx.jar version - allows our plugin to build even if the optional NetRexxC task was not installed with Ant
    * auto add all plugin jars to classpath - allows scripts to access plugins without modifying the classpath
    * change macro directory structure per David recommendation
 
 Version 0.1.3 (Nov 30, 2009) 

    * Fix codepage output problem reported by George Hovey (TeeStream module)
    * Add flush button to console per George request (NetRexxScript module)
    * Change command entry field to HistoryTextField to allow recording and reentering commands (NetRexxScript)
    * fix bug - runbysearch was not correctly searching scriptpath in non preparse mode
    
 Version 0.1.2 (Nov 19, 2009) 

    *  Add check for active macro handler before creating one (fix prob with plugin manager restarts)
 
 Version 0.1.1 (Nov 07, 2009) (prep for second beta version)

    *  Add check for empty files (len<3) - issue error screen and exit
    *  Add outwin.commandstarted call for runmacro entry
 
 Version 0.1.0 (Oct 25, 2009) (first beta version, I hope!)

    *  Mod classloader and runmacro entry to load macro classes without a classpath search
    *  rebuild classloader in flush entry to unload any classes from memory

 Version 0.0.15 (Oct 22, 2009)

    *  Change to allow window to kill scripts started from menu runcurrent option
    *  allow command.nrx syntax on window command line
    *  Add custom classloader to execute java classes
    
 Version 0.0.14 (Oct 18, 2009)

    *  Add dockable window for script console output/input (final major feature!?)
 
 Version 0.0.13 (Oct 14, 2009)

    *  Trap parse error output and scan to flag errors in file buffers (requires ErrorList plugin)
 
 Version 0.0.12 (Oct 12, 2009)

    *  Add options for user specified classpath and scriptpath
 
 Version 0.0.11 (Oct 07, 2009)

    *  Change to use File.separator and File.pathSeparator chars for unix support
 
 Version 0.0.10 (Oct 07, 2009)

    *  Added function to run currently open script buffer
 
 Version 0.0.9 (Oct 05, 2009)

    *  Added code to change classpath system variable to include NetRexx before calling parse
       this seems to fix the problems with the missing netrexx.lang classes under the standard jEdit classpath
 
 Version 0.0.8 (Oct 03, 2009)

    *  Add plugin options panel for trace, verbosity, cache, flush, and preparse options
    *  added trace/notrace and verbosity parse options for user selection
    *  added code and option to prefix scripts with the jedit variables
    
 Version 0.0.7 (Sept. 29, 2009)

    *  Add new options for cache, flush, and preparse
    *  change class to extend EBPlugin and add handleMessage interface for editbus msgs to detect script changes
    *  added code to preserve parse results for cache flag and to locate and parse all files for preparse flag
    *  added code to open log viewer and show an error dialog box for parse errors
    
 Version 0.0.6 (Sept. 26, 2009)

    *  restore code to set scriptPath property as Macros.macro.getPath does not work in jEdit 4.2 and NetRexx scripts cannot call plugin code due to the different class loader structure
    *  add check for NetRexxC.jar in classpath and show error message panel if not found
    
Version 0.0.5 (Sept. 19, 2009)

    * remove pathing from jarfile access to allow placing in base jar directory
    * update startup code to copy all .nrx files in jar (except plugin classes) to macros\NetRexx directory
    * remove code to set scriptPath property and doc Macros.macro.getPath way to set the scriptPath variable
 
Version 0.0.4 (Sept. 18, 2009)

    * created html help file and added to the NetRexxScript.jar file. 

Version 0.0.3 (Sept. 2009)

    * created a macro.handler class and code to register it.
    * deactivated code in setup script that creates beanshell hooks.

Version 0.0.2 (Sept. 2009)

    * added netrexxscript.nrx setup script to scan directories and build beanshell invocation "hook" scripts for all NetRexx scripts.
    * added code to create NetRexx macro subdirectory and copy the setup script from the plugin jar to the subdirectory.  

Version 0.0.1 (Sept. 2009)

    * First version working - required hand coding of beanshell "hook" macros to start the NetRexx scripts with the same name. Solved the missing classpath problem using this one! 
 
 */
  
options strictsignal

--import errorlist
import org.gjt.sp.jedit.
import COM.ibm.netrexx.process.NetRexxA

package netrexxplugin

class NetRexxScriptPlugin public extends EBPlugin implements runnable, EBComponent
	
	properties public static
		outwin=NetRexxInterface	 null			--	save pointer to dockable window	
--		outwin=NetRexxScript				--	save pointer to dockable window	
	
	properties private
		
		av=View								--	save pointer to jEdit active view	
		interpreter = NetRexxA				--	holds NetRexx interpreter
		myloader=NetRexxScriptClassLoader	--	holds our custom class loader
--		flushinprogress="no"				--	flag to prevent flush loops
		
		cache="empty"						--	cache of parsed scriptnames
		backcache="empty"					--	cache of parsed scriptnames for reverse reference like error reporting
		revcache="empty"					--	cache of prefixed scriptnames (to avoid duplicates)

		scriptcache="empty"			--	new cache of prefixed scripts in memory
		commentlevel=0						--	shared prefix check variable
		scanstart=1										--	shared prefix check variable
		
		parseset=String[0]					--	array of script file names to parse
		prefixset=String[0]					--	array of script programs to parse
		
		flags=[String 'nocrossref']			--  parse flags per NetRexx user guide as a String array		
		parseflags='nocrossref compact'		--  parse flags per NetRexx user guide as a Rexx item
		
		setdir=String 						--	pass location of settings directory
		ps=File.pathSeparator
		fs=File.separator
		origname=""							--	save original name for runcurrent temp script copy
		
		jcp=String 							--	save original java classpath
		nrcpath=String	""					--	save path to NetRexxC.jar
		errpath=String						--	save path to ErrorList.jar
		jarpath=String ""				--	save the jar paths for all plugins
		utilityclasspath=String ""				--	save the plugin settings utility directory path
		
	properties private unused
		lastspath=String ""					--	save scriptpath in use by the plugin
		mypath=String	""					--	save path to NetRexxScript.jar
	properties private
		
		df=boolean 0						--	debug flag defaults to "false"
		testflag= 1						--	debug flag to trace only "n" hits
		
--		errorsource=errorlist.DefaultErrorSource
		errorsource=NetRexxErrorList

		sysin = InputStream
		sysout= PrintStream
		syserr= PrintStream
		tee1  = TeeStream
		tee2  = TeeStream
		tee3  = TeeStream
		out1  = PrintStream
		out2  = PrintStream
		bas1  = ByteArrayOutputStream
		bas2  = ByteArrayOutputStream

--									vars to run the script in it's own thread:
		sthread=Thread
		tparms=Rexx
		tmethod=Method
		
	properties private constant
		
		t=boolean 1		--	"true"
		f=boolean 0		--	"false"
		
	properties public static 
		
		lastcpath=String ""					--	save classpath in use by the interpreter
		scriptPath=String "bozo"
		nrsplugin=NetRexxScriptPlugin

	properties public constant
		
		NAME = String  "NetRexxScript"
		OPTION_PREFIX = String "options.netrexxscript."
	    
--		Perform plugin initialization			---------------------------------------------------------------------------------------------------------------------

	method start()
		nrsplugin=this
		version=jEdit.getProperty("plugin.netrexxplugin.NetRexxPlugin.version","notfound")
		System.out.println("NetRexx plugin version" version "starting")
 		do
		jf=JarFile(jEdit.getPlugin("netrexxplugin.NetRexxPlugin").getPluginJAR.getFile)
		je=jf.getJarEntry("build.number")
		if je\=null then do
			ir=BufferedReader(InputStreamReader(jf.getInputStream(je)))
			/*l1=*/ ir.readline;l2=ir.readline;l3=ir.readline
--			l1=ir.readline;l2=ir.readline;l3=ir.readline
			System.out.println(l3" "Rexx(l2).substr(2))
			end
		catch ioe=IOException
			System.out.println("build.number" ioe.toString)
		end

		setdir=jEdit.getSettingsDirectory()	--	string with settings directory path (add \macros to get default script paths)		
		
--	init some permanent properties we will need later	
		
    	jEdit.setBooleanProperty(OPTION_PREFIX"debug",jEdit.getBooleanProperty(OPTION_PREFIX"debug",f)) 
    	df=jEdit.getBooleanProperty(OPTION_PREFIX"debug",f) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"clear",jEdit.getBooleanProperty(OPTION_PREFIX"clear",t)) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"trace",jEdit.getBooleanProperty(OPTION_PREFIX"trace",t)) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"cache",jEdit.getBooleanProperty(OPTION_PREFIX"cache",t)) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"preparse",jEdit.getBooleanProperty(OPTION_PREFIX"preparse",t)) 
    	jEdit.setBooleanProperty(OPTION_PREFIX"addjeditvars",jEdit.getBooleanProperty(OPTION_PREFIX"addjeditvars",t))
    	jEdit.setProperty(OPTION_PREFIX"verbosity",jEdit.getProperty(OPTION_PREFIX"verbosity",'verbose3'))
    	jEdit.setProperty(OPTION_PREFIX"classpath",jEdit.getProperty(OPTION_PREFIX"classpath",""))   
    	jEdit.setProperty(OPTION_PREFIX"scriptpath",jEdit.getProperty(OPTION_PREFIX"scriptpath",""))       						
  		
--------------------   locate the NetRexxC.jar file and other things so we can add them to the classpath for the interpreter  ----		
		jcp=System.getProperty(String "java.class.path")
		NRCS=String("NetRexxC.jar")
		
		if jcp.indexOf(NRCS)<0 then do
			ja=jEdit.getPluginJARs
			loop jp=0 to ja.length-1
				if ja[jp].getPath.indexOf(NRCS)>=0 then nrcpath=ja[jp].getPath
				if Rexx(ja[jp].getPath).pos("NetRexxPlugin.jar")\=0 then mypath=ja[jp].getPath
				if Rexx(ja[jp].getPath).pos("ErrorList.jar")\=0 then errpath=ja[jp].getPath
				jarpath=Rexx(jarpath||ps||ja[jp].getPath).strip("b",ps).toString			--		remove excess path seps and save plugin jar paths
				end
			end		

		utilityclasspath=setdir||fs'NetRexx'
--		say "utilityclasspath="utilityclasspath"<=="

--	create some external processors and hooks

		sysout=System.out									--	save original IO streams
		syserr=System.err
		sysin=System.in
		System.setIn(NetRexxScriptPlugin.sysin(sysin))		--	set intercept for "ask" instructions			
		bas1 = ByteArrayOutputStream(1000)					--	build some capture streams for output
		out1 = PrintStream(bas1,t)
		bas2 = ByteArrayOutputStream(1000)
		out2 = PrintStream(bas2,t)
		tee1 = TeeStream(System.out, out1)
		tee2 = TeeStream(System.err, out1)
		tee3 = TeeStream(tee1, out2)
	
		setclasspath('init')								-- set custom classpath
		say "load REXXIO class to pickup IO streams" 	 --  see if this sets printstream for "say" instructions	

		setup														--	perform any new user setup
			
		newloader											-- build a custom classloader
		newinterpreter										-- make a NetRexx interpreter with current classpath
		setclasspath('off')									 
			
		EditBus.addToBus(EBComponent this)		--	make sure we are on the bus
		
		if Macros.getHandler("netrexx")=null then do	--	first start - load a macro handler
			mh=NetRexxScriptMacroHandler()						--	make a macro handler
			Macros.registerHandler(mh)							--	pass to jEdit
			end
		
		if errpath\=null then do
--		if errpath\="" then do
			errorsource=NetRexxErrorList()
--			errorsource=errorlist.DefaultErrorSource("NetRexxScript")
--			ErrorSource.registerErrorSource(errorsource)
			end

--	run the provided setup script
			do
			execute(setdir||fs'NetRexx'fs'netrexxstartscript.nrx scan')		--	check for netrexx scripts and provide hooks
			scriptcache='empty'								-- force cache empty before preparse check adds stuff
			cache='empty'								-- force cache empty before preparse check adds stuff
			backcache='empty'								-- force cache empty before preparse check adds stuff
			revcache="empty"
			end
		
		loop for 20											--	wait 2 secs for startup script, then kill it
			if sthread=null then leave
			Thread.sleep(100)
			catch oops=Exception
				say oops
			finally
				if sthread\=null then kill
			end		
			
-- if the preparse flag is on, try to parse all scripts we can find
	
		if jEdit.getBooleanProperty(OPTION_PREFIX"preparse") then -
			if \parseall then jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)	--	try to parse all current nrx script files				

		say "NetRexx plugin started"

method setup		--	initial setup stuff: creates directories and loads files from our jar
  						
--	create some directorys for NetRexx scripts
/*
		tempdir=String setdir||fs'NetRexx'
		tdf=File(tempdir)
		if \tdf.exists then do
			tdf.mkdir
			if \tdf.exists then do
				say 'unable to create NetRexx temp script directory:' tempdir
				jEdit.setBooleanProperty(OPTION_PREFIX"addjeditvars",f)
--				return
				end
				else say 'created NetRexx temp script directory:' tempdir
			end		
*/			
/*			
		scriptdir = String setdir||fs'macros'fs'NetRexx'
		scriptdir2=String setdir||fs'macros'fs'NetRexxScript'
		scriptdir3=String setdir||fs'macros'fs'NetRexxScript'fs'samples'
		sdf=File(scriptdir)
		sdf2=File(scriptdir2)
		sdf3=File(scriptdir3)
		if \tdf.exists then do
			tdf.mkdir
			if \tdf.exists then do
				say 'unable to create NetRexx temp script directory:' tempdir
				jEdit.setBooleanProperty(OPTION_PREFIX"addjeditvars",f)
--				return
				end
				else say 'created NetRexx temp script directory:' tempdir
			end		
		if \sdf.exists then do
			sdf.mkdir
			if \sdf.exists then do
				say 'unable to create NetRexx script directory:' scriptdir
--				return
				end
				else say 'created NetRexx script directory:' scriptdir
			end
		if \sdf2.exists then do
			sdf2.mkdir
			if \sdf2.exists then do
				say 'unable to create NetRexx script sample directory:' scriptdir2
--				return
				end
				else say 'created NetRexx script sample directory:' scriptdir2
			end			
		if \sdf3.exists then do
			sdf3.mkdir
			if \sdf3.exists then do
				say 'unable to create NetRexx script sample directory:' scriptdir3
--				return
				end
				else say 'created NetRexx script sample directory:' scriptdir3
			end						
*/
--	install the setup and sample scripts

			--		first see if we can rename an old prefix file which will not work with the new NetRexxPlugin
				pf=File(setdir||fs'NetRexx'fs'prefix.txt')
				if pf.exists then do
					opf=File(setdir||fs'NetRexx'fs'old.prefix.txt')
					pf.renameTo(opf)
--					catch badguy=Exception
--						say pf.getPath "rename prefix error =" badguy
					end		

		do		--		create any missing NetRexx directories in jEdit user home
			jf=JarFile(jEdit.getPlugin("netrexxplugin.NetRexxPlugin").getPluginJAR.getFile)
--			jf=JarFile(getPluginJAR.getFile)
			
			entries = jf.entries()
			loop while entries.hasMoreElements()				
				je=JarEntry entries.nextElement()
				jer=Rexx(je.getName)
				if je.isDirectory then 
					if jer.pos('NetRexx')>0 then makeadir(jer)
						else if jer.pos('macros')>0 then makeadir(jer)
--				if Rexx(je.getName).translate(fs,'/').pos('NetRexx')>0 then copyjarentry(jf,je,setdir)
--				if Rexx(je.getName).translate(fs,'/').pos('NetRexx'fs)>0 then copyjarentry(jf,je,setdir)
--	another Java "gotcha" - jar entries have unix file separators thus requireing the translate above					
				end

--																						now copy any jar files entries in a NetRexx or macros directory				
			entries = jf.entries()
			loop while entries.hasMoreElements()				
				je=JarEntry entries.nextElement()
				if \je.isDirectory then do
					jer=Rexx(je.getName)
					split=jer.lastpos('/')
					if split>0 then 
						if jer.delstr(split).pos('NetRexx')>0 then copyjarentry(jf,je,setdir)
							else if jer.delstr(split).pos('macros')>0 then copyjarentry(jf,je,setdir)
					end
--				if Rexx(je.getName).translate(fs,'/').pos('NetRexx')>0 then copyjarentry(jf,je,setdir)
--				if Rexx(je.getName).translate(fs,'/').pos('NetRexx'fs)>0 then copyjarentry(jf,je,setdir)
--	another Java "gotcha" - jar entries have unix file separators thus requireing the translate above					
				end
			catch err=Exception
				say "NetRexxScript.jar ==>" err
		end

		do
			cf1=File(setdir||fs'modes'fs'catalog')
			if cf1.length()=217 then do
				cfr=File(setdir||fs'modes'fs'empty-catalog')
				cf1.renameTo(cfr)
				end
				cf=File(setdir||fs'modes'fs'catalog')
				if \cf.exists then do
					bcf=BufferedWriter(FileWriter(cf))
					ncf=BufferedReader(FileReader(File(setdir||fs'NetRexx'fs'catalog')))
					copyfile(ncf,bcf)
					bcf.close
					end
				catch badguy=Exception
				say cf.getPath "copy mode error =" badguy
		end
		
		do
				mf=File(setdir||fs'modes'fs'netrexx.xml')
				if \mf.exists then do
					bmf=BufferedWriter(FileWriter(mf))
					nmf=BufferedReader(FileReader(File(setdir||fs'NetRexx'fs'netrexx.xml')))
					copyfile(nmf,bmf)
					bmf.close
					end
		catch badguy=Exception
				say mf.getPath "copy mode error =" badguy
		end
		
method makeadir(jer=Rexx)		
			tempdir=String setdir||fs||jer
			tdf=File(tempdir)
			if \tdf.exists then do
				tdf.mkdirs
				if \tdf.exists then say 'unable to create NetRexx directory:' tempdir
													 else say 'created NetRexx directory:' tempdir
				end		
				
-- shutdown the plugin:										-------------------------------------------------------------------------------------------------------
		
	method stop()
		interpreter = null
		System.setIn(sysin)						
		-- clear any error messages before quitting
		if errorsource\= null then do
 			errorsource.quit
/* 			errorsource.clear()
			ErrorSource.unregisterErrorSource(errorsource) */
			end
			
			EditBus.removeFromBus(EBComponent this)		--	make sure we get off the bus
			
--	unload NetRexxC.jar in case of restarting plugin
	  nrc=jEdit.getPluginJAR(nrcpath)
	  jEdit.removePluginJAR(nrc,0)
			
		say "NetRexx plugin stopped"
 
	method commonentry -- make sure run time variables are current
		
		setdir=jEdit.getSettingsDirectory()	--	string with settings directory path	
		
--		outwin=null
		if outwin=null then do
				av=jEdit.getActiveView
				if av\=null then do
					winout=NetRexxInterface NetRexx.interpret
					if winout=null then 
					winout=NetRexxInterface jEdit.getActiveView.getDockableWindowManager.getDockableWindow(NAME)
					if winout=null then outwin=null
						else outwin=NetRexxInterface winout
		--				else outwin=NetRexxScript winout
					end
				end
			
		myloader.setDebug(df)
		
-- main method called by macro selection or internally to execute a script:		-----------------------------------------------------------------------------------
		
	method execute(script=String,on=String "",incache=boolean 0) -- analyze script request and execute it
		
		say "NetRexx Plugin execute" script
		if df then trace all
		origname=on							--	save original script name in case using runcurrent temp copy
	
		if sthread\=null then do
			say "another script is active - cannot execute:"script
			return
			end

--	analyze and verify the script request
		
		rscript=Rexx(script)' '
		if rscript.pos('.nrx ')=0 then do
			Macros.error(jEdit.getActiveView,"The file is not a NetRexx script:\n" rscript)
			if outwin\=null then do;outwin.commandended;end
			return
			end
		sscript=Rexx(script)
		sscript=sscript.substr(sscript.lastpos(fs)+1)
		sscript=sscript.substr(1,sscript.lastpos('.')-1)
		if sscript.verify('_$€'||'a'.sequence('z')||'A'.sequence('Z')||'0'.sequence('9'))>0 then do
			Macros.error(jEdit.getActiveView,"Invalid NetRexx program name:\n" rscript)
			if outwin\=null then do;outwin.commandended;end
			return
			end
		
		parse rscript sname '.nrx ' sparms		-- 	capture any passed parms
		sname=sname'.nrx'						--	reattach file type
		spath=sname.left(sname.lastpos(fs))
		sname=sname.substr(sname.lastpos(fs)+1)
		stype=sname.substr(sname.lastpos('.'))
		sname=sname.left(sname.lastpos('.')-1)
		fname=spath||sname||stype
		
		if jEdit.getBooleanProperty(OPTION_PREFIX"clear",t) then - 
			if outwin\=null then outwin.clearparseout
		
--	 parse the file(s)
		if \cache.exists(fname), incache then do		--	if the file is not already parsed, do it  (precached dirty buffer is ok too)
			if scriptcache.exists(fname) then flen=scriptcache[fname].length
				else do
			fchk=File(fname)
			if df then say "file len="fchk.length
				flen=fchk.length
				end
			if flen<3 then do
--			if fchk.length<3 then do
				Macros.error(jEdit.getActiveView,"Cannot execute empty file:\n" fname)
				if outwin\=null then outwin.commandended
				return
				end
			if \incache then 
				addtocache(spath,sname||stype)
			if \parse(fname) then return 	-- parse the file(s), using the flags
			end
				
		if \jEdit.getBooleanProperty(OPTION_PREFIX"cache") then do
			scriptcache='empty'	-- if not using cache, force empty it
			cache='empty'	-- if not using cache, force empty it
			backcache='empty'	-- if not using cache, force empty it
			revcache="empty"	-- if not using cache, force empty it
			end
			
--	save the scriptPath for access by the script			
		scriptPath=String(fname)
		jEdit.setTemporaryProperty("NetRexxScriptPath",scriptPath)		--		save scriptPath for jEdit 4.2 NetRexx script use

		loadandgo(sname,sparms)
		
	method loadandgo(sname=Rexx,sparms=String)		--	load a class and run it's main method
		if df then trace results
-- 	find the script's class
		sscript = String sname
		setclasspath('on')

		savecontextloader=Thread.currentThread().getContextClassLoader()		--		the getClassObject call links the interpreter RxProxyLoader class loader chain!
		Thread.currentThread().setContextClassLoader(myloader)		--		one classloader to rule them all!
	
			scriptClass=interpreter.getClassObject(null, sscript) 	-- find the script's class
		
		Thread.currentThread().setContextClassLoader(savecontextloader)		--		reset classloader 
			
		if scriptClass=null then do
			do				 
			scriptClass=myloader.loadClass(sscript)
			catch loaderror=Exception
				say "load error="loaderror
				say "NetRexxScript could not find class for" sname
				setclasspath('off')
			end
				
			if scriptClass=null then do
					if outwin\=null then do;outwin.commandended;end
					av=jEdit.getActiveView;if av=null then return
					Macros.error(av,"The command class could not be located:\n" sname )
					return
					end
			end
		
		justgo(scriptClass,sname,sparms)
			
	method justgo(scriptClass=Class,sname=Rexx,sparms=String)		--	load a class and run it's main method
		if df then trace results

--	find the 'main' method; it takes an array of Strings as its argument
		do

			--		this should link interpreter to my classloader in advanced after3.01 NetRexx version with RxProxyLoader mod
		savecontextloader=Thread.currentThread().getContextClassLoader()		--		the getClassObject call links the interpreter RxProxyLoader class loader chain!
		Thread.currentThread().setContextClassLoader(myloader)		--		one classloader to rule them all! 
	
			classes=[interpreter.getClassObject('java.lang', 'String', 1)]
		
		Thread.currentThread().setContextClassLoader(savecontextloader)		--		reset classloader 
				
			mainMethod=scriptClass.getMethod('main', classes)
			if mainMethod=null then do
				say "could not find main method in" sname
				setclasspath('off')
				av=jEdit.getActiveView;if av=null then return
				if outwin\=null then do;outwin.commandended;end
				Macros.error(av,"The command method could not be located:\n" sname )
				return
				end
			catch e=Exception
				say e
				if outwin\=null then do;outwin.commandended;end
				setclasspath('off')
				return
			end

--	now invoke it with a separate thread to keep interface alive
		tmethod=mainMethod
		tparms=sparms
		sthread=Thread(this,sname)
		sthread.setDaemon(t)			--	insure thread ends if jEdit closes
		sthread.setContextClassLoader(myloader)		--		one classloader to rule them all!
		sthread.start

	method run
		
		invokeit(tmethod,tparms)
		
	method invokeit(mainMethod=Method,sparms) --signals IllegalAccessException			--	invoke it with a null instance (it's static)
		values=Object[1]
		sa=String[1];sa[0]=String sparms
		values[0]=sa
		setclasspath('on')				--	setup modified classpath for interpreter

		bas1.reset
		bas2.reset
		if outwin\=null then do
			tee3.setArea(outwin.getscriptout)
			tee2.setArea(outwin.gettraceout)
			tee1.setArea(outwin.gettraceout)
			outwin.commandstarted
			if jEdit.getBooleanProperty(OPTION_PREFIX"clear",t) then do 
				outwin.clearscriptout;outwin.cleartraceout;
				end
			outwin.show("scriptout")
			end

		do
			if df then say "mainMethod="mainMethod
			mainMethod.invoke(null, values)
			catch error=Exception
				say "invokeit error="error
--				say "note ***: If NetRexxC is in the Java lib\\ext directory it will cause invocation exceptions."
				say error.getCause
				error.getCause.printStackTrace
			end

		cleancup						--	clean command environment up after done
		sthread=null					--  erase thread pointer
   	
		if Thread.currentThread.getName\="netrexxstartscript" then
			do				--		reinit interpreter environment if someone used an "Exit" statement  2012-12-01
			exitingmethod=interpreter.getClass().getMethod('exiting',null)
			exiting=Boolean exitingmethod.invoke(interpreter,null)
			if exiting.booleanValue() then rebuildinterpreter
			catch e=Exception		--	probably no exiting method in interpreter == most likely 3.01 or prior == skip interpreter rebuild for performance reasons
--			rebuildinterpreter		--	warn 3.01 or earlier users to restart jEdit if a script call to "EXIT" statement kills interpreter
    		end
/*    	
		if interpreter.exiting then do					--		reinit interpreter environment if someone used an "Exit" statement  2012-09-21
			setclasspath('on')
				newinterpreter
			setclasspath('off')
				flush
				end
*/			
	method rebuildinterpreter						--	interpreter may have been shutdown by EXIT statement - need to reinitialize
--					setclasspath('on')
--					newinterpreter
--					setclasspath('off')
					flush
					
	method cleancup						--	also called by kill thread entry point
		if df then trace results
		if outwin\=null then do
			tee3.setArea(null)
			tee2.setArea(null)
			tee1.setArea(null)
			outwin.show("scriptout")
			outwin.commandended					
			end
		bas1.reset
		bas2.reset
		setclasspath('off')				--	restore the original classpath value in case someone else checks it	
			
--	end of script execution method		--	start of externally called methods	---------------------------------
	
method kill
	if sthread\=null then sthread.stop
	sthread=null
	cleancup
	flush
		
method interrupt
	if sthread\=null then sthread.interrupt

method handleMessage(msg=EBMessage)		--	make sure we notice any changes made to a script
	if msg<=BufferUpdate then do
		bu = BufferUpdate msg
		if bu.getWhat="SAVED" then do
			if df then say "NetRexxScript handleMessage called:" bu
			bi=bu.getBuffer
			if df then say "name="bi.getName
			bpath=bi.getPath
			if df then say "path="bpath
			if Rexx(bi.getName).pos(".nrx")=0 then return
			backcache[cache[bpath]]=null		--	remove it from the cache
			cache[bpath]=null		--	remove it from the cache
			revcache[File(bpath).getName]=null
			if Rexx(bpath).pos("macros")>0 then Macros.loadMacros	--	rescan macros
			end
		end

method runmacro(script=String) -- called by macro menu selection
	if df then say "execute from macro menu="script
	if df then trace results
	commonentry
	if outwin=null then parms=""
		else do
			parms=" "outwin.getcmdline.getText
			outwin.commandstarted
			end
	if Rexx(script).pos(".class")>0 then do
		jEdit.setTemporaryProperty("NetRexxScriptPath",script)		--		save Path for script use
		classmacro=myloader.loadThisClass(script)
		justgo(classmacro,script,parms)
		catch loadfail=Exception
			say "macro="script loadfail
		finally
			return
		end
		
	execute(script||parms)
		
method runbysearch(cmd=Rexx)			--	called by dockable window command line
	if df then say "execute by search="cmd
	if df then trace all
	commonentry
	parse cmd cmdname parms
	if cmdname.right(4)=".nrx" then cmdnrx=cmdname
							   else cmdnrx=cmdname".nrx"
	cmdbare=cmdnrx.left(cmdnrx.pos(".nrx")-1)
	if revcache.exists(cmdnrx) then do
		usename=revcache[cmdnrx]
		execute(usename' 'parms)
		return
		end
	findname=searchlibs(cmdbare)
	if findname\="" then execute(findname' 'parms)
					else loadandgo(cmdbare,parms)

method runcurrent(v=View,buf=Buffer,parms="") 
	if df then trace all
	commonentry
	tmpdir=setdir||fs||"NetRexx"fs"temp"
	tdf=File(tmpdir);if \tdf.exists then tdf.mkdirs
			
	if df then say 'parms='parms
	if df then say 'buf.getPath='buf.getPath
		on=buf.getPath
	if buf.isDirty then do
/*		
		if buf.isUntitled then tn=tmpdir||fs'current.nrx'		--		give it a temp name
			else tn=tmpdir||fs||buf.getName					--		give it a temp name
		tf=File(tn)
		if tf.exists then tf.delete							--		delete any old temp copy
	*/		
		if buf.isUntitled then sn='current_buffer.nrx'		--		give it a temp name
			else sn=buf.getName					--		give it a temp name
		onr=Rexx(on)
		if buf.isUntitled then dir='unsaved'fs		--		give it a temp name
			else dir=onr.substr(1,onr.lastpos(fs))	--		give it a temp name
		scriptreader2=BufferedReader(StringReader(buf.getText(0,buf.getLength())))
		tn=dir||sn

--		buf.save(v,tn,f)									--		save a temp copy of the file
--		VFSManager.waitForRequests()						--		wait til save is done
		clearfromcache(tn)
		if tn\=buf.getPath then clearfromcache(buf.getPath)
/*
		if cache.exists(tn) then backcache[cache[tn]]=null	--		invalidate any cache entry for the file
		if cache.exists(tn) then cache[tn]=null				--		invalidate any cache entry for the file
		if cache.exists(tn) then if scriptcache.exists(tn) then scriptcache[tn]=null				--		invalidate any cache entry for the file
		if cache.exists(buf.getPath) then cache[buf.getPath]=null  --  invalidate any cache entry for the file
		if cache.exists(buf.getPath) then if scriptcache.exists(buf.getPath) then scriptcache[buf.getPath]=null				--		invalidate any cache entry for the file
		if revcache.exists(sn) then revcache[sn]=null	--	invalidate any cache entry for the file			
--		if revcache.exists(tf.getName) then revcache[tf.getName]=null	--	invalidate any cache entry for the file
--		if tf.canRead then execute(tn' 'parms,on)						--		run it if we got it
*/
		origname=on		--		setup for backcache error reporting link
		addtocachep2(dir,sn,scriptreader2)
		execute(tn' 'parms,on,1)					--		execute in pre-cached mode
--		if parse(on) then execute(tn' 'parms,on)
		
		clearfromcache(tn)		--		make sure dirty bufs are not cached!
/*
		if cache.exists(tn) then backcache[cache[tn]]=null	--		invalidate any cache entry for the file
		if cache.exists(tn) then if scriptcache.exists(tn) then scriptcache[tn]=null				--		invalidate any cache entry for the file
		if cache.exists(tn) then cache[tn]=null				--		invalidate any cache entry for the file
--		if revcache.exists(tf.getName) then revcache[tf.getName]=null	--	invalidate any cache entry for the file
		if revcache.exists(sn) then revcache[sn]=null	--	invalidate any cache entry for the file
*/		
		return
		end
		
	execute(buf.getPath' 'parms)										--	run an unmodified script
	
method clearfromcache(tn)
	dn=tn.substr(1,tn.lastpos(fs)).strip('t',fs)
	sn=tn.substr(tn.lastpos(fs)+1)
	if cache.exists(tn) then do
					backcache[cache[tn]]=null	--		invalidate any cache entry for the file
					cache[tn]=null				--		invalidate any cache entry for the file
					if scriptcache.exists(tn) then scriptcache[tn]=null				--		invalidate any cache entry for the file
					if revcache.exists(sn) then revcache[sn]=null	--	invalidate any cache entry for the file
					end

method getClassPath
	if df then trace results
	ucp=jEdit.getProperty(OPTION_PREFIX"classpath","")			--	get the user specified classpath
--	say Rexx(jcp||ps||nrcpath||ps||ucp||ps||utilityclasspath||ps||jarpath).strip('b',ps)
	return Rexx(jcp||ps||nrcpath||ps||ucp||ps||utilityclasspath||ps||jarpath).strip('b',ps)

method getScriptPath
	if df then trace results
	usp=jEdit.getProperty(OPTION_PREFIX"scriptpath","")			--	get the user specified scriptpath
	md=setdir||fs||"macros"										--	jEdit macro directories
	return Rexx(usp||ps||md).strip('b',ps)
	
method optionflush		--	clears the cache and resets classpath/scriptpath if options are changed

	df=jEdit.getBooleanProperty(OPTION_PREFIX"debug",f) 		--	options may have changed
	if df then trace results
		
	newcpath=getClassPath
	if newcpath\=lastcpath then do
		setclasspath("on")
		newinterpreter					--	if class path changed, rebuild interpreter
		setclasspath("off")
		end
	
	newspath=getScriptPath
	lastcpath=newcpath
	lastspath=newspath
	flush													--	if path changes, flush memory
	
method flush		--	clears the cache by user menu request
	say "NetRexxScript flush called"
	if df then trace results
	cache="empty"
	scriptcache="empty"
	backcache="empty"
	revcache="empty"
	newloader				--		rebuild loader to clear any classes from memory
	setclasspath('on')
	newinterpreter	--		might as well reinit NetRexxA to clear memory there also
	setclasspath('off')
	if jEdit.getBooleanProperty(OPTION_PREFIX"preparse") then -
	  if \parseall then jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)	--	try to parse all current nrx script files
	
method newloader	--	create a new classloader (and flush any loaded classes from memory)
	if df then trace results
	thisloader=this.getClass.getClassLoader
	md=setdir||fs||"macros"
	myloader=NetRexxScriptClassLoader(thisloader,jEdit.getProperty(OPTION_PREFIX"classpath","")||ps||md||ps||utilityclasspath||ps||mypath)
	myloader.setDebug(df)
			
method cache		--		change the cache flag
	say "NetRexxScript cache called"
	if jEdit.getBooleanProperty(OPTION_PREFIX"cache") then do
			jEdit.setBooleanProperty(OPTION_PREFIX"cache",f)		--	turn off cache
			jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)	--	cannot preparse if no cache
			scriptcache='empty'
			cache='empty'
			backcache='empty'
			revcache="empty"
			end
		else jEdit.setBooleanProperty(OPTION_PREFIX"cache",t)
	
method preparse		--	sets the preparse flag and parses all scripts as requested
	say "NetRexxScript preparse called"
	if jEdit.getBooleanProperty(OPTION_PREFIX"preparse") then 		--	turn off preparse and empty the cache
		do
		jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)
		scriptcache='empty'		
		cache='empty'
		backcache='empty'
		revcache="empty"
		end
		else do
			jEdit.setBooleanProperty(OPTION_PREFIX"cache",t)		--	requires cacheing
			jEdit.setBooleanProperty(OPTION_PREFIX"preparse",t)	--	turn on preparse flag
			if \parseall then jEdit.setBooleanProperty(OPTION_PREFIX"preparse",f)	--	try to parse all current nrx script files
			end

-------------------------------------------------	start of internal utility methods: ------------------------			

method size(r=Rexx)	--	this method does not exist in NetRexx 3.01 Rexx class
	s=0;loop x over r;s=s+1;end;return s
	
method buildparseset	--	build an array of strings with file names to parse from the script name cache	
	if df then trace results	
	cc=int size(cache)	--	count cached files
--	cc=cache.size	--	count cached files
--	cc=0;loop cn over cache;cc=cc+1;end	--	count cached files
	if cc>0 then do						--	rebuild the cache of parsed scripts if any left
		parseset=String[cc]					--	reserve name array space
		prefixset=String[int size(scriptcache)]		--	reserve script array space
--		prefixset=String[scriptcache.size]		--	reserve script array space
		cc=0;
		loop psn over scriptcache
			parseset[cc]=psn
			prefixset[cc]=scriptcache[psn].toString
			cc=cc+1
			end
		loop cn over cache;
			if scriptcache[cn]="empty" then do
				parseset[cc]=cache[cn];
				if df then say cn'='cache[cn]
				cc=cc+1
				end
			end	--	build an array of file names to parse
		end
		
		else parseset=String[0]			--	nothing to parse

method setclasspath(o=Rexx)				--	temporarily alter the classpath for the NetRexx interpreter	

--	if df then say "java.class.path was="System.getProperty( "java.class.path" )			
	if 'on init'.pos(o)>0 then do
		newcpath=getClassPath
		System.setProperty(String "java.class.path",newcpath)		--	add NetRexx and user stuff to the classpath
		System.setOut(tee3)
		System.setErr(tee2)
		if o="init" then do
			lastcpath=newcpath
			lastspath=getScriptPath
			end
		end
	else do						--	reset all to vanilla (don't confuse other programs using this thread)
		System.setProperty(String "java.class.path",jcp)
		System.setOut(sysout)
		System.setErr(syserr)
		end
--	if df then say "java.class.path is="System.getProperty( "java.class.path" )			

method newinterpreter
	
		interpreter = NetRexxA()   -- make a NetRexx interpreter with current classpath
--		say "NetRexx interpreter loaded"  --  see if this sets printstream for "say" instructions
		interpreter.parse([String 'initapi'],[String 'return'],String[0])		--		force init of interpreter
		
method parseall							--		if preparse flag is set then we parse all found scripts here:
	if df then say "NetRexxScript parseall called"
	buildcache													--	get all script file names
	success=parse('all') 					--  parse the file(s), using the flags
	return success
	
method parse(fn=Rexx)
	buildparseset												--	build array of file name strings for parse call
	getoptions													--	set parse options array from properties
	setclasspath('on')
	if errorsource\= null then errorsource.clear
--	if outwin\=null then outwin.clearparseout	
	backupscriptcache="empty".copyindexed(scriptcache) 		--		backup prefixed script cache in case interpreter is messing it up 
--	if parseset.length >0 then success=interpreter.parse(parseset, flags) --  parse the file(s), using the flags

	if parseset.length >0 then success=interpreter.parse(parseset,prefixset, flags) --  parse the file(s), using the flags
		else success=1
	if df then say "script parse completed with code=" success
		
--	report any errors to ErrorList plugin and dock window:		
--				[C:\Documents and Settings\dad\.jedit\NetRexx\prefixed\error.nrx 1 424 4] Error: Keyword symbol expected
	ereader=BufferedReader(InputStreamReader(ByteArrayInputStream(bas1.toByteArray)),1000)
	loop while ereader.ready
		erl=ereader.readLine
		if df then say "parse out==>"erl
		if Rexx(erl).left(1)="[" then do
			parse erl '[' erlpref ']' emsg
			parse erlpref tfn eln eloc elen .
			parse emsg etype .
/*			
			if tfn.pos('prefixed')>0 then -					--	is file prefixed
				if eln = 1 then do;pff=File(setdir||fs||'NetRexx'fs'prefix.txt');eloc=eloc-pff.length;if df then say eloc pff.length;end
			tfn=backcache[tfn.translate(' ','\0')]
*/				
			if errorsource \= null then do
				lc=0;pl=0;rep=1
				tfn=tfn.translate(' ','\0') 
				if scriptcache.exists(tfn) then do
					fileinfo=scriptcache[tfn,'fileinfo']
					if fileinfo.exists('prefixlength') then do
							lc=fileinfo['linecount'];pl=fileinfo['prefixlength']
						if df then
							if etype="Error:" then say "eln="eln "tfn="tfn
							if eln>lc & eln<lc+pl+1 then rep=0			--		if error in prefix code, don't report it back to source file
							if eln>lc+pl then eln=eln-pl
						if df then
							if etype="Error:" then say "lc="lc "pl="pl "eln="eln "eloc="eloc "elen="elen "emsg="emsg
						if df then
							if etype="Error:" then saystring(scriptcache[tfn].toString)
							end
					end
--			if errpath \= null then do
			 if rep then 
				if etype="Warning:" then errorsource.addError(NetRexxErrorList.WARNING,tfn,eln-1,eloc-1,eloc+elen-1,emsg)
					else errorsource.addError(NetRexxErrorList.ERROR,tfn,eln-1,eloc-1,eloc+elen-1,emsg)
/* 				if etype="Warning:" then errorsource.addError(ErrorSource.WARNING,tfn,eln-1,eloc-1,eloc+elen-1,emsg)
					else errorsource.addError(ErrorSource.ERROR,tfn,eln-1,eloc-1,eloc+elen-1,emsg) */
				end
			if outwin\=null then outwin.addparseout('['tfn eln eloc elen']' emsg||"\n")
			end
		  else if outwin\=null then outwin.addparseout(erl||"\n")
		catch eio=IOException
			say eio
		end	
	
	if success=0 then do		--	handle any error in parse here
		if fn='all' then say "NetRexxScript parse all failed."
			else say "NetRexxScript execute failed:" fn
		av=jEdit.getActiveView;if av=null then return 0
		wm=jEdit.getActiveView.getDockableWindowManager()
		if outwin=null then do
			wm.showDockableWindow("log-viewer")
			if \wm.isDockableWindowVisible("log-viewer") then wm.toggleDockableWindow("log-viewer")
			jc=Component wm.getDockableWindow("log-viewer")
			end
			else do;jc=av;outwin.show('parseout');outwin.commandended;end
		if fn='all' then do
			scriptcache='empty'
			cache='empty'	--	clear the cache
			backcache='empty'	--	clear the cache
			revcache="empty"
			if outwin=null then -
				 Macros.error(jc,"One or more NetRexx scripts failed to parse correctly - cache flushed - please check the activity log for messages:\n")
			else Macros.error(jc,"One or more NetRexx scripts failed to parse correctly - cache flushed - please check the parse log for messages:\n")
			end
		  else do			--		not a parse all mode
			scriptcache="empty".copyindexed(backupscriptcache)		--	reload scriptcache
		  clearfromcache(fn)
/*		  
			backcache[cache[fn]]=null		--	remove it from the cache
			cache[fn]=null		--	remove it from the cache
			scriptcache[fn]=null		--	remove it from the cache
			revcache[File(fn).getName]=null
*/			
			if outwin=null then -			
				 Macros.error(jc,"The script failed to parse correctly - please check the activity log for messages:\n" fn )
			else Macros.error(jc,"The script failed to parse correctly - please check the parse log for messages:\n" fn )
			buildparseset			--	build array of file name strings for parse call
			if parseset.length>0 then do					--	rebuild the cache of parsed scripts if any left
				redosuccess=interpreter.parse(parseset, flags) 	-- parse the file(s), using the flags
				if df then say "script reparse completed with code=" redosuccess
				end		  	  
		    end
		end	
		
	setclasspath('off')
	bas1.reset			 	
	bas2.reset
	return success
	
method getoptions				--		read parse options and use to build a parse flags array
	
	if jEdit.getBooleanProperty(OPTION_PREFIX"trace") then popts=parseflags 'trace'
													  else popts=parseflags 'notrace'
																		  	  
	popts=popts jEdit.getProperty(OPTION_PREFIX"verbosity","verbose3")	
	if df then say "popts="popts
	flags=String[popts.words]
	loop i=0 to popts.words-1;flags[i]=popts.word(i+1);end

method searchlibs(scriptname)			--	scans script library path for a script by class name
	if df then trace all
	ulp=jEdit.getProperty(OPTION_PREFIX"scriptpath","")  -- get the user specified scriptpath
	loop while ulp\="" 
		parse ulp nextpath (ps) ulp
		if df then say "nextpath="nextpath
		ne=File(nextpath)
		if ne.isFile then if scriptname'.nrx'=ne.getName then return ne.getPath;else nop
			else do
				scriptpath=searchdir(nextpath,scriptname)
				if scriptpath\="" then return scriptpath
				end
		end
		
	d1=setdir||fs'macros'
	return searchdir(d1,scriptname)
	
method searchdir(dir,scriptname)
	if df then trace all
	filter=nrxFilter()
	if df then say "searching dir:"dir
	dirf=File(dir)
	scriptpath=checklist(dir,dirf.list(filter),scriptname)	--	first check any scripts in the dir
	if scriptpath\="" then return scriptpath
		
	fa=dirf.listFiles						--	array of names in the directory
	loop i=0 to fa.length-1					--	second search any subdirectories
		if fa[i].isDirectory then scriptpath=searchdir(fa[i].getPath,scriptname)	--	recursive call to self for subdirs
		if scriptpath\="" then return scriptpath
		end
		
	return ""

method checklist(dir=Rexx,fa=String[],scriptname)
	if df then trace all
	if fa.length=0 then return ""
	loop i=0 to fa.length-1
		if df then say fa[i]
		if scriptname".nrx"=fa[i] then return dir||fs||scriptname".nrx"
		end
	return ""
		
method buildcache			--	builds a cache array of script names to preparse - 1st macro dirs then user dirs
	
	d1=setdir||fs'macros'
	addadirtocache(d1)
	
	ulp=jEdit.getProperty(OPTION_PREFIX"scriptpath","")  -- get the user specified scriptpath
	loop while ulp\="" 
		parse ulp nextpath (ps) ulp
		if df then say "nextpath="nextpath
		ne=File(nextpath)
		if ne.isFile then addtocache(ne.getParent||fs,ne.getName)
			else addadirtocache(nextpath)
		end

	if df then say "---------parseset--------"
	if df then loop cn over cache;say cn'='cache[cn];end
		
method addadirtocache(dir=Rexx)		--	add all NetRexx files in a directory and it's subdirectories to cache		
	filter=nrxFilter()
	if df then say "adding dir to cache:"dir
	dirf=File(dir)
	addalltocache(dir,dirf.list(filter))	--	first add any scripts in the dir to the cache
	
	fa=dirf.listFiles						--	array of names in the directory
	loop i=0 to fa.length-1					--	second add any subdirectories to the cache (lower precedence)
		if fa[i].isDirectory then addadirtocache(fa[i].getPath)	--	recursive call to self for subdirs
		end
	
method addalltocache(dir=Rexx,fa=String[])
	if fa.length=0 then return
	loop i=0 to fa.length-1
		if df then say fa[i]
		addtocache(dir||fs,fa[i])
		end
		
method linkcache(dir=Rexx,sn=Rexx)
		cache[dir||sn]=dir||sn
		backcache[dir||sn]=dir||sn
		if origname \= "" then backcache[dir||sn]=origname
		revcache[sn]=dir||sn	
	
method addtocache(dir=Rexx,sn=Rexx)
	if df then
		if testflag<5 then trace results
		else trace off
			
	if revcache.exists(sn) then return 			--	don't allow duplicate script names
	if df then say "adding dir="dir "name="sn
	if \jEdit.getBooleanProperty(OPTION_PREFIX"addjeditvars") then do
		linkcache(dir,sn)
		return
		end
		
	do
/*
	scriptreader=BufferedReader(FileReader(dir||sn))
	scriptreader.mark(4096);line1=scriptreader.readline;scriptreader.reset	--	look at the first line of the script
	liner=Rexx(line1);liner=liner.translate(' ','\t');parse liner command .					--	extract a command keyword
	if 'import options package class'.wordpos(command) <>0 then do  	--	if user controlling things, don't prefix the script
		linkcache(dir,sn)
		return
		end
	*/
	scriptreader2=BufferedReader(FileReader(dir||sn))
	addtocachep2(dir,sn,scriptreader2)

	catch err=Exception
		say "addtocache error ==>" err
	end
	
method addtocachep2(dir=Rexx,sn=Rexx,scriptreader2=BufferedReader)			--		create separate part two entry for adding programs already in memory	
	do
	nrsdir=String setdir||fs'NetRexx'
/*	
	tempdir=String setdir||fs'NetRexx'fs"prefixed"
	tdf=File(tempdir);if \tdf.exists then tdf.mkdirs
	tf=File(tempdir||fs||sn)
	if tf.exists then tf.delete					--		clear any old modified file version
*/	
--	tofw=BufferedWriter(FileWriter(tf,1))		--		open temp file with append
	tosb=StringWriter(4096) 										--		temp script holder
	tofs=BufferedWriter(tosb)										--		open temp file with append
	
--	prefixreader=BufferedReader(FileReader(nrsdir||fs'prefix.txt'))
	prefixreader2=BufferedReader(FileReader(nrsdir||fs'prefix.txt'))
--	copyfile(prefixreader,tofw)					--		copy the prefix to the temp script file
--	copyfile(prefixreader2,tofs)					--		copy the prefix to the temp script file
 if jEdit.getBooleanProperty(OPTION_PREFIX"addjeditvars") then
	fileinfo=prefixfile(prefixreader2,scriptreader2,tofs,sn)					--		copy the prefixed file to the temp script file
 else fileinfo=copyfile(scriptreader2,tofs)					--		copy the script to temp output file stringbuf without a prefix
--	copyfile(scriptreader,tofw)					--		copy the script to temp output file
--	copyfile(scriptreader2,tofs)					--		copy the script to temp output file
	tofs.close
	cache[dir||sn]=dir||sn				--		point parse to modified script file
--	cache[dir||sn]=tempdir||fs||sn				--		point parse to modified script file
	scriptcache[dir||sn]=Rexx(tosb.getBuffer)		--		move temp program string buf into a Rexx collection
	scriptcache[dir||sn,'fileinfo']=fileinfo		--		save the error offsets info
 if df then
	if testflag<5 then do
		say tosb.getBuffer.toString
		saystring(tosb.getBuffer.toString)
		xx=scriptcache[dir||sn,'fileinfo']
		say "fileinfo exists?="scriptcache[dir||sn].exists('fileinfo')
		say "fileinfo="xx
		say "fileinfo[linecount]="xx["linecount"]
		say "fileinfo[prefixlength]="xx["prefixlength"]
		end
	
	backcache[dir||sn]=dir||sn			--		set back pointer for error reporting	
--	backcache[tempdir||fs||sn]=dir||sn			--		set back pointer for error reporting	
	if origname \= "" then backcache[dir||sn]=origname	--	set back pointer for error reporting	
--	if origname \= "" then backcache[tempdir||fs||sn]=origname	--	set back pointer for error reporting	
	revcache[sn]=dir||sn						--		reverse link the script name for duplicate checks
--	tofw.close
--	prefixreader.close
	prefixreader2.close
--	scriptreader.close
	scriptreader2.close

	catch err=Exception
		say "addtocache error ==>" err
	end
	
	testflag=testflag+1

------------------------------------------------------ general purpose routines -------------------------------------------------------

method saystring(s=String) signals IOException
	bsr= BufferedReader(StringReader(s))
	loop forever
		in=bsr.readLine
		if in=null then return
		say in
		end

method copyjarentry(jf=JarFile,je=JarEntry,scriptdir=String)	--	method to copy a jarfile entry to a directory
	if df then trace results	
	nrscript=scriptdir||fs||je.getName
	nrs=File(nrscript)
	if \nrs.exists then do
		rc=copyjarentrytofile(jf,je,nrs)
		if rc=1 then say je.getName "copied to:" scriptdir
		end
		
method copyjarentrytofile(jf=JarFile,je=JarEntry,nrs=File)
	if df then trace results
	do
		scriptstream=jf.getInputStream(je)
		if Rexx(je.getName).pos(".class")=0 & Rexx(je.getName).pos(".jar")=0 then do
				scriptreader=BufferedReader(InputStreamReader(scriptstream))
--				scriptwriter=BufferedWriter(OutputStreamWriter(outstream))
				scriptwriter=BufferedWriter(FileWriter(nrs))
				copyfile(scriptreader,scriptwriter)
				scriptwriter.close
				end
			else do
				outstream=FileOutputStream(nrs)
				copybin(scriptstream,outstream)
				outstream.close
				end
		catch badguy=Exception
			say je.getName "copy error =" badguy
			return 0
		end
	return 1
	
/* methods to copy a file:   */

method prefixfile(pfq=java.io.BufferedReader,ifq=java.io.BufferedReader,ofq=java.io.BufferedWriter,sn=Rexx) returns Rexx signals IOException
	if df then
	 if testflag<5 then trace results
		else trace off
		fileinfo="empty"
		fileinfo['linecount']=0	
		commentlevel=0
  loop label readloop forever
		rline=ifq.readline
		if rline = null then leave
		line=Rexx(rline)
		if line='' then do; if fileinfo['linecount']>0 then ofq.newline();fileinfo['linecount']=fileinfo['linecount']+1;iterate;end	
		scanstart=1
	 loop label scanline forever
	 	if line.verify(' \t','n',scanstart)=0 then do
				if fileinfo['linecount']>0 then ofq.newline()
				ofq.write(string line,0,line.length)
				fileinfo['linecount']=fileinfo['linecount']+1
				iterate readloop 		--	if remainder is all blanks, pass it on
				end
		if commentlevel=0 then
			if prolog(line) then do -- still in prolog
				if scanstart<line.length then iterate scanline		-- more to check on this line?
				if fileinfo['linecount']>0 then ofq.newline()
				ofq.write(string line,0,line.length)
				fileinfo['linecount']=fileinfo['linecount']+1
				iterate readloop
				end
			else do			--	not in prolog = class, method, or other
					if fileinfo['linecount']>0 then ofq.newline()
					if line.substr(scanstart).changestr('\t',' ').word(1).lower="class" then nop		--		if found class then skip prefix
					else do																																								--		if found method or something else, add a suitable prefix
						if line.substr(scanstart).changestr('\t',' ').word(1)="method" then fileinfo['prefixlength']=addprefix(pfq,ofq,sn,'nomain')
																										else fileinfo['prefixlength']=addprefix(pfq,ofq,sn)
					  ofq.newline()
						end
--												write the current line and copy the rest of the program code						
					ofq.write(string line,0,line.length)
					ofq.newline()
					copyfile(ifq,ofq)		--		copy remainder of program
					return fileinfo
						
					end -- not prolog
					
		  if stillcomment(line) then iterate scanline
/*		  	
				if fileinfo['linecount']>1 then ofq.newline()
				ofq.write(string line,0,line.length)
				fileinfo['linecount']=fileinfo['linecount']+1
				iterate readloop
	*/				
		 end scanline
				
		end readloop
		
	return fileinfo
	
method addprefix(ifq=BufferedReader,ofq=BufferedWriter,sn=Rexx,pt='withmain') returns Rexx signals IOException
	if df then
	 if testflag<5 then trace results
		else trace off
			
	linesadded=0
	
  line="		import org.gjt.sp.jedit."
  ofq.write(string line,0,line.length)			--		write an import statement for jEdit
	linesadded=linesadded+1
	
  line="		import netrexxplugin."
  ofq.newline()
  ofq.write(string line,0,line.length)			--		write an import statement for this plugin
	linesadded=linesadded+1
	
  line="		import javax.swing."
  ofq.newline()
  ofq.write(string line,0,line.length)			--		write an import statement for Swing
	linesadded=linesadded+1
	
	if sn.lastpos('.')>0 then cn=sn.left(sn.lastpos('.')-1)
		else cn=sn
	line="class" cn
  ofq.newline()
	ofq.write(string line,0,line.length)			--		write a class statement
	linesadded=linesadded+1
	
	ofq.newline()
	linesadded=linesadded+copyfile(ifq,ofq)
	
	if pt='nomain' then return linesadded
		
	line='    method main($007=String[]) static;arg=Rexx($007);arg=arg'
	ofq.newline()
	ofq.write(string line,0,line.length)			--		write a method statement
	linesadded=linesadded+1
	
	return linesadded
	
method stillcomment(line=Rexx) returns boolean
	if df then
		if testflag<5 then trace results
		else trace off
			
	cd=line.verify('*/','m',scanstart) 	--	possible comment delimiter
	
	if cd=0 then do			--		no comment change on this line
					scanstart=line.length+1
					return 1
					end
	
	if line.substr(cd,2)='/*' then do
		commentlevel=commentlevel+1	--	 deeper in debt
		scanstart=cd+2
		return 1
		end
		
	if line.substr(cd,2)='*/' then do
		commentlevel=commentlevel-1		--	less of a hole
		scanstart=cd+2
		if commentlevel = 0 then return 0
			else return 1
		end
		
	say "this can't happen!"
	return 1
	
method prolog(line=Rexx) returns boolean
	if df then
		if testflag<5 then trace results
		else trace off
			
	nb=line.verify(' \t','n',scanstart) 		--	find first non blank
	
	if nb=0 then do			--	nothing found ==> ignore it
					scanstart=line.length+1
					return 1
					end

	if line.substr(nb,2)='/*' 	then do
			commentlevel=commentlevel+1
			scanstart=nb+2
			return 1
			end
					
	if line.substr(nb,2)='--', 'options package import'.wordpos(line.substr(nb).word(1).lower)>0 then do
		scanstart=line.length+1			--		line comment or prolog statement ==> ignore rest of line
		return 1
		end
		
	return 0 		--		found something that does not look like prolog

method copyfile(ifq=java.io.BufferedReader,ofq=java.io.BufferedWriter) returns Rexx signals IOException
	if df then trace results
			
	line=ifq.readline
	if line = null then return 0
	linecount=1
	ofq.write(string line,0,line.length)
	trace off
  loop forever
			line=ifq.readline
			if line = null then leave
			linecount=linecount+1
			ofq.newline()
			ofq.write(string line,0,line.length)
			end	
			
	return linecount

method copybin(ifq=InputStream,ofq=OutputStream) binary signals IOException

	bite=ifq.read
  loop while bite \= -1
	ofq.write(bite)
	bite=ifq.read
	end		

-- special class required for .nrx file filtering
	
Class NetRexxScriptPlugin.nrxFilter implements FilenameFilter				--		filter to select .nrx files
	method accept(f=File,n=String) returns boolean
		fn=Rexx(n)
		if fn.right(4)='.nrx' then return 1
			else return 0
	
-- subclass to pass input from dock window to scripts

class NetRexxScriptPlugin.sysin dependent extends BufferedInputStream

	properties private
	
	istring=BufferedInputStream
	
	method sysin(x=InputStream)
		super(x)

	method available returns int signals IOException
		
		if parent.outwin=null then return 0
		if istring\=null then return istring.available
			else return 0
		
	method read returns int signals IOException
	
		if parent.outwin=null then return -1
		
		if istring=null then -
			istring=BufferedInputStream(StringBufferInputStream(parent.outwin.read'\r\n'))
			
		if available>0 then do
			c=istring.read
			if available=0 then istring=null
			return c
			end
		return -1

	method read(b=byte[],off=int,len=int) returns int signals IOException
		
		if parent.outwin=null then return -1
		istring=BufferedInputStream(StringBufferInputStream(parent.outwin.read'\r\n'))		
		
		if available>0 then do
			cnt=istring.read(b,off,len)
			if available=0 then istring=null
			return cnt	
			end
		return -1	

